/*! For license information please see solclient-full.js.LICENSE.txt */
!function(root, factory) {
    if ("object" === typeof exports && "object" === typeof module) module.exports = factory(); else if ("function" === typeof define && define.amd) define("solace", [], factory); else if ("object" === typeof exports) exports["solace"] = factory(); else root["solace"] = factory();
}(self, () => {
    return (() => {
        var __webpack_modules__ = {
            "./index.js": (module, __unused_webpack_exports, __webpack_require__) => {
                module.exports = __webpack_require__("./modules/solclient-core/api.js");
            },
            "./modules/solclient-convert/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Base64 = __webpack_require__("./modules/solclient-convert/lib/base64.js").Base64;
                const Bits = __webpack_require__("./modules/solclient-convert/lib/bits.js").Bits;
                const Convert = __webpack_require__("./modules/solclient-convert/lib/convert.js").Convert;
                const Hex = __webpack_require__("./modules/solclient-convert/lib/hex.js").Hex;
                const Long = __webpack_require__("./modules/solclient-convert/lib/long.js").Long;
                module.exports.Base64 = Base64;
                module.exports.Bits = Bits;
                module.exports.Convert = Convert;
                module.exports.Hex = Hex;
                module.exports.Long = Long;
            },
            "./modules/solclient-convert/lib/base64.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];
                const KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                const ENC_LUT = [ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ];
                class DecodeError extends Error {}
                const LegacyEncoder = {
                    base64_encode(input) {
                        let output = "";
                        let i = 0;
                        do {
                            const chr1 = input.charCodeAt(i++);
                            const chr2 = input.charCodeAt(i++);
                            const chr3 = input.charCodeAt(i++);
                            const enc1 = chr1 >> 2;
                            const enc2 = (3 & chr1) << 4 | chr2 >> 4;
                            let enc3 = (15 & chr2) << 2 | chr3 >> 6;
                            let enc4 = 63 & chr3;
                            if (isNaN(chr2)) enc3 = enc4 = 64; else if (isNaN(chr3)) enc4 = 64;
                            output += KEY_STR.charAt(enc1);
                            output += KEY_STR.charAt(enc2);
                            output += KEY_STR.charAt(enc3);
                            output += KEY_STR.charAt(enc4);
                        } while (i < input.length);
                        return output;
                    },
                    base64_decode(input) {
                        let output = "";
                        let i = 0;
                        do {
                            while (ENC_LUT[input.charCodeAt(i)] > 64) i++;
                            const enc1 = ENC_LUT[input.charCodeAt(i++)];
                            const enc2 = ENC_LUT[input.charCodeAt(i++)];
                            const enc3 = ENC_LUT[input.charCodeAt(i++)];
                            const enc4 = ENC_LUT[input.charCodeAt(i++)];
                            if (enc1 < 0 || enc2 < 0 || enc3 < 0 || enc4 < 0) throw new DecodeError("Invalid base64 character");
                            const chr1 = enc1 << 2 | enc2 >> 4;
                            const chr2 = (15 & enc2) << 4 | enc3 >> 2;
                            const chr3 = (3 & enc3) << 6 | enc4;
                            output += String.fromCharCode(chr1);
                            if (64 !== enc3) output += String.fromCharCode(chr2);
                            if (64 !== enc4) output += String.fromCharCode(chr3);
                        } while (i < input.length - 3);
                        return output;
                    }
                };
                const isNode = "undefined" === typeof window;
                const hasBuffer = "undefined" !== typeof Buffer;
                const hasBlob = "undefined" !== typeof Blob;
                const BufferEncoder = hasBuffer && (hasBlob || isNode) ? {
                    base64_encode: str => Buffer.from(str, "binary").toString("base64"),
                    base64_decode: str => Buffer.from(str, "base64").toString("binary")
                } : {};
                const WindowEncoder = "undefined" !== typeof window ? {
                    base64_encode: window["btoa"] ? b => window["btoa"](b) : null,
                    base64_decode: window["atob"] ? a => window["atob"](a) : null
                } : {};
                const Base64 = {
                    encode: WindowEncoder.base64_encode || BufferEncoder.base64_encode || LegacyEncoder.base64_encode,
                    decode: WindowEncoder.base64_decode || BufferEncoder.base64_decode || LegacyEncoder.base64_decode
                };
                module.exports.Base64 = Base64;
            },
            "./modules/solclient-convert/lib/bits.js": module => {
                const Bits = {
                    get(val, shift, numBits) {
                        return val >>> shift & (1 << numBits) - 1;
                    },
                    set(dataIn, val, shift, numBits) {
                        const curMask = (1 << numBits) - 1;
                        const shiftedVal = (val & curMask) << shift;
                        const data = dataIn & ~(curMask << shift);
                        return data | shiftedVal;
                    }
                };
                module.exports.Bits = Bits;
            },
            "./modules/solclient-convert/lib/convert.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Long = __webpack_require__("./node_modules/long/umd/index.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const BufferImpl = __webpack_require__("./node_modules/buffer/index.js").Buffer;
                const TWO_ZEROES_STR = String.fromCharCode(0, 0);
                const THREE_ZEROES_STR = String.fromCharCode(0, 0, 0);
                const FOUR_ZEROES_STR = String.fromCharCode(0, 0, 0, 0);
                const BYTEARRAY_CONVERT_CHUNK = 8192;
                const UNSIGNED_LSHIFT_24 = 256 * 256 * 256;
                const ARRAY_BUFFER_CONVERT_CHUNK = 32768;
                function uint8ArrayToString(data, format = void 0) {
                    const dataLength = data.byteLength;
                    const uint8DataArray = new Uint8Array(BufferImpl.from(data));
                    let result = "";
                    for (let i = 0; i < dataLength; i++) if (format && "hex" === format.toLowerCase()) result += uint8DataArray[i].toString(16).padStart(2, "0"); else result += String.fromCharCode(255 & uint8DataArray[i]);
                    return result;
                }
                function stringToUint8Array(data) {
                    const dataLength = data.length;
                    const arrayBuf = new ArrayBuffer(dataLength);
                    const uint8Array = new Uint8Array(arrayBuf, 0, dataLength);
                    for (let i = 0; i < dataLength; i++) uint8Array[i] = data.charCodeAt(i);
                    return uint8Array;
                }
                function hexStringToUint8Array(data) {
                    if (null == data) return new Uint8Array();
                    return Uint8Array.from(BufferImpl.from(data, "hex"));
                }
                function arrayBufferToString(ab) {
                    if (!ab) return "";
                    const len = ab.byteLength;
                    const u8 = new Uint8Array(ab);
                    if (len < ARRAY_BUFFER_CONVERT_CHUNK) return String.fromCharCode.apply(null, u8);
                    let k = 0;
                    let r = "";
                    while (k < len) {
                        r += String.fromCharCode.apply(null, u8.subarray(k, k + ARRAY_BUFFER_CONVERT_CHUNK));
                        k += ARRAY_BUFFER_CONVERT_CHUNK;
                    }
                    return r;
                }
                function stringToArrayBuffer(str) {
                    return stringToUint8Array(str).buffer;
                }
                function int8ToStr(int8) {
                    return String.fromCharCode(255 & int8);
                }
                function int16ToStr(int16) {
                    return String.fromCharCode(int16 >> 8 & 255) + String.fromCharCode(255 & int16);
                }
                function int24ToStr(int24) {
                    return String.fromCharCode(int24 >> 16 & 255) + String.fromCharCode(int24 >> 8 & 255) + String.fromCharCode(255 & int24);
                }
                function int32ToStr(int32) {
                    if (0 === int32) return FOUR_ZEROES_STR;
                    if (int32 > 0) {
                        if (int32 < 256) return THREE_ZEROES_STR + String.fromCharCode(int32);
                        if (int32 < 65536) return TWO_ZEROES_STR + String.fromCharCode(int32 >> 8) + String.fromCharCode(255 & int32);
                    }
                    return String.fromCharCode(int32 >> 24 & 255) + String.fromCharCode(int32 >> 16 & 255) + String.fromCharCode(int32 >> 8 & 255) + String.fromCharCode(255 & int32);
                }
                function int64ToStr(int64) {
                    if ("number" !== typeof int64) return int32ToStr(int64.high) + int32ToStr(int64.low);
                    if (int64 >= 0) {
                        if (int64 < 256) return FOUR_ZEROES_STR + THREE_ZEROES_STR + String.fromCharCode(int64);
                        if (int64 < 65536) return FOUR_ZEROES_STR + TWO_ZEROES_STR + String.fromCharCode(int64 >> 8) + String.fromCharCode(255 & int64);
                        if (int64 < 4294967296) return FOUR_ZEROES_STR + (String.fromCharCode(int64 >> 24 & 255) + String.fromCharCode(int64 >> 16 & 255) + String.fromCharCode(int64 >> 8 & 255) + String.fromCharCode(255 & int64));
                    }
                    return String.fromCharCode(int64 >> 56 & 255) + String.fromCharCode(int64 >> 48 & 255) + String.fromCharCode(int64 >> 40 & 255) + String.fromCharCode(int64 >> 32 & 255) + String.fromCharCode(int64 >> 24 & 255) + String.fromCharCode(int64 >> 16 & 255) + String.fromCharCode(int64 >> 8 & 255) + String.fromCharCode(255 & int64);
                }
                function byteArrayToStr(byteArray) {
                    const len = byteArray.length;
                    if (len < BYTEARRAY_CONVERT_CHUNK) return String.fromCharCode.apply(null, byteArray);
                    let k = 0;
                    let r = "";
                    while (k < len) {
                        r += String.fromCharCode.apply(null, byteArray.slice(k, k + BYTEARRAY_CONVERT_CHUNK));
                        k += BYTEARRAY_CONVERT_CHUNK;
                    }
                    return r;
                }
                function strToByteArray(str) {
                    const result = [];
                    let i;
                    for (i = 0; i < str.length; i++) result[i] = str.charCodeAt(i);
                    return result;
                }
                function strToHexArray(str) {
                    function toHex(c) {
                        return c.charCodeAt(0).toString(16);
                    }
                    return Array.prototype.map.call(str.split(""), toHex);
                }
                function strToInt8(data) {
                    return 255 & data.charCodeAt(0);
                }
                function strToInt16(data) {
                    return (data.charCodeAt(0) << 8) + data.charCodeAt(1);
                }
                function strToInt24(data) {
                    return (data.charCodeAt(0) << 16) + (data.charCodeAt(1) << 8) + data.charCodeAt(2);
                }
                function strToInt32(data) {
                    return (data.charCodeAt(0) << 24) + (data.charCodeAt(1) << 16) + (data.charCodeAt(2) << 8) + data.charCodeAt(3);
                }
                function strToUInt32(data) {
                    return data.charCodeAt(0) * UNSIGNED_LSHIFT_24 + (data.charCodeAt(1) << 16) + (data.charCodeAt(2) << 8) + data.charCodeAt(3);
                }
                function strToUInt64(data) {
                    return Long.fromBits(strToUInt32(data.substr(4, 4)), strToUInt32(data.substr(0, 4)), true);
                }
                function ucs2ToUtf8(ucs2) {
                    return unescape(encodeURIComponent(ucs2));
                }
                function utf8ToUcs2(utf8) {
                    return decodeURIComponent(escape(utf8));
                }
                function anythingToBuffer(value) {
                    if (BufferImpl.isBuffer(value)) return value;
                    if ("string" === typeof value) return BufferImpl.from(value, "latin1");
                    if (value instanceof ArrayBuffer) return BufferImpl.from(value);
                    if (value.buffer instanceof ArrayBuffer && "number" === typeof value.byteLength && "number" === typeof value.byteOffset) {
                        if (0 === value.byteOffset && value.byteLength === value.buffer.byteLength) return BufferImpl.from(value.buffer);
                        return BufferImpl.from(value.buffer, value.byteOffset, value.byteLength);
                    }
                    throw new OperationError("Parameter value failed validation", ErrorSubcode.PARAMETER_OUT_OF_RANGE, "Expecting Buffer/Uint8Array, also accepting string, ArrayBuffer, any TypedArray, or DataView.");
                }
                const Convert = {
                    arrayBufferToString: arrayBufferToString,
                    stringToArrayBuffer: stringToArrayBuffer,
                    uint8ArrayToString: uint8ArrayToString,
                    stringToUint8Array: stringToUint8Array,
                    hexStringToUint8Array: hexStringToUint8Array,
                    int8ToStr: int8ToStr,
                    strToInt8: strToInt8,
                    int16ToStr: int16ToStr,
                    strToInt16: strToInt16,
                    int24ToStr: int24ToStr,
                    strToInt24: strToInt24,
                    int32ToStr: int32ToStr,
                    strToInt32: strToInt32,
                    strToUInt32: strToUInt32,
                    int64ToStr: int64ToStr,
                    strToUInt64: strToUInt64,
                    byteArrayToStr: byteArrayToStr,
                    strToByteArray: strToByteArray,
                    strToHexArray: strToHexArray,
                    ucs2ToUtf8: ucs2ToUtf8,
                    utf8ToUcs2: utf8ToUcs2,
                    anythingToBuffer: anythingToBuffer
                };
                module.exports.Convert = Convert;
            },
            "./modules/solclient-convert/lib/hex.js": module => {
                function numToHex(n) {
                    if ("number" !== typeof n) return "";
                    const s = n.toString(16);
                    return s.length < 2 ? `0` + s : s;
                }
                function formatHexString(obj) {
                    if ("number" === typeof obj) return `0x` + numToHex(obj);
                    if ("object" === typeof obj && Array.isArray(obj)) return obj.map(numToHex).join();
                    if ("string" === typeof obj) return Array.prototype.map.call(obj, (_, i) => numToHex(obj.charCodeAt(i))).join("");
                    return null;
                }
                const Hex = {
                    formatHexString: formatHexString
                };
                module.exports.Hex = Hex;
            },
            "./modules/solclient-convert/lib/long.js": (module, __unused_webpack_exports, __webpack_require__) => {
                module.exports.Long = __webpack_require__("./node_modules/long/umd/index.js");
            },
            "./modules/solclient-core/api-internal.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Convert = __webpack_require__("./modules/solclient-convert/api.js");
                const Debug = __webpack_require__("./modules/solclient-debug/api.js");
                const Destination = __webpack_require__("./modules/solclient-destination/api.js");
                const Error = __webpack_require__("./modules/solclient-error/api.js");
                const ESKit = __webpack_require__("./modules/solclient-eskit/api.js");
                const Factory = __webpack_require__("./modules/solclient-factory/api.js");
                const FSM = __webpack_require__("./modules/solclient-fsm/api.js");
                const Log = __webpack_require__("./modules/solclient-log/api.js");
                const Message = __webpack_require__("./modules/solclient-message/api.js");
                const MessageTracing = __webpack_require__("./modules/solclient-message-tracing/api.js");
                const Publisher = __webpack_require__("./modules/solclient-message-publisher/api.js");
                const SDT = __webpack_require__("./modules/solclient-sdt/api.js");
                const Session = __webpack_require__("./modules/solclient-session/api.js");
                const SMF = __webpack_require__("./modules/solclient-smf/api.js");
                const SolcacheSession = __webpack_require__("./modules/solclient-solcache-session/api.js");
                const TestEnv = __webpack_require__("./modules/solclient-env/api.js");
                const Transport = __webpack_require__("./modules/solclient-transport/api.js");
                const Util = __webpack_require__("./modules/solclient-util/api.js");
                const Validate = __webpack_require__("./modules/solclient-validate/api.js");
                module.exports = {
                    Convert: Convert,
                    Debug: Debug,
                    Destination: Destination,
                    Error: Error,
                    ESKit: ESKit,
                    Factory: Factory,
                    FSM: FSM,
                    Log: Log,
                    Message: Message,
                    MessageTracing: MessageTracing,
                    Publisher: Publisher,
                    SDT: SDT,
                    Session: Session,
                    SMF: SMF,
                    SolcacheSession: SolcacheSession,
                    TestEnv: TestEnv,
                    Transport: Transport,
                    Util: Util,
                    Validate: Validate
                };
            },
            "./modules/solclient-core/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const FactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
                const {
                    SolclientFactory,
                    SolclientFactoryProfiles,
                    SolclientFactoryProperties
                } = FactoryLib;
                const Long = __webpack_require__("./modules/solclient-convert/api.js").Long;
                const {
                    Destination,
                    DestinationType,
                    Topic
                } = __webpack_require__("./modules/solclient-destination/api.js");
                const {
                    ErrorSubcode,
                    NotImplementedError,
                    OperationError,
                    RequestError,
                    RequestEventCode
                } = __webpack_require__("./modules/solclient-error/api.js");
                const makeIterator = __webpack_require__("./modules/solclient-eskit/api.js").makeIterator;
                const {
                    ConsoleLogImpl,
                    LogImpl,
                    LogLevel
                } = __webpack_require__("./modules/solclient-log/api.js");
                const {
                    Message,
                    MessageCacheStatus,
                    MessageDeliveryModeType,
                    MessageDumpFlag,
                    MessageOutcome,
                    MessageType,
                    MessageUserCosType,
                    ReplicationGroupMessageId
                } = __webpack_require__("./modules/solclient-message/api.js");
                const {
                    MessageConsumer,
                    MessageConsumerAcknowledgeMode,
                    MessageConsumerEventName,
                    MessageConsumerProperties,
                    QueueBrowser,
                    QueueBrowserEventName,
                    QueueBrowserProperties
                } = __webpack_require__("./modules/solclient-message-consumer/api.js");
                const {
                    ReplayStartLocation,
                    ReplayStartLocationBeginning
                } = __webpack_require__("./modules/solclient-replaystart/api.js");
                const {
                    MessagePublisherAcknowledgeMode,
                    MessagePublisherProperties
                } = __webpack_require__("./modules/solclient-message-publisher/api.js");
                const {
                    Baggage,
                    TraceContext,
                    TraceContextSetter
                } = __webpack_require__("./modules/solclient-message-tracing/api.js");
                const {
                    AbstractQueueDescriptor,
                    QueueAccessType,
                    QueueDescriptor,
                    QueueDiscardBehavior,
                    QueuePermissions,
                    QueueProperties,
                    QueueType,
                    EndpointNameComplaint
                } = __webpack_require__("./modules/solclient-queue/api.js");
                const {
                    SDTField,
                    SDTFieldType,
                    SDTMapContainer,
                    SDTStreamContainer,
                    SDTUnsupportedValueError,
                    SDTValueErrorSubcode
                } = __webpack_require__("./modules/solclient-sdt/api.js");
                const {
                    AuthenticationScheme,
                    CapabilityType,
                    MessageRxCBInfo,
                    MutableSessionProperty,
                    Session,
                    SessionEvent,
                    SessionEventCBInfo,
                    SessionEventCode,
                    SessionProperties,
                    SessionState,
                    SslDowngrade
                } = __webpack_require__("./modules/solclient-session/api.js");
                const {
                    CacheCBInfo,
                    CacheLiveDataAction,
                    CacheRequestResult,
                    CacheReturnCode,
                    CacheReturnSubcode,
                    CacheSession,
                    CacheSessionProperties
                } = __webpack_require__("./modules/solclient-solcache-session/api.js");
                const StatType = __webpack_require__("./modules/solclient-stats/api.js").StatType;
                const {
                    TransportError,
                    TransportProtocol
                } = __webpack_require__("./modules/solclient-transport/api.js");
                const Version = __webpack_require__("./modules/solclient-util/api.js").Version;
                const _internal = __webpack_require__("./modules/solclient-core/api-internal.js");
                const solace = {
                    AbstractQueueDescriptor: AbstractQueueDescriptor,
                    AuthenticationScheme: AuthenticationScheme,
                    Baggage: Baggage,
                    CacheCBInfo: CacheCBInfo,
                    CacheLiveDataAction: CacheLiveDataAction,
                    CacheRequestResult: CacheRequestResult,
                    CacheReturnCode: CacheReturnCode,
                    CacheReturnSubcode: CacheReturnSubcode,
                    CacheSession: CacheSession,
                    CacheSessionProperties: CacheSessionProperties,
                    CapabilityType: CapabilityType,
                    ConsoleLogImpl: ConsoleLogImpl,
                    Destination: Destination,
                    DestinationType: DestinationType,
                    ErrorSubcode: ErrorSubcode,
                    LogImpl: LogImpl,
                    LogLevel: LogLevel,
                    Long: Long,
                    Message: Message,
                    MessageCacheStatus: MessageCacheStatus,
                    MessageConsumer: MessageConsumer,
                    MessageConsumerAcknowledgeMode: MessageConsumerAcknowledgeMode,
                    MessageConsumerEventName: MessageConsumerEventName,
                    MessageConsumerProperties: MessageConsumerProperties,
                    MessageDeliveryModeType: MessageDeliveryModeType,
                    MessageDumpFlag: MessageDumpFlag,
                    MessageOutcome: MessageOutcome,
                    MessagePublisherAcknowledgeMode: MessagePublisherAcknowledgeMode,
                    MessagePublisherProperties: MessagePublisherProperties,
                    MessageRxCBInfo: MessageRxCBInfo,
                    MessageType: MessageType,
                    MessageUserCosType: MessageUserCosType,
                    MutableSessionProperty: MutableSessionProperty,
                    NotImplementedError: NotImplementedError,
                    OperationError: OperationError,
                    QueueAccessType: QueueAccessType,
                    QueueBrowser: QueueBrowser,
                    QueueBrowserEventName: QueueBrowserEventName,
                    QueueBrowserProperties: QueueBrowserProperties,
                    QueueDescriptor: QueueDescriptor,
                    QueueDiscardBehavior: QueueDiscardBehavior,
                    QueuePermissions: QueuePermissions,
                    QueueProperties: QueueProperties,
                    QueueType: QueueType,
                    EndpointNameComplaint: EndpointNameComplaint,
                    ReplayStartLocation: ReplayStartLocation,
                    ReplayStartLocationBeginning: ReplayStartLocationBeginning,
                    ReplicationGroupMessageId: ReplicationGroupMessageId,
                    RequestError: RequestError,
                    RequestEventCode: RequestEventCode,
                    SDTField: SDTField,
                    SDTFieldType: SDTFieldType,
                    SDTMapContainer: SDTMapContainer,
                    SDTStreamContainer: SDTStreamContainer,
                    SDTUnsupportedValueError: SDTUnsupportedValueError,
                    SDTValueErrorSubcode: SDTValueErrorSubcode,
                    Session: Session,
                    SessionEvent: SessionEvent,
                    SessionEventCBInfo: SessionEventCBInfo,
                    SessionEventCode: SessionEventCode,
                    SessionProperties: SessionProperties,
                    SessionState: SessionState,
                    SolclientFactory: SolclientFactory,
                    SolclientFactoryProfiles: SolclientFactoryProfiles,
                    SolclientFactoryProperties: SolclientFactoryProperties,
                    SslDowngrade: SslDowngrade,
                    StatType: StatType,
                    Topic: Topic,
                    TraceContext: TraceContext,
                    TraceContextSetter: TraceContextSetter,
                    TransportError: TransportError,
                    TransportProtocol: TransportProtocol,
                    Version: Version,
                    makeIterator: makeIterator,
                    _internal: _internal
                };
                Object.assign(module.exports, solace);
            },
            "./modules/solclient-debug/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Debug = __webpack_require__("./modules/solclient-debug/lib/debug.js").Debug;
                module.exports.Debug = Debug;
            },
            "./modules/solclient-debug/lib/debug.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const PRINTABLE_LUT = (() => {
                    const tmp = [];
                    for (let c = 0; c < 256; ++c) tmp[c] = c < 33 || c > 126 ? "." : String.fromCharCode(c);
                    return tmp;
                })();
                const SPACER = "   ";
                const UNPRINTABLE = ".";
                function formatDumpBytes(data, showDecode, leftPadding) {
                    const {
                        StringBuffer,
                        StringUtils
                    } = __webpack_require__("./modules/solclient-util/api.js");
                    const {
                        isEmpty,
                        padLeft,
                        padRight
                    } = StringUtils;
                    if (isEmpty(data)) return null;
                    const output = new StringBuffer();
                    const ascii = new StringBuffer();
                    const line = new StringBuffer();
                    let lineBytes = 0;
                    const asciiOffset = 54;
                    for (let i = 0, dataLen = data.length; i < dataLen; ++i) {
                        const ccode = data.charCodeAt(i);
                        line.append(padLeft(ccode.toString(16), 2, "0"), " ");
                        ascii.append(PRINTABLE_LUT[ccode] || UNPRINTABLE);
                        lineBytes++;
                        if (8 === lineBytes) line.append(SPACER);
                        if (16 === lineBytes || i === data.length - 1) {
                            if (leftPadding > 0) output.append(padRight("", leftPadding, " "));
                            output.append(padRight(line.toString(), asciiOffset, " "));
                            if (showDecode) output.append(ascii);
                            output.append("\n");
                            line.clear();
                            ascii.clear();
                            lineBytes = 0;
                        }
                    }
                    return output.toString();
                }
                function parseSMFStream(data) {
                    const {
                        Decode: {
                            decodeCompoundMessage
                        }
                    } = __webpack_require__("./modules/solclient-smf/api.js").Codec;
                    const {
                        LOG_WARN,
                        LOG_ERROR
                    } = __webpack_require__("./modules/solclient-log/api.js");
                    if (null === data) {
                        LOG_ERROR("data null in debugParseSmfStream");
                        return;
                    }
                    let pos = 0;
                    LOG_WARN(`parseSMFStream(): Starting parse, length ` + data.length);
                    while (pos < data.length) {
                        const incomingMsg = decodeCompoundMessage(data, pos);
                        const smf = incomingMsg ? incomingMsg.smfHeader : null;
                        if (!(incomingMsg && smf)) {
                            LOG_WARN("parseSMFStream(): couldn't decode message.");
                            LOG_WARN(`Position: ${pos} length: ` + data.length);
                            return;
                        }
                        LOG_WARN(`>> Pos(${pos}) Protocol ${smf.smf_protocol}, Length: ` + smf.messageLength);
                        pos += smf.messageLength;
                    }
                }
                const Debug = {
                    formatDumpBytes: formatDumpBytes,
                    parseSMFStream: parseSMFStream
                };
                module.exports.Debug = Debug;
            },
            "./modules/solclient-destination/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Destination = __webpack_require__("./modules/solclient-destination/lib/destination.js").Destination;
                const DestinationFromNetwork = __webpack_require__("./modules/solclient-destination/lib/destination-from-network.js").DestinationFromNetwork;
                const DestinationType = __webpack_require__("./modules/solclient-destination/lib/destination-type.js").DestinationType;
                const DestinationUtil = __webpack_require__("./modules/solclient-destination/lib/destination-util.js").DestinationUtil;
                const Parameter = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                const Queue = __webpack_require__("./modules/solclient-destination/lib/queue.js").Queue;
                const SolclientFactory = __webpack_require__("./modules/solclient-factory/api.js").SolclientFactory;
                const Topic = __webpack_require__("./modules/solclient-destination/lib/topic.js").Topic;
                SolclientFactory.createTopicDestination = SolclientFactory.createFactory(topicName => {
                    Parameter.isString("topicName", topicName);
                    return Topic.createFromName(topicName);
                });
                SolclientFactory.createTopic = SolclientFactory.createFactory(topicName => new Topic(topicName));
                SolclientFactory.createDurableQueueDestination = SolclientFactory.createFactory(queueName => {
                    Parameter.isString("queueName", queueName);
                    return Queue.createFromLocalName(queueName);
                });
                module.exports.Destination = Destination;
                module.exports.DestinationFromNetwork = DestinationFromNetwork;
                module.exports.DestinationType = DestinationType;
                module.exports.DestinationUtil = DestinationUtil;
                module.exports.Queue = Queue;
                module.exports.Topic = Topic;
            },
            "./modules/solclient-destination/lib/destination-from-network.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationType = __webpack_require__("./modules/solclient-destination/lib/destination-type.js").DestinationType;
                const DestinationUtil = __webpack_require__("./modules/solclient-destination/lib/destination-util.js").DestinationUtil;
                const Queue = __webpack_require__("./modules/solclient-destination/lib/queue.js").Queue;
                const Topic = __webpack_require__("./modules/solclient-destination/lib/topic.js").Topic;
                const QUEUE_PREFIX = "#P2P/QUE/";
                const QUEUE_PREFIX_LEN = QUEUE_PREFIX.length;
                const TEMPORARY_QUEUE_PREFIX = "#P2P/QTMP/";
                function createDestinationFromName(networkTopicName, networkTopicBytes = void 0) {
                    if (null === networkTopicName || 0 === networkTopicName.length) return null;
                    const spec = {
                        name: networkTopicName,
                        bytes: networkTopicBytes || DestinationUtil.encodeBytes(networkTopicName)
                    };
                    if ("#" === networkTopicName[0]) if (networkTopicName.startsWith(QUEUE_PREFIX)) {
                        const offset = QUEUE_PREFIX_LEN;
                        spec.name = networkTopicName.substr(offset);
                        spec.type = DestinationType.QUEUE;
                        spec.offset = offset;
                        return new Queue(spec);
                    } else if (networkTopicName.startsWith(TEMPORARY_QUEUE_PREFIX)) {
                        spec.name = networkTopicName;
                        spec.type = DestinationType.TEMPORARY_QUEUE;
                        spec.offset = 0;
                        return new Queue(spec);
                    }
                    return new Topic(spec);
                }
                function createDestinationFromBytes(networkTopicBytes) {
                    if (null === networkTopicBytes || 0 === networkTopicBytes.length) return null;
                    const networkTopicName = DestinationUtil.decodeBytes(networkTopicBytes);
                    return createDestinationFromName(networkTopicName, networkTopicBytes);
                }
                const DestinationFromNetwork = {
                    createDestinationFromBytes: createDestinationFromBytes,
                    createDestinationFromName: createDestinationFromName
                };
                module.exports.DestinationFromNetwork = DestinationFromNetwork;
            },
            "./modules/solclient-destination/lib/destination-type.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const DestinationType = {
                    TOPIC: "topic",
                    QUEUE: "queue",
                    TEMPORARY_QUEUE: "temporary_queue"
                };
                module.exports.DestinationType = Enum.new(DestinationType);
                module.exports.DestinationType._setCanonical({
                    TOPIC: DestinationType.TOPIC,
                    QUEUE: DestinationType.QUEUE,
                    TEMPORARY_QUEUE: DestinationType.TEMPORARY_QUEUE
                });
            },
            "./modules/solclient-destination/lib/destination-util.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const DestinationType = __webpack_require__("./modules/solclient-destination/lib/destination-type.js").DestinationType;
                const LOG_ERROR = __webpack_require__("./modules/solclient-log/api.js").LOG_ERROR;
                const SubscriptionInfo = __webpack_require__("./modules/solclient-destination/lib/subscription-info.js").SubscriptionInfo;
                const {
                    UUID,
                    StringUtils
                } = __webpack_require__("./modules/solclient-util/api.js");
                const {
                    ucs2ToUtf8,
                    utf8ToUcs2
                } = Convert;
                const ProfileBinding = SolclientFactoryLib.ProfileBinding;
                const {
                    toSafeChars,
                    stripNullTerminate
                } = StringUtils;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const DESTINATION_PREFIX_FROM_TYPE = {
                    [DestinationType.QUEUE]: "#P2P/QUE/",
                    [DestinationType.TEMPORARY_QUEUE]: "#P2P/QTMP/"
                };
                function createTemporaryName(type, vrid, name) {
                    const id = name || UUID.generateUUID();
                    switch (type) {
                      case DestinationType.TOPIC:
                        return `#P2P/TTMP/${vrid}/` + id;

                      case DestinationType.TEMPORARY_QUEUE:
                        return `#P2P/QTMP/${vrid}/` + id;

                      default:
                        LOG_ERROR("Unknown/invalid destination type", DestinationType.describe(type));
                    }
                    return;
                }
                function createPrefix(type) {
                    return DESTINATION_PREFIX_FROM_TYPE[type] || "";
                }
                function createOperationError(type, errorStr) {
                    return new OperationError(`Invalid ${type}: ` + errorStr, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                }
                function legacyValidate(type, bytes, name, exceptionCreator = createOperationError.bind(null, type)) {
                    let error;
                    const nameLength = name.length;
                    if (nameLength < 1) {
                        error = exceptionCreator("Too short (must be >= 1 character).");
                        return {
                            error: error
                        };
                    }
                    const bytesLength = bytes.length;
                    if (bytesLength > 251) {
                        error = exceptionCreator(`Too long (encoding must be <= 250 bytes); name is ${bytesLength - 1} bytes: '${name}'`);
                        return {
                            error: error
                        };
                    }
                    let isWildcarded = false;
                    if (">" === name.charAt(nameLength - 1)) isWildcarded = true;
                    for (let i = 0; i < nameLength; ++i) switch (name.charAt(i)) {
                      case "/":
                        if (0 === i || i === nameLength - 1 || "/" === name.charAt(i - 1)) {
                            error = exceptionCreator(`Empty level(s) in '${name}'@${i}.`);
                            return {
                                error: error
                            };
                        }
                        break;

                      case "*":
                        if (i < nameLength - 1 && "/" !== name.charAt(i + 1)) {
                            error = exceptionCreator(`Illegal wildcard(s) in '${name}'@${i}.`);
                            return {
                                error: error
                            };
                        }
                        isWildcarded = true;
                        break;

                      default:
                        break;
                    }
                    return {
                        isWildcarded: isWildcarded
                    };
                }
                function encodeBytes(bytes) {
                    return ProfileBinding.value.topicUtf8Encode ? ucs2ToUtf8(bytes) + ` ` : bytes + ` `;
                }
                function decodeBytes(bytes) {
                    return stripNullTerminate(ProfileBinding.value.topicUtf8Encode ? utf8ToUcs2(bytes) : bytes);
                }
                function encode(type, name) {
                    const prefix = createPrefix(type);
                    const offset = prefix.length;
                    const networkName = prefix + name;
                    const bytes = encodeBytes(networkName);
                    return {
                        bytes: bytes,
                        offset: offset,
                        networkName: networkName
                    };
                }
                function validateAndEncode(type, name, exceptionCreator = createOperationError.bind(null, type)) {
                    const {
                        bytes,
                        offset
                    } = encode(type, name);
                    const {
                        error: constError,
                        isWildcarded
                    } = legacyValidate(type, bytes, name, exceptionCreator);
                    let error = constError;
                    let subscriptionInfo = {};
                    subscriptionInfo.isWildcarded = isWildcarded;
                    if (!error) Object.keys(DESTINATION_PREFIX_FROM_TYPE).some(prefixType => {
                        const prefix = DESTINATION_PREFIX_FROM_TYPE[prefixType];
                        if (!name.startsWith(prefix)) return false;
                        error = exceptionCreator(`Reserved prefix '${prefix}' found at start of '${name}'`);
                        return true;
                    });
                    if (!error) {
                        const {
                            error: errorConst,
                            subInfo: subInfoConst
                        } = SubscriptionInfo.parseFromName(name, type);
                        error = errorConst;
                        subscriptionInfo = subInfoConst;
                    }
                    return {
                        bytes: bytes,
                        offset: offset,
                        error: error,
                        isWildcarded: isWildcarded,
                        subscriptionInfo: subscriptionInfo
                    };
                }
                const DestinationUtil = {
                    createPrefix: createPrefix,
                    createTemporaryName: createTemporaryName,
                    decodeBytes: decodeBytes,
                    encode: encode,
                    encodeBytes: encodeBytes,
                    legacyValidate: legacyValidate,
                    toSafeChars: toSafeChars,
                    validateAndEncode: validateAndEncode
                };
                module.exports.DestinationUtil = DestinationUtil;
            },
            "./modules/solclient-destination/lib/destination.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const DestinationType = __webpack_require__("./modules/solclient-destination/lib/destination-type.js").DestinationType;
                const DestinationUtil = __webpack_require__("./modules/solclient-destination/lib/destination-util.js").DestinationUtil;
                class Destination {
                    constructor(spec, type = DestinationType.TOPIC) {
                        if ("object" === typeof spec) {
                            this._name = spec.name;
                            this._type = spec.type;
                            this._bytes = spec.bytes;
                            this._offset = spec.offset;
                            if (spec.isValidated) {
                                this._isValidated = true;
                                this._isWildcarded = spec.isWildcarded;
                                this._subscriptionInfo = spec.subscriptionInfo || {};
                            } else {
                                this._isValidated = false;
                                this._subscriptionInfo = {};
                            }
                        } else {
                            this._name = spec;
                            this._type = type;
                            const result = DestinationUtil.encode(type, spec);
                            this._bytes = result.bytes;
                            this._offset = result.offset;
                            this._isValidated = false;
                            this._subscriptionInfo = {};
                        }
                    }
                    getName() {
                        return this._name;
                    }
                    get name() {
                        return this.getName();
                    }
                    getType() {
                        return this._type;
                    }
                    get type() {
                        return this.getType();
                    }
                    getBytes() {
                        return this._bytes;
                    }
                    get bytes() {
                        return this.getBytes();
                    }
                    getOffset() {
                        return this._offset;
                    }
                    get offset() {
                        return this.getOffset();
                    }
                    validate() {
                        if (this._isValidated) {
                            if (this._error) throw this._error;
                            return;
                        }
                        const {
                            error,
                            isWildcarded
                        } = DestinationUtil.legacyValidate(this.type, this.bytes, this.name);
                        this._isValidated = true;
                        if (error) {
                            this._error = error;
                            throw error;
                        }
                        this._isWildcarded = isWildcarded;
                    }
                    isWildcarded() {
                        this.validate();
                        return this._isWildcarded;
                    }
                    getSubscriptionInfo() {
                        return this._subscriptionInfo || {};
                    }
                    toString() {
                        return util_inspect(this);
                    }
                    equals(other) {
                        if (!(other instanceof Destination)) return false;
                        return this.toString().valueOf() === other.toString().valueOf();
                    }
                }
                module.exports.Destination = Destination;
            },
            "./modules/solclient-destination/lib/queue.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationUtilLib = __webpack_require__("./modules/solclient-destination/lib/destination-util.js");
                const assert = __webpack_require__("./modules/solclient-eskit/api.js").assert;
                const Destination = __webpack_require__("./modules/solclient-destination/lib/destination.js").Destination;
                const DestinationType = __webpack_require__("./modules/solclient-destination/lib/destination-type.js").DestinationType;
                class Queue extends Destination {
                    constructor(spec) {
                        assert(spec.name, "Queue name not supplied");
                        assert(spec.type === DestinationType.QUEUE || spec.type === DestinationType.TEMPORARY_QUEUE, "Queue spec.type is invalid");
                        assert(spec.bytes, "Queue spec missing bytes");
                        assert(void 0 !== spec.offset, "Queue spec missing offset");
                        super(spec);
                    }
                    getOffset() {
                        return this._offset;
                    }
                    get offset() {
                        return this.getOffset();
                    }
                    ["inspect"]() {
                        return `[Queue ${this.getName()}]`;
                    }
                    static createFromLocalName(queueName) {
                        const encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(DestinationType.QUEUE, queueName);
                        if (encoding.error) throw encoding.error;
                        return new Queue({
                            name: queueName,
                            type: DestinationType.QUEUE,
                            isValidated: true,
                            bytes: encoding.bytes,
                            offset: encoding.offset,
                            isWildcarded: encoding.isWildcarded,
                            subscriptionInfo: encoding.subscriptionInfo
                        });
                    }
                }
                module.exports.Queue = Queue;
            },
            "./modules/solclient-destination/lib/subscription-info.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const DestinationType = __webpack_require__("./modules/solclient-destination/lib/destination-type.js").DestinationType;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                function subscriptionParseNoExport(type, name, bytes, offset, result) {
                    const NOEXPORT_PREFIX = "#noexport/";
                    const NOEXPORT_PREFIX_LEN = NOEXPORT_PREFIX.length;
                    let index = offset;
                    let error;
                    if (name.length - index > NOEXPORT_PREFIX_LEN && !result.isNoExport) if (name.startsWith(NOEXPORT_PREFIX, index)) {
                        index += NOEXPORT_PREFIX_LEN;
                        result.isNoExport = true;
                    } else result.isNoExport = false; else result.isNoExport = false;
                    return {
                        error: error,
                        index: index,
                        result: result
                    };
                }
                function subscriptionParseShare(type, name, bytes, offset, result, exceptionCreator) {
                    const SHARE_PREFIX = "#share/";
                    const SHARE_PREFIX_LEN = SHARE_PREFIX.length;
                    const LEVEL_DELIMETER = "/";
                    const LEVEL_DELIMETER_LEN = LEVEL_DELIMETER.length;
                    let index = offset;
                    let error;
                    let groupIndex = -1;
                    let shareGroup;
                    if (name.length - index > SHARE_PREFIX_LEN && !result.isShare) if (name.startsWith(SHARE_PREFIX, offset) && name.length - (index + SHARE_PREFIX_LEN) > LEVEL_DELIMETER_LEN + 1) {
                        index += SHARE_PREFIX_LEN;
                        groupIndex = index;
                        index = name.indexOf(LEVEL_DELIMETER, groupIndex);
                        if (index > 0) {
                            shareGroup = name.substring(groupIndex, index);
                            index += LEVEL_DELIMETER_LEN;
                            result.isShare = true;
                            result.shareGroup = shareGroup;
                            result.dispatchTopicIndex = index;
                        } else {
                            error = exceptionCreator(`Illegal share Group in '${name}'@${groupIndex}.`);
                            result.isShare = true;
                        }
                    } else result.isShare = false; else result.isShare = false;
                    return {
                        error: error,
                        index: index,
                        result: result
                    };
                }
                function subscriptionStringParse(layers, type, name, bytes, subInfo, exceptionCreator) {
                    const parseLayers = layers.length || 0;
                    let offset = 0;
                    let error;
                    let result = subInfo || {};
                    for (let i = 0; i < parseLayers; ++i) {
                        const {
                            error: constError,
                            index: constOffset,
                            result: constResult
                        } = layers[i](type, name, bytes, offset, result, exceptionCreator);
                        offset = constOffset;
                        result = constResult;
                        error = constError;
                        if (error) break;
                    }
                    return {
                        error: error,
                        result: result
                    };
                }
                const SUBSCRIPTION_LAYER_PARSER_FROM_TYPE = {
                    [DestinationType.TOPIC]: {
                        _layers: [ subscriptionParseNoExport, subscriptionParseShare ],
                        parse: function(type, name, bytes, subInfo, exceptionCreator) {
                            const {
                                error,
                                result
                            } = subscriptionStringParse(this._layers, type, name, bytes, subInfo, exceptionCreator);
                            return {
                                error: error,
                                result: result
                            };
                        }
                    }
                };
                function createOperationError(type, errorStr) {
                    return new OperationError(`Invalid ${type}: ` + errorStr, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                }
                class SubscriptionInfo {
                    constructor(name) {
                        this._name = name;
                        this._isShare = false;
                        this._isNoExport = false;
                        this._dispatchTopicIndex = -1;
                        this._shareGroup = null;
                    }
                    getName() {
                        return this._name;
                    }
                    get name() {
                        return this.getName();
                    }
                    get isShare() {
                        return this._isShare;
                    }
                    set isShare(value) {
                        this._isShare = value;
                    }
                    get isNoExport() {
                        return this._isNoExport;
                    }
                    set isNoExport(value) {
                        this._isNoExport = value;
                    }
                    get dispatchTopicIndex() {
                        return this._dispatchTopicIndex < 0 ? 0 : this._dispatchTopicIndex;
                    }
                    set dispatchTopicIndex(value) {
                        this._dispatchTopicIndex = value < 0 ? -1 : value;
                    }
                    get shareGroup() {
                        return this.isShare ? this._shareGroup : null;
                    }
                    set shareGroup(value) {
                        if (this.isShare) this._shareGroup = value;
                    }
                    toString() {
                        return util_inspect(this);
                    }
                    static parseFromName(name, type = DestinationType.TOPIC) {
                        let subInfo = new SubscriptionInfo(name);
                        let error = null;
                        const parser = SUBSCRIPTION_LAYER_PARSER_FROM_TYPE[type];
                        if (parser) {
                            const {
                                error: errorConst,
                                result: subInfoConst
                            } = parser.parse(type, name, null, subInfo, createOperationError.bind(null, type));
                            subInfo = subInfoConst;
                            error = errorConst;
                        }
                        return {
                            error: error,
                            subInfo: subInfo
                        };
                    }
                }
                module.exports.SubscriptionInfo = SubscriptionInfo;
            },
            "./modules/solclient-destination/lib/topic.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationUtilLib = __webpack_require__("./modules/solclient-destination/lib/destination-util.js");
                const Destination = __webpack_require__("./modules/solclient-destination/lib/destination.js").Destination;
                const DestinationType = __webpack_require__("./modules/solclient-destination/lib/destination-type.js").DestinationType;
                class Topic extends Destination {
                    constructor(spec) {
                        if ("object" === typeof spec) super({
                            type: DestinationType.TOPIC,
                            name: spec.name,
                            bytes: spec.bytes,
                            offset: spec.offset,
                            isValidated: spec.isValidated,
                            isWildcarded: spec.isWildcarded,
                            subscriptionInfo: spec.subscriptionInfo
                        }); else super(spec, DestinationType.TOPIC);
                    }
                    ["inspect"]() {
                        return `[Topic ${this.getName()}]`;
                    }
                    static createFromName(topicName) {
                        const encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(DestinationType.TOPIC, topicName);
                        if (encoding.error) throw encoding.error;
                        return new Topic({
                            name: topicName,
                            isValidated: true,
                            bytes: encoding.bytes,
                            offset: encoding.offset,
                            isWildcarded: encoding.isWildcarded,
                            subscriptionInfo: encoding.subscriptionInfo
                        });
                    }
                }
                module.exports.Topic = Topic;
            },
            "./modules/solclient-env/api.js": module => {
                function apiEnv(envObject) {
                    if (true) throw new Error("Test environment will not override build environment");
                    global.BUILD_ENV = Object.assign({}, envObject, {
                        TEST: true
                    });
                    return global.BUILD_ENV;
                }
                if (true) apiEnv.target = () => apiEnv();
                module.exports = apiEnv;
            },
            "./modules/solclient-error/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ErrorResponseSubcodeMapper = __webpack_require__("./modules/solclient-error/lib/error-response-subcode-mapper.js").ErrorResponseSubcodeMapper;
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/lib/error-subcodes.js").ErrorSubcode;
                const NotImplementedError = __webpack_require__("./modules/solclient-error/lib/not-implemented-error.js").NotImplementedError;
                const OperationError = __webpack_require__("./modules/solclient-error/lib/operation-error.js").OperationError;
                const RequestError = __webpack_require__("./modules/solclient-error/lib/request-error.js").RequestError;
                const RequestEventCode = __webpack_require__("./modules/solclient-error/lib/request-event-codes.js").RequestEventCode;
                const SolaceError = __webpack_require__("./modules/solclient-error/lib/solace-error.js").SolaceError;
                module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;
                module.exports.ErrorSubcode = ErrorSubcode;
                module.exports.NotImplementedError = NotImplementedError;
                module.exports.OperationError = OperationError;
                module.exports.RequestError = RequestError;
                module.exports.RequestEventCode = RequestEventCode;
                module.exports.SolaceError = SolaceError;
            },
            "./modules/solclient-error/lib/error-response-subcode-mapper.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/lib/error-subcodes.js").ErrorSubcode;
                const makeMap = __webpack_require__("./modules/solclient-eskit/api.js").makeMap;
                const SC = ErrorSubcode;
                const ROOT_MAPPING = makeMap(400, makeMap("client name parse error", SC.CLIENT_NAME_INVALID, "document is too large", SC.MESSAGE_TOO_LARGE, "inactivity timeout", SC.INACTIVITY_TIMEOUT, "max num subscriptions exceeded", SC.SUBSCRIPTION_TOO_MANY, "message too long", SC.MESSAGE_TOO_LARGE, "nolocal discard", SC.NOLOCAL_DISCARD, "not enough space", SC.OUT_OF_RESOURCES, "subscription already exists", SC.SUBSCRIPTION_ALREADY_PRESENT, "subscription attributes conflict with existing subscription", SC.SUBSCRIPTION_ATTRIBUTES_CONFLICT, "subscription not found", SC.SUBSCRIPTION_NOT_FOUND, "subscription parse error", SC.SUBSCRIPTION_INVALID, "topic parse error", SC.INVALID_TOPIC_SYNTAX, "unknown transport session identifier", SC.UNKNOWN_TRANSPORT_SESSION_ID, "xml parse error", SC.XML_PARSE_ERROR, "unsupported ssl downgrade value", SC.LOGIN_FAILURE), 401, makeMap("", SC.LOGIN_FAILURE), 403, makeMap("basic authentication is shutdown", SC.BASIC_AUTHENTICATION_IS_SHUTDOWN, "client certificate authentication is shutdown", SC.CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN, "client name already in use", SC.CLIENT_NAME_ALREADY_IN_USE, "client username is shutdown", SC.CLIENT_USERNAME_IS_SHUTDOWN, "dynamic clients not allowed", SC.DYNAMIC_CLIENTS_NOT_ALLOWED, "invalid virtual router address", SC.INVALID_VIRTUAL_ADDRESS, "forbidden", SC.CLIENT_ACL_DENIED, "message vpn not allowed", SC.MESSAGE_VPN_NOT_ALLOWED, "publish acl denied", SC.PUBLISH_ACL_DENIED, "replication is standby", SC.REPLICATION_IS_STANDBY, "selector does not match", SC.SELECTOR_DOES_NOT_MATCH, "subscription acl denied", SC.SUBSCRIPTION_ACL_DENIED, "subscription does not match", SC.SUBSCRIPTION_DOES_NOT_MATCH, "compression is shutdown", SC.LOGIN_FAILURE, "shared subscriptions not supported on topic endpoints", SC.SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED, "shared subscriptions not supported on queues", SC.SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED, "shared subscription permission denied", SC.SHARED_SUBSCRIPTIONS_NOT_ALLOWED), 404, makeMap("", SC.LOGIN_FAILURE), 503, makeMap("low priority msg congestion", SC.LOW_PRIORITY_MSG_CONGESTION, "message vpn unavailable", SC.MESSAGE_VPN_UNAVAILABLE, "replication is standby", SC.REPLICATION_IS_STANDBY, "service unavailable", SC.GM_UNAVAILABLE, "spool over quota", SC.SPOOL_OVER_QUOTA, "subscriber delete in progress", SC.CLIENT_DELETE_IN_PROGRESS, "too many clients", SC.TOO_MANY_CLIENTS, "too many connections for vpn", SC.TOO_MANY_CLIENTS, "max message usage exceeded", SC.MAX_MESSAGE_USAGE_EXCEEDED), 507, makeMap("ad not ready", SC.GM_NOT_READY));
                const AD_MAPPING = makeMap("PARENT", ROOT_MAPPING, 400, makeMap("already bound", SC.ALREADY_BOUND, "endpoint already exists", SC.ENDPOINT_ALREADY_EXISTS, "subscription already exists", SC.SUBSCRIPTION_ALREADY_PRESENT, "already exists", SC.ENDPOINT_ALREADY_EXISTS, "endpoint property mismatch", SC.ENDPOINT_PROPERTY_MISMATCH, "invalid durable topic endpoint name", SC.INVALID_DTE_NAME, "invalid selector", SC.INVALID_SELECTOR, "invalid topic name", SC.INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT, "invalid queue or topic endpoint durability", SC.INVALID_QUEUE_OR_TOPIC_ENDPOINT_DURABILITY, "queue not found", SC.QUEUE_NOT_FOUND, "quota out of range", SC.QUOTA_OUT_OF_RANGE, "unknown flow name", SC.UNKNOWN_FLOW_NAME, "unsubscribe not allowed", SC.UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND, "invalid queue name", SC.INVALID_QUEUE_NAME, "invalid topic endpoint name", SC.INVALID_TE_NAME, "message size out of range", SC.MESSAGE_SIZE_OUT_OF_RANGE, "unsupported permissions", SC.UNSUPPORTED_PERMISSIONS), 403, makeMap("permission not allowed", SC.PERMISSION_NOT_ALLOWED, "client initiated replay not allowed on non-exclusive topic endpoint", SC.CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED, "client initiated replay not allowed on non-exclusive queue", SC.CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED, "client initiated replay from inactive flow not allowed", SC.CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED, "client initiated replay from browser flow not allowed", SC.CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED, "replay not supported on temporary queue", SC.REPLAY_TEMPORARY_NOT_SUPPORTED, "replay not supported on anonymous queue", SC.REPLAY_ANONYMOUS_QUEUE_NOT_SUPPORTED, "replay not supported on anonymous queue without subscriptions", SC.REPLAY_ANONYMOUS_QUEUE_WITHOUT_SUBSCRIPTIONS_NOT_SUPPORTED, "unknown start location type", SC.UNKNOWN_START_LOCATION_TYPE, "mismatched endpoint error id", SC.MISMATCHED_ENDPOINT_ERROR_ID, "replay start message unavailable", SC.REPLAY_START_MESSAGE_NOT_AVAILABLE, "browsing not supported on partitioned queue", SC.PARTITIONED_QUEUE_BROWSING_NOT_SUPPORTED, "selectors not supported on partitioned queue", SC.PARTITIONED_QUEUE_SELECTORS_NOT_SUPPORTED), 503, makeMap("durable topic endpoint shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "endpoint shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "max clients exceeded for durable topic endpoint", SC.MAX_CLIENTS_FOR_TE, "max clients exceeded for topic endpoint", SC.MAX_CLIENTS_FOR_TE, "max clients exceeded for queue", SC.MAX_CLIENTS_FOR_QUEUE, "no more non-durable queue or topic endpoint", SC.NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT, "no subscription match", SC.NO_SUBSCRIPTION_MATCH, "queue shutdown", SC.QUEUE_SHUTDOWN, "te shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "unknown durable topic endpoint", SC.UNKNOWN_TOPIC_ENDPOINT_NAME, "unknown queue", SC.UNKNOWN_QUEUE_NAME, "replay disabled", SC.REPLAY_DISABLED, "replay cancelled", SC.REPLAY_CANCELLED, "replay message unavailable", SC.REPLAY_MESSAGE_UNAVAILABLE, "replay started", SC.REPLAY_STARTED, "replayed message rejected by topic endpoint", SC.REPLAY_MESSAGE_REJECTED, 'replayed message rejected by queue"', SC.REPLAY_MESSAGE_REJECTED, "replay log modified", SC.REPLAY_LOG_MODIFIED, "mismatched endpoint error id", SC.MISMATCHED_ENDPOINT_ERROR_ID, "out of replay resources", SC.OUT_OF_REPLAY_RESOURCES, "topic or selector modified on durable topic endpoint", SC.TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT, "replay failed", SC.REPLAY_FAILED, "replay start time not available", SC.REPLAY_START_TIME_NOT_AVAILABLE, "replay start message unavailable", SC.REPLAY_START_MESSAGE_NOT_AVAILABLE, "sync replication ineligible", SC.SYNC_REPLICATION_INELIGIBLE, "max endpoints exceeded", SC.MAX_ENDPOINTS_EXCEEDED, "copy-from queue template missing", SC.COPY_FROM_QUEUE_TEMPLATE_MISSING, "copy-from topic-endpoint template missing", SC.COPY_FROM_TE_TEMPLATE_MISSING), 507, makeMap("assured delivery not ready", SC.ASSURED_DELIVERY_NOT_READY));
                function getSubcodeMappingInner(root, respErrorCode, respStr) {
                    if (200 === respErrorCode) return 0;
                    const codeMap = root[respErrorCode] || {};
                    const searchKey = (respStr || "").toLowerCase();
                    const foundKey = Object.keys(codeMap).find(mapKey => mapKey === searchKey || searchKey.indexOf(mapKey) >= 0);
                    if (foundKey) return codeMap[foundKey];
                    if (codeMap[""]) return codeMap[""];
                    if (root["PARENT"]) return getSubcodeMappingInner(root["PARENT"], respErrorCode, respStr);
                    return;
                }
                function getSubcodeMapping(root, respErrorCode, respStr) {
                    const result = getSubcodeMappingInner(root, respErrorCode, respStr);
                    if (void 0 === result) return SC.UNKNOWN_ERROR;
                    return result;
                }
                const ErrorResponseSubcodeMapper = {
                    getErrorSubcode(respErrorCode, respStr) {
                        return getSubcodeMapping(ROOT_MAPPING, respErrorCode, respStr);
                    },
                    getADErrorSubcode(respErrorCode, respStr) {
                        return getSubcodeMapping(AD_MAPPING, respErrorCode, respStr);
                    }
                };
                module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;
            },
            "./modules/solclient-error/lib/error-subcodes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const ErrorSubcode = {
                    UNKNOWN_ERROR: 4294967295,
                    NO_ERROR: 0,
                    SESSION_NOT_CONNECTED: 2,
                    INVALID_SESSION_OPERATION: 3,
                    INVALID_OPERATION: 3,
                    TIMEOUT: 4,
                    MESSAGE_VPN_NOT_ALLOWED: 5,
                    MESSAGE_VPN_UNAVAILABLE: 6,
                    CLIENT_USERNAME_IS_SHUTDOWN: 7,
                    DYNAMIC_CLIENTS_NOT_ALLOWED: 8,
                    CLIENT_NAME_ALREADY_IN_USE: 9,
                    CLIENT_NAME_INVALID: 10,
                    CLIENT_DELETE_IN_PROGRESS: 11,
                    TOO_MANY_CLIENTS: 12,
                    LOGIN_FAILURE: 13,
                    INVALID_VIRTUAL_ADDRESS: 14,
                    CLIENT_ACL_DENIED: 15,
                    SUBSCRIPTION_ACL_DENIED: 16,
                    PUBLISH_ACL_DENIED: 17,
                    PARAMETER_OUT_OF_RANGE: 18,
                    PARAMETER_CONFLICT: 19,
                    PARAMETER_INVALID_TYPE: 20,
                    INTERNAL_ERROR: 21,
                    INSUFFICIENT_SPACE: 22,
                    OUT_OF_RESOURCES: 23,
                    PROTOCOL_ERROR: 24,
                    COMMUNICATION_ERROR: 25,
                    KEEP_ALIVE_FAILURE: 26,
                    TOPIC_MISSING: 28,
                    INVALID_TOPIC_SYNTAX: 31,
                    MESSAGE_TOO_LARGE: 32,
                    XML_PARSE_ERROR: 33,
                    SUBSCRIPTION_ALREADY_PRESENT: 34,
                    SUBSCRIPTION_NOT_FOUND: 35,
                    SUBSCRIPTION_INVALID: 36,
                    SUBSCRIPTION_ERROR_OTHER: 37,
                    SUBSCRIPTION_TOO_MANY: 38,
                    SUBSCRIPTION_ATTRIBUTES_CONFLICT: 39,
                    NO_LOCAL_NOT_SUPPORTED: 40,
                    DATA_ERROR_OTHER: 42,
                    CREATE_XHR_FAILED: 43,
                    CONNECTION_ERROR: 44,
                    DATA_DECODE_ERROR: 45,
                    INACTIVITY_TIMEOUT: 46,
                    UNKNOWN_TRANSPORT_SESSION_ID: 47,
                    AD_MESSAGING_NOT_SUPPORTED: 48,
                    CREATE_WEBSOCKET_FAILED: 49,
                    REPLICATION_IS_STANDBY: 50,
                    BASIC_AUTHENTICATION_IS_SHUTDOWN: 51,
                    CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN: 52,
                    GM_UNAVAILABLE: 100,
                    UNKNOWN_FLOW_NAME: 111,
                    ALREADY_BOUND: 112,
                    INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT: 113,
                    UNKNOWN_QUEUE_NAME: 114,
                    UNKNOWN_TOPIC_ENDPOINT_NAME: 115,
                    MAX_CLIENTS_FOR_QUEUE: 116,
                    MAX_CLIENTS_FOR_TE: 117,
                    UNEXPECTED_UNBIND: 118,
                    QUEUE_NOT_FOUND: 119,
                    SPOOL_OVER_QUOTA: 120,
                    QUEUE_SHUTDOWN: 121,
                    TOPIC_ENDPOINT_SHUTDOWN: 122,
                    NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT: 123,
                    ENDPOINT_ALREADY_EXISTS: 124,
                    PERMISSION_NOT_ALLOWED: 125,
                    INVALID_SELECTOR: 126,
                    MAX_MESSAGE_USAGE_EXCEEDED: 127,
                    ENDPOINT_PROPERTY_MISMATCH: 128,
                    NO_SUBSCRIPTION_MATCH: 129,
                    MESSAGE_DELIVERY_MODE_MISMATCH: 130,
                    MESSAGE_ALREADY_ACKNOWLEDGED: 131,
                    SUBSCRIPTION_DOES_NOT_MATCH: 133,
                    SELECTOR_DOES_NOT_MATCH: 134,
                    INVALID_DTE_NAME: 135,
                    UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND: 136,
                    CALLBACK_ERROR: 137,
                    NOLOCAL_DISCARD: 138,
                    GM_NOT_READY: 140,
                    LOW_PRIORITY_MSG_CONGESTION: 141,
                    QUOTA_OUT_OF_RANGE: 142,
                    FAILED_LOADING_TRUSTSTORE: 143,
                    FAILED_LOADING_CERTIFICATE_AND_KEY: 144,
                    UNRESOLVED_HOSTS: 145,
                    REPLAY_NOT_SUPPORTED: 146,
                    REPLAY_DISABLED: 147,
                    CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED: 148,
                    CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED: 149,
                    CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED: 150,
                    REPLAY_TEMPORARY_NOT_SUPPORTED: 151,
                    UNKNOWN_START_LOCATION_TYPE: 152,
                    REPLAY_CANCELLED: 153,
                    REPLAY_MESSAGE_UNAVAILABLE: 154,
                    REPLAY_START_TIME_NOT_AVAILABLE: 155,
                    REPLAY_MESSAGE_REJECTED: 156,
                    REPLAY_LOG_MODIFIED: 157,
                    MISMATCHED_ENDPOINT_ERROR_ID: 158,
                    OUT_OF_REPLAY_RESOURCES: 159,
                    TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT: 160,
                    REPLAY_FAILED: 161,
                    REPLAY_STARTED: 162,
                    COMPRESSED_TLS_NOT_SUPPORTED: 163,
                    SHARED_SUBSCRIPTIONS_NOT_SUPPORTED: 164,
                    SHARED_SUBSCRIPTIONS_NOT_ALLOWED: 165,
                    SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED: 166,
                    REPLAY_START_MESSAGE_NOT_AVAILABLE: 167,
                    MESSAGE_ID_NOT_COMPARABLE: 168,
                    REPLAY_ANONYMOUS_QUEUE_NOT_SUPPORTED: 169,
                    PARTITIONED_QUEUE_BROWSING_NOT_SUPPORTED: 170,
                    PARTITIONED_QUEUE_SELECTORS_NOT_SUPPORTED: 171,
                    REPLAY_ANONYMOUS_QUEUE_WITHOUT_SUBSCRIPTIONS_NOT_SUPPORTED: 172,
                    SYNC_REPLICATION_INELIGIBLE: 173,
                    INVALID_QUEUE_OR_TOPIC_ENDPOINT_DURABILITY: 174,
                    INVALID_QUEUE_NAME: 175,
                    INVALID_TE_NAME: 176,
                    MESSAGE_SIZE_OUT_OF_RANGE: 177,
                    UNSUPPORTED_PERMISSIONS: 178,
                    MAX_ENDPOINTS_EXCEEDED: 179,
                    ASSURED_DELIVERY_NOT_READY: 180,
                    COPY_FROM_QUEUE_TEMPLATE_MISSING: 181,
                    COPY_FROM_TE_TEMPLATE_MISSING: 182
                };
                module.exports.ErrorSubcode = Enum.new(ErrorSubcode);
            },
            "./modules/solclient-error/lib/not-implemented-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SolaceError = __webpack_require__("./modules/solclient-error/lib/solace-error.js").SolaceError;
                class NotImplementedError extends SolaceError {
                    constructor(message) {
                        super("NotImplementedError", message || "", NotImplementedError);
                    }
                }
                module.exports.NotImplementedError = NotImplementedError;
            },
            "./modules/solclient-error/lib/operation-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SolaceError = __webpack_require__("./modules/solclient-error/lib/solace-error.js").SolaceError;
                class OperationError extends SolaceError {
                    constructor(message, subcode, reason) {
                        super("OperationError", message, OperationError);
                        this.subcode = subcode;
                        this.reason = reason;
                    }
                }
                module.exports.OperationError = OperationError;
            },
            "./modules/solclient-error/lib/request-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/lib/error-subcodes.js").ErrorSubcode;
                const OperationError = __webpack_require__("./modules/solclient-error/lib/operation-error.js").OperationError;
                const RequestEventCode = __webpack_require__("./modules/solclient-error/lib/request-event-codes.js").RequestEventCode;
                const SUBCODE_FROM_EC = {
                    [RequestEventCode.REQUEST_ABORTED]: ErrorSubcode.SESSION_NOT_CONNECTED,
                    [RequestEventCode.REQUEST_TIMEOUT]: ErrorSubcode.TIMEOUT
                };
                class RequestError extends OperationError {
                    constructor(message, eventCode, correlationKey, reason) {
                        super(message, SUBCODE_FROM_EC[eventCode], reason);
                        this.name = "RequestError";
                        this._eventCode = eventCode;
                        this._correlationKey = correlationKey;
                    }
                    get requestEventCode() {
                        return this._requestEventCode;
                    }
                    get errorSubcode() {
                        return super.subcode;
                    }
                    ["inspect"]() {
                        const superObj = super["inspect"] ? super["inspect"]() : {};
                        return Object.assign(superObj, {
                            requestEventCode: RequestEventCode.describe(this.requestEventCode),
                            infoStr: this.infoStr,
                            correlationKey: this.correlationKey
                        });
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.RequestError = RequestError;
            },
            "./modules/solclient-error/lib/request-event-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const RequestEventCode = {
                    REQUEST_ABORTED: 8,
                    REQUEST_TIMEOUT: 9
                };
                module.exports.RequestEventCode = Enum.new(RequestEventCode);
            },
            "./modules/solclient-error/lib/solace-error.js": module => {
                class SolaceError extends Error {
                    constructor(type, message, constructor) {
                        super(message || "");
                        this.message = message;
                        this.name = type;
                        if (Error.captureStackTrace) Error.captureStackTrace(this, constructor); else this.stack = new Error().stack;
                    }
                }
                module.exports.SolaceError = SolaceError;
            },
            "./modules/solclient-eskit/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ArrayOperations = __webpack_require__("./modules/solclient-eskit/lib/array-operations.js").ArrayOperations;
                const assert = __webpack_require__("./modules/solclient-eskit/lib/assert.js").assert;
                const BidiMap = __webpack_require__("./modules/solclient-eskit/lib/bidi-map.js").BidiMap;
                const Enum = __webpack_require__("./modules/solclient-eskit/lib/enum.js").Enum;
                const Iterator = __webpack_require__("./modules/solclient-eskit/lib/iterator.js").Iterator;
                const Lazy = __webpack_require__("./modules/solclient-eskit/lib/lazy.js").Lazy;
                const makeMap = __webpack_require__("./modules/solclient-eskit/lib/make-map.js").makeMap;
                const Mixin = __webpack_require__("./modules/solclient-eskit/lib/mixin.js").Mixin;
                const Resolver = __webpack_require__("./modules/solclient-eskit/lib/resolver.js").Resolver;
                const SetOperations = __webpack_require__("./modules/solclient-eskit/lib/set-operations.js").SetOperations;
                module.exports.assert = assert;
                module.exports.ArrayOperations = ArrayOperations;
                module.exports.BidiMap = BidiMap;
                module.exports.Enum = Enum;
                module.exports.Iterator = Iterator;
                module.exports.Lazy = Lazy;
                module.exports.makeIterator = Iterator.makeIterator;
                module.exports.makeMap = makeMap;
                module.exports.Mixin = Mixin;
                module.exports.mixin = Mixin.mixin;
                module.exports.Resolver = Resolver;
                module.exports.resolve = Resolver.resolve;
                module.exports.SetOperations = SetOperations;
            },
            "./modules/solclient-eskit/lib/array-operations.js": module => {
                function defaultComparator(a, b) {
                    const astr = String(a);
                    const bstr = String(b);
                    return astr > bstr ? 1 : astr < bstr ? -1 : 0;
                }
                function insertOrdered(array, element, comparator = defaultComparator) {
                    const result = [ ...array ];
                    return this.inplaceInsertOrdered(result, element, comparator);
                }
                function inplaceInsertOrdered(array, element, comparator = defaultComparator) {
                    let index = 0;
                    let min = 0;
                    let max = array.length;
                    if (max > 0) if (comparator(element, array[max - 1]) > 0) index = max; else {
                        index = min + max >> 1;
                        while (max > min) {
                            if (comparator(element, array[index]) < 0) max = index; else min = index + 1;
                            index = min + max >> 1;
                        }
                    }
                    array.splice(index, 0, element);
                }
                module.exports = {
                    ArrayOperations: {
                        defaultComparator: defaultComparator,
                        insertOrdered: insertOrdered,
                        inplaceInsertOrdered: inplaceInsertOrdered
                    }
                };
            },
            "./modules/solclient-eskit/lib/assert.js": module => {
                let assert;
                if (false); else assert = () => {};
                module.exports.assert = assert;
            },
            "./modules/solclient-eskit/lib/bidi-map.js": module => {
                class BidiMap {
                    constructor(...pairs) {
                        this.forward = new Map();
                        this.reverse = new Map();
                        pairs.forEach(p => {
                            this.setValues(p[0], p[1]);
                        });
                    }
                    setValues(key, value) {
                        this.forward.set(key, value);
                        this.reverse.set(value, key);
                    }
                }
                module.exports.BidiMap = BidiMap;
            },
            "./modules/solclient-eskit/lib/enum.js": module => {
                function enumName(instance, keys, value) {
                    const matches = keys.filter(k => instance[k] === value);
                    return matches.length ? matches[0] : null;
                }
                function enumValues(instance, keys) {
                    return Array.from(new Set(keys.map(k => instance[k])));
                }
                class Enum {
                    constructor(values) {
                        Object.defineProperties(this, {
                            _canonical: {
                                value: null,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        this._setCanonical(values);
                    }
                    _setCanonical(values, final = false) {
                        this._canonical = Object.assign({}, values);
                        Object.keys(this).forEach(key => {
                            const descriptor = Object.getOwnPropertyDescriptor(this, key);
                            if (void 0 !== descriptor.value) Object.defineProperty(this, key, {
                                enumerable: false,
                                writable: true,
                                configurable: true,
                                value: descriptor.value
                            });
                        });
                        Object.keys(values).forEach(key => {
                            Object.defineProperty(this, key, {
                                enumerable: true,
                                writable: !final,
                                configurable: !final,
                                value: values[key]
                            });
                        });
                    }
                    describe(enumValue, noneValue = "<none>", unknownValue = "<unknown>") {
                        if (null === enumValue || void 0 === enumValue) return noneValue;
                        const name = enumName(this._canonical, Object.keys(this._canonical || {}), enumValue) || unknownValue;
                        return name === enumValue ? name : name + ` (${enumValue})`;
                    }
                    nameOf(enumValue) {
                        return enumName(this._canonical, Object.keys(this._canonical || {}), enumValue);
                    }
                    get names() {
                        return Object.keys(this._canonical || {});
                    }
                    get values() {
                        return enumValues(this._canonical, Object.keys(this._canonical || {}));
                    }
                    get isEnum() {
                        return true;
                    }
                    static nameOf(instance, value) {
                        return instance.nameOf(value);
                    }
                    static values(instance) {
                        return instance.values();
                    }
                    static new(values) {
                        return new Enum(values);
                    }
                    static ofStrings(strings) {
                        const map = {};
                        strings.forEach(s => {
                            map[s] = s;
                        });
                        return Enum.new(map);
                    }
                    static ofNumbers(keys) {
                        const map = {};
                        keys.forEach((key, index) => {
                            map[key] = index;
                        });
                        return Enum.new(map);
                    }
                }
                module.exports.Enum = Enum;
            },
            "./modules/solclient-eskit/lib/iterator.js": module => {
                class Iterator {
                    constructor(arr, start = 0, end = arr.length) {
                        this._arr = arr;
                        this._index = start;
                        this._end = end;
                    }
                    deref() {
                        return this._arr[this._index];
                    }
                    incr() {
                        return ++this._index;
                    }
                    end() {
                        return this._index >= this._end;
                    }
                    static makeIterator(arr, start = 0, end = arr.length) {
                        return new Iterator(arr, start, end);
                    }
                }
                module.exports.Iterator = Iterator;
            },
            "./modules/solclient-eskit/lib/lazy.js": module => {
                const DEFAULT_PROPERTY_OPTIONS = {
                    enumerable: true
                };
                function setPropertyValue(target, key, value, options = null) {
                    Object.defineProperty(target, key, Object.assign({
                        value: value
                    }, DEFAULT_PROPERTY_OPTIONS, options));
                }
                function lazyProperty(target, key, evalFn) {
                    Object.defineProperty(target, key, Object.assign({
                        configurable: true,
                        get: () => {
                            const result = evalFn(target, key);
                            setPropertyValue(target, key, result);
                            return result;
                        },
                        set: value => {
                            setPropertyValue(target, key, value);
                        }
                    }, DEFAULT_PROPERTY_OPTIONS));
                    return target;
                }
                function lazyProperties(target, obj) {
                    Object.keys(obj).forEach(k => {
                        lazyProperty(target, k, obj[k]);
                    });
                    return obj;
                }
                function lazyValue(evalFn) {
                    return lazyProperty({}, "value", evalFn);
                }
                const Lazy = {
                    lazyProperties: lazyProperties,
                    lazyProperty: lazyProperty,
                    lazyValue: lazyValue
                };
                module.exports.Lazy = Lazy;
            },
            "./modules/solclient-eskit/lib/make-map.js": module => {
                module.exports.makeMap = function(...keyValuePairs) {
                    const result = {};
                    for (let i = 0; i < keyValuePairs.length; i += 2) result[keyValuePairs[i]] = keyValuePairs[i + 1];
                    return result;
                };
            },
            "./modules/solclient-eskit/lib/mixin.js": module => {
                const Mixin = {};
                Mixin.mixin = function(target, add) {
                    const targetProto = target.prototype;
                    const addProto = add.prototype;
                    Object.getOwnPropertyNames(addProto).forEach(name => {
                        if ("constructor" === name) return;
                        Object.defineProperty(targetProto, name, Object.getOwnPropertyDescriptor(addProto, name));
                    });
                    return target;
                };
                module.exports.Mixin = Mixin;
            },
            "./modules/solclient-eskit/lib/resolver.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Lazy = __webpack_require__("./modules/solclient-eskit/lib/lazy.js").Lazy;
                const lazyProperty = Lazy.lazyProperty;
                function traversePath(commonSource, keySource, pathArr) {
                    return pathArr.reduce((source, value) => {
                        if ("string" === typeof value) return source[value];
                        return value;
                    }, keySource);
                }
                class Resolver {
                    constructor(options, source) {
                        Object.keys(options).forEach(compoundKey => {
                            compoundKey.split(",").map(k => k.trim()).forEach(key => {
                                const rawPath = options[compoundKey];
                                const path = "string" === typeof rawPath ? rawPath.split(".") : rawPath;
                                const pathArr = (Array.isArray(path) ? path : [ path ]).concat(key);
                                lazyProperty(this, key, () => traversePath(source, this, pathArr));
                            });
                        });
                    }
                    static resolve(options, source) {
                        return new Resolver(options, source);
                    }
                }
                module.exports.Resolver = Resolver;
            },
            "./modules/solclient-eskit/lib/set-operations.js": module => {
                function isSuperset(set, subset) {
                    return Array.from(subset).every(elem => set.has(elem));
                }
                function inplaceUnion(setA, setB) {
                    setB.forEach(elem => {
                        setA.add(elem);
                    });
                    return setA;
                }
                function union(setA, setB) {
                    return inplaceUnion(new Set(setA), setB);
                }
                function inplaceIntersection(setA, setB) {
                    setA.forEach(elem => {
                        if (!setB.has(elem)) setA.delete(elem);
                    });
                    return setA;
                }
                function intersection(setA, setB) {
                    return new Set(Array.from(setA).filter(elem => setB.has(elem)));
                }
                function inplaceDifference(setA, setB) {
                    setB.forEach(elem => {
                        setA.delete(elem);
                    });
                    return setA;
                }
                function difference(setA, setB) {
                    return new Set(Array.from(setA).filter(elem => !setB.has(elem)));
                }
                module.exports = {
                    SetOperations: {
                        inplaceDifference: inplaceDifference,
                        inplaceIntersection: inplaceIntersection,
                        inplaceUnion: inplaceUnion,
                        isSuperset: isSuperset,
                        difference: difference,
                        intersection: intersection,
                        union: union
                    }
                };
            },
            "./modules/solclient-events/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const EventEmitter = __webpack_require__("./modules/solclient-events/lib/event-emitter.js").EventEmitter;
                const Timer = __webpack_require__("./modules/solclient-events/lib/timer.js").Timer;
                module.exports = {
                    EventEmitter: EventEmitter,
                    Timer: Timer
                };
            },
            "./modules/solclient-events/lib/event-emitter.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const NodeEventEmitter = __webpack_require__("./node_modules/events/events.js").EventEmitter;
                const ArrayUtils = __webpack_require__("./modules/solclient-util/api.js").ArrayUtils;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const LOG_WARN = __webpack_require__("./modules/solclient-log/api.js").LOG_WARN;
                const {
                    flatten,
                    includes
                } = ArrayUtils;
                const NODE_DEFAULT_EVENTS = [ "error", "newListener", "removeListener" ];
                const BLACKLIST_DIRECT = [ "newListener", "removeListener" ];
                function buildFilter(emits) {
                    if ("function" === typeof emits) return k => includes(NODE_DEFAULT_EVENTS, k) || emits(k);
                    if (!Array.isArray(emits)) return null;
                    const emitSet = new Set(flatten(emits));
                    NODE_DEFAULT_EVENTS.forEach(el => emitSet.add(el));
                    const emitArray = Array.from(emitSet);
                    return k => includes(emitArray, k);
                }
                const DISABLED_ACTIONS = {
                    ignore() {},
                    fail() {
                        throw new Error("Emitter disabled");
                    }
                };
                class EventEmitter extends NodeEventEmitter {
                    constructor(options) {
                        super();
                        const {
                            direct,
                            emits,
                            unsafe,
                            formatEventName
                        } = options || {};
                        this.formatEventName = formatEventName || (name => name);
                        const bareEmit = this.emit.bind(this);
                        this._installDirectFilter(direct, bareEmit);
                        this._installErrorHandlers(unsafe);
                        this._installEmitVerifier();
                        this._listenerVerificationFilter = buildFilter(emits);
                        this._emits = emits;
                    }
                    _installDirectFilter(direct, bareEmit) {
                        if (!direct) return;
                        if (includes(BLACKLIST_DIRECT, direct)) throw new OperationError(`Cannot configure listener collection events [${BLACKLIST_DIRECT.join(", ")}] as direct`, ErrorSubcode.INTERNAL_ERROR);
                        this._defaultEmitDirect = (...args) => bareEmit(direct, ...args);
                        this.emitDirect = this._defaultEmitDirect;
                        this._directEventName = direct;
                        this.on = (eventName, listener) => {
                            this._verifyListenerEvent(eventName);
                            const ret = super.on(eventName, listener);
                            this._setEmitDirect(eventName, true, listener);
                            return ret;
                        };
                        this.addListener = (eventName, listener) => this.on(eventName, listener);
                        this.once = (eventName, listener) => {
                            this._verifyListenerEvent(eventName);
                            const ret = super.once(eventName, listener);
                            this._setEmitDirect(eventName, false);
                            return ret;
                        };
                        this.prependListener = (eventName, listener) => {
                            this._verifyListenerEvent(eventName);
                            const ret = super.prependListener(eventName, listener);
                            this._setEmitDirect(eventName, true, listener);
                            return ret;
                        };
                        this.prependOnceListener = (eventName, listener) => {
                            this._verifyListenerEvent(eventName);
                            const ret = super.prependOnceListener(eventName, listener);
                            this._setEmitDirect(eventName, false);
                            return ret;
                        };
                        this.removeAllListeners = eventName => {
                            const ret = super.removeAllListeners(eventName);
                            if (eventName === this._directEventName || void 0 === eventName) this.emitDirect = this._defaultEmitDirect;
                            return ret;
                        };
                        this.removeListener = (eventName, listener) => {
                            const ret = super.removeListener(eventName, listener);
                            if (eventName === this._directEventName && 0 === this.listenerCount(eventName)) this.emitDirect = this._defaultEmitDirect;
                            return ret;
                        };
                        this.directListenerCount = () => this.listenerCount(this._directEventName);
                        this.setOnFirstDirectListener = firstDirect => {
                            this._onFirstDirectListener = firstDirect;
                        };
                    }
                    _setEmitDirect(eventName, onListener, listener) {
                        if (eventName !== this._directEventName) return;
                        if (onListener && 1 === this.directListenerCount()) this.emitDirect = listener; else this.emitDirect = this._defaultEmitDirect;
                        if (1 === this.directListenerCount() && void 0 !== this._onFirstDirectListener) this._onFirstDirectListener();
                    }
                    _verifyListenerEvent(event) {
                        if (!this._listenerVerificationFilter) return;
                        if (void 0 === event || null === event) this.throwInternal(new OperationError(`Emitter rejects listener for no-name event: ` + event, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                        if (!this._listenerVerificationFilter(event)) this.throwInternal(new OperationError(`Emitter rejects listeners for ${event}, emits ` + this._emits, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                    }
                    _installEmitVerifier() {
                        if (false);
                    }
                    _installErrorHandlers(unsafe) {
                        if (unsafe) {
                            this.throwInternal = err => {
                                throw err;
                            };
                            return;
                        }
                        const emitBase = this.emit.bind(this);
                        this.throwInternal = function(err) {
                            this._internalError = true;
                            throw err;
                        };
                        this.emit = (name, ...args) => {
                            try {
                                emitBase(name, ...args);
                            } catch (ex) {
                                if (this._internalError) {
                                    this._internalError = void 0;
                                    throw ex;
                                }
                                const err = this.formatErrorEvent(ex, name, ...args);
                                try {
                                    LOG_WARN(`Listener for '${err.info.event.formattedName}' threw exception, dispatching to 'error'`);
                                    emitBase("error", err);
                                } catch (innerEx) {
                                    LOG_WARN("Listener for 'error' threw exception:", innerEx, "\nOriginal exception:", ex);
                                }
                            }
                        };
                    }
                    get isDirect() {
                        return this.emitDirect && this.emitDirect !== this._defaultEmitDirect;
                    }
                    formatErrorEvent(ex, name, ...args) {
                        const formattedName = this.formatEventName(name);
                        return Object.assign(new OperationError(`Unhandled error in event handler for '${formattedName}'`, ErrorSubcode.CALLBACK_ERROR, `On event: ${[ name, ...args ]} ` + ex), {
                            stack: ex.stack,
                            info: {
                                event: {
                                    name: name,
                                    formattedName: formattedName,
                                    args: args
                                },
                                error: ex
                            }
                        });
                    }
                    disableEmitter() {
                        this._defaultEmitDirect = DISABLED_ACTIONS.ignore;
                        this.removeAllListeners();
                        this.emit = DISABLED_ACTIONS.ignore;
                        this.addListener("removeListener", DISABLED_ACTIONS.fail);
                        this.addListener("newListener", DISABLED_ACTIONS.fail);
                    }
                }
                module.exports.EventEmitter = EventEmitter;
            },
            "./modules/solclient-events/lib/timer.js": module => {
                class Timer {
                    constructor(cancel) {
                        this.cancel = () => {
                            this.cancel = () => {};
                            cancel();
                        };
                    }
                    static newInterval(interval, onInterval, ...args) {
                        const timerRef = setInterval(onInterval, interval, ...args);
                        return new Timer(() => clearInterval(timerRef));
                    }
                    static newTimeout(timeout, onExpire, ...args) {
                        const timerRef = setTimeout(onExpire, timeout, ...args);
                        return new Timer(() => clearTimeout(timerRef));
                    }
                }
                module.exports.Timer = Timer;
            },
            "./modules/solclient-factory/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    FactoryProfile,
                    SolclientFactoryProfiles
                } = __webpack_require__("./modules/solclient-factory/lib/solclient-factory-profiles.js");
                const ProfileBinding = __webpack_require__("./modules/solclient-factory/lib/profile-binding.js").ProfileBinding;
                const SolclientFactory = __webpack_require__("./modules/solclient-factory/lib/solclient-factory.js").SolclientFactory;
                const SolclientFactoryProperties = __webpack_require__("./modules/solclient-factory/lib/solclient-factory-properties.js").SolclientFactoryProperties;
                module.exports.FactoryProfile = FactoryProfile;
                module.exports.ProfileBinding = ProfileBinding;
                module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;
                module.exports.SolclientFactoryProperties = SolclientFactoryProperties;
                module.exports.SolclientFactory = SolclientFactory;
            },
            "./modules/solclient-factory/lib/profile-binding.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const OperationError = __webpack_require__("./modules/solclient-error/api.js").OperationError;
                let binding = null;
                const ProfileBinding = {
                    get value() {
                        if (null === binding) throw new OperationError("Profile binding not initialized. Call solace.SolclientFactory.init");
                        return binding;
                    },
                    set value(value) {
                        binding = value;
                    }
                };
                module.exports.ProfileBinding = ProfileBinding;
            },
            "./modules/solclient-factory/lib/solclient-factory-profiles.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                class FactoryProfile {
                    get guaranteedMessagingEnabled() {
                        return;
                    }
                    get cometEnabled() {
                        return;
                    }
                    get topicUtf8Encode() {
                        return;
                    }
                    get byteArrayAsString() {
                        return;
                    }
                    ["inspect"]() {
                        return {
                            guaranteedMessagingEnabled: this.guaranteedMessagingEnabled,
                            cometEnabled: this.cometEnabled,
                            topicUtf8Encode: this.topicUtf8Encode,
                            byteArrayAsString: this.byteArrayAsString
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                class Version7Profile extends FactoryProfile {
                    get guaranteedMessagingEnabled() {
                        return !!false;
                    }
                    get cometEnabled() {
                        return !!true;
                    }
                    get topicUtf8Encode() {
                        return false;
                    }
                    get byteArrayAsString() {
                        return true;
                    }
                }
                const legacyInstance = new Version7Profile();
                class Version10Profile extends FactoryProfile {
                    get guaranteedMessagingEnabled() {
                        return true;
                    }
                    get cometEnabled() {
                        return false;
                    }
                    get topicUtf8Encode() {
                        return true;
                    }
                    get byteArrayAsString() {
                        return true;
                    }
                }
                const v10Instance = new Version10Profile();
                class Version105Profile extends FactoryProfile {
                    get guaranteedMessagingEnabled() {
                        return true;
                    }
                    get cometEnabled() {
                        return false;
                    }
                    get topicUtf8Encode() {
                        return true;
                    }
                    get byteArrayAsString() {
                        return false;
                    }
                }
                const forwardInstance = new Version105Profile();
                const SolclientFactoryProfiles = {
                    _legacy: legacyInstance,
                    _v10: v10Instance,
                    _forward: forwardInstance,
                    _default: legacyInstance,
                    version7: legacyInstance,
                    version10: v10Instance,
                    version10_5: forwardInstance,
                    ["inspect"]() {
                        return {
                            version7: this.version7,
                            version10: this.version10,
                            version10_5: this.version10_5
                        };
                    },
                    toString() {
                        return util_inspect(this);
                    }
                };
                module.exports.FactoryProfile = FactoryProfile;
                module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;
            },
            "./modules/solclient-factory/lib/solclient-factory-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const APIProperties = __webpack_require__("./modules/solclient-util/api.js").APIProperties;
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                function getDefaultLogLevel() {
                    const LogLevel = __webpack_require__("./modules/solclient-log/api.js").LogLevel;
                    return LogLevel.INFO;
                }
                class SolclientFactoryProperties extends APIProperties {
                    constructor(options) {
                        super({
                            logLevel: getDefaultLogLevel(),
                            logger: null
                        }, options);
                    }
                    get profile() {
                        return this._profile;
                    }
                    set profile(profile) {
                        this._profile = profile;
                    }
                    get logLevel() {
                        return Check.number(this._logLevel) ? this._logLevel : getDefaultLogLevel();
                    }
                    set logLevel(val) {
                        this._logLevel = val;
                    }
                    get logger() {
                        return this._logger || null;
                    }
                    set logger(val) {
                        this._logger = val;
                    }
                    ["inspect"]() {
                        const LogLevel = __webpack_require__("./modules/solclient-log/api.js").LogLevel;
                        return {
                            logLevel: LogLevel.describe(this._logLevel),
                            profile: this._profile
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.SolclientFactoryProperties = SolclientFactoryProperties;
            },
            "./modules/solclient-factory/lib/solclient-factory.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const {
                    FactoryProfile,
                    SolclientFactoryProfiles
                } = __webpack_require__("./modules/solclient-factory/lib/solclient-factory-profiles.js");
                const Parameter = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                const ProfileBinding = __webpack_require__("./modules/solclient-factory/lib/profile-binding.js").ProfileBinding;
                const SolclientFactoryProperties = __webpack_require__("./modules/solclient-factory/lib/solclient-factory-properties.js").SolclientFactoryProperties;
                const factoryState = {
                    initializeCount: 0,
                    initializers: []
                };
                const SolclientFactory = {
                    addInitializer(func) {
                        factoryState.initializers.push(func);
                    },
                    createFactory(func) {
                        return function(...args) {
                            if (0 === factoryState.initializeCount) throw new OperationError("SolclientFactory not initialized", ErrorSubcode.INVALID_OPERATION);
                            return func(...args);
                        };
                    },
                    init(factoryProps) {
                        if (factoryState.initializeCount > 0) return this;
                        const props = new SolclientFactoryProperties(factoryProps);
                        const profile = factoryProps && factoryProps.profile || SolclientFactoryProfiles.version7;
                        Parameter.isInstanceOf("factoryProps.profile", profile, FactoryProfile);
                        ProfileBinding.value = profile;
                        factoryState.initializers.forEach(initializer => {
                            initializer.call(this, props, factoryState);
                        });
                        ++factoryState.initializeCount;
                        if (void 0 !== factoryProps && null !== factoryProps) {
                            const {} = __webpack_require__("./modules/solclient-log/api.js");
                        }
                        return this;
                    },
                    reset() {
                        factoryState.initializeCount = 0;
                    },
                    _getInitializeCount() {
                        return factoryState.initializeCount;
                    },
                    get profiles() {
                        return SolclientFactoryProfiles;
                    }
                };
                module.exports.SolclientFactory = SolclientFactory;
            },
            "./modules/solclient-flow/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Flow = __webpack_require__("./modules/solclient-flow/lib/flow.js").Flow;
                const FlowOperation = __webpack_require__("./modules/solclient-flow/lib/flow-operation.js").FlowOperation;
                const PrivateFlowEventName = __webpack_require__("./modules/solclient-flow/lib/private-flow-event-names.js").PrivateFlowEventName;
                module.exports.Flow = Flow;
                module.exports.FlowOperation = FlowOperation;
                module.exports.PrivateFlowEventName = PrivateFlowEventName;
            },
            "./modules/solclient-flow/lib/flow-operation.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const FlowOperation = {
                    CONNECT: "FlowOperation_CONNECT",
                    DISCONNECT: "FlowOperation_DISCONNECT",
                    START: "FlowOperation_START",
                    STOP: "FlowOperation_STOP",
                    DISPOSE: "FlowOperation_DESTROY",
                    GET_STATS: "FlowOperation_GET_STATS",
                    RESET_STATS: "FlowOperation_RESET_STATS",
                    GET_PROPERTIES: "FlowOperation_GET_PROPERTIES",
                    GET_DESTINATION: "FlowOperation_GET_DESTINATION"
                };
                module.exports.FlowOperation = Enum.new(FlowOperation);
            },
            "./modules/solclient-flow/lib/flow.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    NotImplementedError,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const EventEmitter = __webpack_require__("./modules/solclient-events/api.js").EventEmitter;
                const FlowOperation = __webpack_require__("./modules/solclient-flow/lib/flow-operation.js").FlowOperation;
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const PrivateFlowEventName = __webpack_require__("./modules/solclient-flow/lib/private-flow-event-names.js").PrivateFlowEventName;
                const Stats = __webpack_require__("./modules/solclient-stats/api.js").Stats;
                const ALWAYS_OPS = [ FlowOperation.DISPOSE, FlowOperation.GET_STATS, FlowOperation.GET_PROPERTIES, FlowOperation.RESET_STATS ];
                class Flow extends EventEmitter {
                    constructor(flowProperties, sessionInterfaceFactory, emitterOptions) {
                        const emitterOptionsFull = Object.assign({}, emitterOptions);
                        emitterOptionsFull.emits = (emitterOptionsFull.emits || []).concat(PrivateFlowEventName.values);
                        super(emitterOptionsFull);
                        const sessionInterface = sessionInterfaceFactory(this);
                        const self = this;
                        this.logger = new LogFormatter((...args) => [ `[session=${sessionInterface.sessionIdHex}]`, `[flow=${self.flowIdDec}]`, ...args ]);
                        this.log = this.logger.wrap(this.log, this);
                        this._disposing = false;
                        this._disposed = false;
                        this._userDisconnected = true;
                        this._properties = flowProperties;
                        this._sessionInterface = sessionInterface;
                        this._stats = new Stats(sessionInterface);
                        this._privateEventEmitter = new EventEmitter(emitterOptionsFull);
                    }
                    _emit(type, ...args) {
                        this._privateEventEmitter.emit(type, ...args);
                        this.emit(type, ...args);
                    }
                    _on(type, listener) {
                        this._privateEventEmitter.on(type, listener);
                    }
                    _once(type, listener) {
                        this._privateEventEmitter.once(type, listener);
                    }
                    _removeListener(type, listener) {
                        this._privateEventEmitter.removeListener(type, listener);
                    }
                    clearStats() {
                        const {} = this.logger;
                        this._operationCheck(FlowOperation.RESET_STATS);
                        this._stats.resetStats();
                    }
                    connect() {
                        const {} = this.logger;
                        this.userDisconnected = false;
                        this._operationCheck(FlowOperation.CONNECT);
                    }
                    dispose() {
                        const {} = this.logger;
                        if (this._disposed || this._disposing) return;
                        this._operationCheck(FlowOperation.DISPOSE);
                        this._disposing = true;
                        const terminate = () => {
                            this._disposed = true;
                            this._properties = null;
                            this._userDisconnected = true;
                            this._emit(this.getDisposedEvent());
                            this.disableEmitter();
                            this._privateEventEmitter.disableEmitter();
                        };
                        if (this._fsm._midDispatch) {
                            const terminateWithRunningFSM = () => {
                                this._fsm.terminateFsm();
                                terminate();
                            };
                            setTimeout(() => terminateWithRunningFSM(), 0);
                        } else terminate();
                    }
                    disconnect() {
                        this._operationCheck(FlowOperation.DISCONNECT);
                        const {} = this.logger;
                        this.userDisconnected = true;
                    }
                    _disconnectSession() {
                        this._operationCheck(FlowOperation.DISCONNECT);
                    }
                    getDisposedEvent() {
                        throw new NotImplementedError("Abstract method");
                    }
                    getProperties() {
                        this._operationCheck(FlowOperation.GET_PROPERTIES);
                        return this._properties.clone();
                    }
                    getStat(statType) {
                        this._operationCheck(FlowOperation.GET_STATS);
                        return this._stats.getStat(statType);
                    }
                    handleUncorrelatedControlMessage(message) {
                        throw new NotImplementedError("Guaranteed Message Connection does not implement a control message handler", message);
                    }
                    incStat(statType, value) {
                        this._stats.incStat(statType, value);
                    }
                    processFSMEvent(event) {
                        this._fsm.processEvent(event);
                    }
                    ["inspect"]() {
                        return {
                            flowId: this.flowIdDec
                        };
                    }
                    toString() {
                        return this["inspect"]();
                    }
                    get canAck() {
                        return !this.disposed;
                    }
                    get disposed() {
                        return this._disposed;
                    }
                    get flowIdDec() {
                        return this.flowId || "(N/A)";
                    }
                    get flowId() {
                        return new NotImplementedError("Flow does not implement ID accessor");
                    }
                    get session() {
                        return this._session;
                    }
                    get userDisconnected() {
                        return this._userDisconnected;
                    }
                    set userDisconnected(value) {
                        this._userDisconnected = value;
                    }
                    _operationCheck(operation) {
                        const {} = this.logger;
                        FlowOperation.describe(operation);
                        if (this._disposed) throw new OperationError("Operation is invalid for Message Consumer in disposed state", ErrorSubcode.INVALID_OPERATION);
                        if (ALWAYS_OPS.some(v => v === operation)) return true;
                        if (operation === FlowOperation.DISCONNECT && this._isDisconnected()) throw new OperationError("Operation is invalid for Message Consumer in disconnected state", ErrorSubcode.INVALID_OPERATION);
                        return;
                    }
                    _isDisconnected() {
                        throw new NotImplementedError("Flow#_isDisconnected not implemented");
                    }
                }
                module.exports.Flow = Flow;
            },
            "./modules/solclient-flow/lib/private-flow-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const PrivateFlowEventName = {
                    BIND_WAITING: "PrivateFlowEventName_bindWaiting"
                };
                module.exports.PrivateFlowEventName = Enum.new(PrivateFlowEventName);
            },
            "./modules/solclient-fsm/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const FsmEvent = __webpack_require__("./modules/solclient-fsm/lib/event.js").FsmEvent;
                const State = __webpack_require__("./modules/solclient-fsm/lib/state.js").State;
                const StateMachine = __webpack_require__("./modules/solclient-fsm/lib/state-machine.js").StateMachine;
                module.exports.FsmEvent = FsmEvent;
                module.exports.State = State;
                module.exports.StateMachine = StateMachine;
            },
            "./modules/solclient-fsm/lib/entry-point.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const StateLib = __webpack_require__("./modules/solclient-fsm/lib/state.js");
                const FsmObject = __webpack_require__("./modules/solclient-fsm/lib/object.js").FsmObject;
                class EntryPoint extends FsmObject {
                    constructor(spec) {
                        super({
                            name: spec.entryPointName
                        });
                        let innerState;
                        this.impl = this.impl || {};
                        this.impl.outerState = new StateLib.State({
                            name: spec.state.getName() + ` outerEntryPoint: ` + spec.entryPointName,
                            parentContext: spec.state.getParent()
                        }).initial(() => spec.state.transitionTo(innerState));
                        innerState = new StateLib.State({
                            name: spec.state.getName() + ` innerEntryPoint: ` + spec.entryPointName,
                            parentContext: spec.state
                        }).initial(spec.func);
                    }
                    getDestState() {
                        return this.impl.outerState;
                    }
                }
                module.exports.EntryPoint = EntryPoint;
            },
            "./modules/solclient-fsm/lib/event.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const FsmObject = __webpack_require__("./modules/solclient-fsm/lib/object.js").FsmObject;
                class FsmEvent extends FsmObject {}
                module.exports.FsmEvent = FsmEvent;
            },
            "./modules/solclient-fsm/lib/exit-point.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const StateLib = __webpack_require__("./modules/solclient-fsm/lib/state.js");
                const FsmObject = __webpack_require__("./modules/solclient-fsm/lib/object.js").FsmObject;
                class ExitPoint extends FsmObject {
                    constructor(spec) {
                        super({
                            name: spec.exitPointName
                        });
                        let outerState;
                        this.impl.innerState = new StateLib.State({
                            name: spec.state.getName() + ` innerExitPoint: ` + spec.exitPointName,
                            parentContext: spec.state
                        }).initial(() => spec.state.transitionTo(outerState));
                        outerState = new StateLib.State({
                            name: spec.state.getName() + ` outerExitPoint: ` + spec.exitPointName,
                            parentContext: spec.state.getParent()
                        }).initial(spec.func);
                    }
                    getDestState() {
                        return this.impl.innerState;
                    }
                }
                module.exports.ExitPoint = ExitPoint;
            },
            "./modules/solclient-fsm/lib/object.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const OperationError = __webpack_require__("./modules/solclient-error/api.js").OperationError;
                class FsmObject {
                    constructor(spec) {
                        if (!spec) throw new OperationError("No spec provided");
                        if (!spec.name) throw new OperationError("No name provided for spec");
                        this.impl = {
                            name: spec.name
                        };
                    }
                    toString() {
                        let extraStringInfo = this.getExtraStringInfo();
                        if (extraStringInfo.length > 0) extraStringInfo = `; ` + extraStringInfo;
                        return `{${this.constructor.name}: ${this.getName()}${extraStringInfo}}`;
                    }
                    getExtraStringInfo() {
                        return "";
                    }
                    getName() {
                        return this.impl.name;
                    }
                }
                module.exports.FsmObject = FsmObject;
            },
            "./modules/solclient-fsm/lib/state-context.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const StateLib = __webpack_require__("./modules/solclient-fsm/lib/state.js");
                const FsmObject = __webpack_require__("./modules/solclient-fsm/lib/object.js").FsmObject;
                const Iterator = __webpack_require__("./modules/solclient-eskit/api.js").Iterator;
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const makeIterator = Iterator.makeIterator;
                class StateContext extends FsmObject {
                    constructor(spec) {
                        super(spec);
                        this.impl = this.impl || {};
                        this.impl.logPadding = "";
                    }
                    getStateMachine() {
                        return this.impl.ancestorList[0];
                    }
                    initial(func) {
                        if (this.impl.initialReaction) this.log(`Replacing ${this} initialReaction ${this.impl.initialReaction} with ` + func);
                        this.impl.initialReaction = func.bind(this);
                        return this;
                    }
                    transitionTo(state, action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: state,
                            action: action
                        });
                    }
                    terminate(action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: this.getStateMachine().getFinalState(),
                            action: action
                        });
                    }
                    getAncestorList() {
                        return this.impl.ancestorList;
                    }
                    log(...args) {
                        this.impl.logPadding, [ ...args ];
                    }
                    onInitial(event) {
                        let result;
                        if (this.impl.initialReaction) {
                            this.log(`Initial: for ` + this);
                            result = this.impl.initialReaction(event);
                            if (result.external) throw new Error(`Initial reaction for ${this} returned external transitions`);
                            return result;
                        }
                        if (!(this instanceof StateLib.State)) throw new Error(`Missing initial reaction for ` + this);
                        return this.transitionTo(this);
                    }
                    processReactionResult(result, e) {
                        let curContext = this;
                        if (!result.destState) return this;
                        const destStateIter = this.lowestCommonAncestor(result);
                        while (curContext !== destStateIter.deref()) {
                            curContext.onExit();
                            curContext = curContext.getParent();
                        }
                        if (result.action) result.action(curContext, e);
                        curContext.log(`Action: transition to ${result.destState} in context ` + curContext);
                        for (destStateIter.incr(); !destStateIter.end(); destStateIter.incr()) {
                            curContext = destStateIter.deref();
                            curContext.onEntry();
                        }
                        const destInitial = curContext.onInitial(e);
                        if (destInitial.destState !== curContext) return curContext.processReactionResult(destInitial, e);
                        return curContext;
                    }
                    lowestCommonAncestor(reactionResult) {
                        const ancestorList = this.impl.ancestorList;
                        const destAncestorList = reactionResult.destState.getAncestorList();
                        let i;
                        if (ancestorList[0] !== destAncestorList[0]) throw new Error(`No common ancestor between (${this} in ${ancestorList[0]}) and (${reactionResult.destState} in ${destAncestorList[0]})`);
                        if (this === reactionResult.destState) {
                            i = ancestorList.length;
                            if (reactionResult.external) --i;
                        } else {
                            for (i = 1; i < ancestorList.length; ++i) if (ancestorList[i] !== destAncestorList[i]) break;
                            if (i === ancestorList.length || i === destAncestorList.length) if (reactionResult.external) --i;
                        }
                        return makeIterator(destAncestorList, i - 1);
                    }
                    setLogPadding(padding) {
                        this.impl.logPadding = padding;
                    }
                }
                StateContext.ReactionResult = class {
                    constructor(spec) {
                        if (!spec || !spec.caller || !(spec.caller instanceof StateContext)) throw new Error("spec.caller is required to be a StateContext");
                        if (!spec.caller.getStateMachine().isRunning()) throw new Error("ReactionResult objects can only be created while processing events");
                        if (spec.destState) {
                            if (!(spec.destState instanceof StateLib.State)) throw new Error("destState must be a State object");
                            if (spec.action && "function" !== typeof spec.action) throw new Error("action must be a function");
                            this.destState = spec.destState;
                            this.action = spec.action;
                            this.external = spec.external;
                        }
                    }
                };
                module.exports.StateContext = StateContext;
            },
            "./modules/solclient-fsm/lib/state-machine.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const LOG_ERROR = __webpack_require__("./modules/solclient-log/api.js").LOG_ERROR;
                const State = __webpack_require__("./modules/solclient-fsm/lib/state.js").State;
                const StateContext = __webpack_require__("./modules/solclient-fsm/lib/state-context.js").StateContext;
                class StateMachine extends StateContext {
                    constructor(spec) {
                        if (spec.parentContext) throw new Error(`State machine cannot have parent state: ` + spec.parentContext);
                        super(spec);
                        this.impl.ancestorList = [ this ];
                        this.impl.eventQueue = [];
                        this.impl.finalState = new State({
                            name: "impl.final",
                            parentContext: this
                        });
                        this.impl.handleUncaughtException = (ev, exc) => {
                            LOG_ERROR(`Uncaught exception in ${this} while processing ${ev}: ` + exc.stack);
                            return this.terminate();
                        };
                    }
                    process(func) {
                        const impl = this.impl;
                        const eventQueue = impl.eventQueue;
                        eventQueue.push(func);
                        if (impl.processingEvents) return false;
                        impl.processingEvents = true;
                        while (eventQueue.length) {
                            const evt = eventQueue.shift();
                            evt.apply(this);
                        }
                        impl.processingEvents = false;
                        this._onEventCompletion();
                        return true;
                    }
                    start() {
                        if (this.getCurrentState()) throw new Error(`Cannot start ${this.getName()}; it is already started.`);
                        this.process(() => {
                            const result = this.onInitial();
                            if (void 0 === result.destState) throw new Error(`Missing destination state from initial transition for ` + this);
                            if (result.destState === this) throw new Error(`Destination state for initial transition for ${this} cannot be the FSM.`);
                            const destAncestorList = result.destState.getAncestorList();
                            if (destAncestorList[0] !== this) throw new Error(`Invalid destination state (${result.destState}) from initial transition for state machine (${this}); destState ancestor (${destAncestorList[0]})`);
                            this.impl.currentState = this.processReactionResult(result);
                        });
                    }
                    isRunning() {
                        return this.impl.processingEvents;
                    }
                    processEvent(evt) {
                        const impl = this.impl;
                        if (!this.process(() => {
                            this.log(`Processing event ` + evt);
                            let result;
                            if (impl.currentState) try {
                                result = impl.currentState.handleEvent(evt);
                                impl.currentState = impl.currentState.processReactionResult(result, evt);
                            } catch (exc) {
                                this.log(`Caught exception ${exc}, continuing`);
                                result = impl.handleUncaughtException.call(impl.currentState, evt, exc);
                                impl.currentState = impl.currentState.processReactionResult(result, evt);
                            }
                        })) this.log(`Deferring event ` + evt);
                    }
                    terminateFsm() {
                        const curState = this.getCurrentState();
                        if (!curState) return;
                        if (this.impl.processingEvents) throw new Error("Cannot terminate state machine while FSM is processing " + "events. To terminate the FSM from within a reaction, return " + "State~terminate() from a reaction.");
                        this.process(() => {
                            const result = curState.terminate();
                            this.impl.currentState = curState.processReactionResult(result);
                        });
                    }
                    setPostEventAction(postEventAction) {
                        if (!this.impl.processingEvents) throw new Error("Cannot set post event hook unless FSM is processing events.");
                        if (!postEventAction || "function" !== typeof postEventAction) throw new Error(`postEventAction must be a function; got (${postEventAction})`);
                        this.impl.postEventAction = postEventAction.bind(this);
                    }
                    _onEventCompletion() {
                        const action = this.impl.postEventAction;
                        if (action) {
                            this.impl.postEventAction = void 0;
                            this.log("Running post event action");
                            action.apply(this);
                        }
                    }
                    getCurrentState() {
                        return this.impl.currentState;
                    }
                    getActiveState(name) {
                        const activeStates = this.impl.currentState.getAncestorList();
                        for (let i = 1; i < activeStates.length; ++i) if (activeStates[i].getName() === name) return activeStates[i];
                        return;
                    }
                    isStateActive(name) {
                        return void 0 !== this.getActiveState(name);
                    }
                    unhandledEventReaction(r) {
                        if ("function" !== typeof r) throw new Error(`In ${this}: unhandled event reaction must be a function; got ` + r);
                        this.impl.handleUnhandledEvent = r.bind(this);
                        return this;
                    }
                    uncaughtExceptionReaction(r) {
                        if ("function" !== typeof r) throw new Error(`In ${this}: Uncaught exception reaction must be a function; got ` + r);
                        this.impl.handleUncaughtException = r;
                        return this;
                    }
                    getFinalState() {
                        return this.impl.finalState;
                    }
                }
                module.exports.StateMachine = StateMachine;
            },
            "./modules/solclient-fsm/lib/state.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const EntryPoint = __webpack_require__("./modules/solclient-fsm/lib/entry-point.js").EntryPoint;
                const ExitPoint = __webpack_require__("./modules/solclient-fsm/lib/exit-point.js").ExitPoint;
                const StateContext = __webpack_require__("./modules/solclient-fsm/lib/state-context.js").StateContext;
                class State extends StateContext {
                    constructor(spec, extensions = null) {
                        super(spec);
                        const parentContext = spec.parentContext;
                        Object.assign(this.impl, {
                            parentContext: parentContext,
                            reactions: {},
                            entryPoints: {},
                            exitPoints: {},
                            ancestorList: [ ...parentContext.getAncestorList(), this ],
                            handleUnhandledEvent: e => parentContext.handleEvent ? parentContext.handleEvent(e) : parentContext.impl.handleUnhandledEvent(e)
                        });
                        if (parentContext) this.log = parentContext.log.bind(this);
                        Object.keys(extensions || {}).forEach(k => {
                            const extension = extensions[k];
                            this[k] = "function" === typeof extension ? extension.bind(this) : extension;
                        });
                        this.setLogPadding(" ".repeat(this.impl.ancestorList.length));
                    }
                    reaction(eventName, func) {
                        if (!eventName) throw new Error("No event name for reaction");
                        if (!func) throw new Error(`No reaction function for reaction ` + eventName);
                        this.log(`Adding reaction to ${this} for event ` + eventName);
                        if (this.impl.reactions[eventName]) this.log(`Replacing reaction ${this.impl.reactions[eventName]} with ` + func);
                        this.impl.reactions[eventName] = func.bind(this);
                        return this;
                    }
                    entryPoint(entryPointName, func) {
                        if (!entryPointName) throw new Error("No entry point name for entry point");
                        if (!func) throw new Error(`No reaction function for entry point ` + entryPointName);
                        this.log(`Adding entryPoint ${entryPointName} to ` + this);
                        if (this.impl.entryPoints[entryPointName]) {
                            this.log(`EntryPoint ${entryPointName} already exists in ` + this);
                            return this;
                        }
                        this.impl.entryPoints[entryPointName] = new EntryPoint({
                            state: this,
                            entryPointName: entryPointName,
                            func: func
                        });
                        return this;
                    }
                    exitPoint(exitPointName, func) {
                        if (!exitPointName) throw new Error("No exit point name for entry point");
                        if (!func) throw new Error(`No reaction function for exit point ` + exitPointName);
                        this.log(`Adding exitPoint ${exitPointName} to ` + this);
                        if (this.impl.exitPoints[exitPointName]) {
                            this.log(`ExitPoint ${exitPointName} already exists in  ` + this);
                            return this;
                        }
                        this.impl.exitPoints[exitPointName] = new ExitPoint({
                            state: this,
                            exitPointName: exitPointName,
                            func: func
                        });
                        return this;
                    }
                    getEntryPointDestState(entryPointName) {
                        if (void 0 === this.impl.entryPoints[entryPointName]) {
                            this.log(this + `: EntryPoint ${entryPointName} does not exist.`);
                            return this;
                        }
                        return this.impl.entryPoints[entryPointName].getDestState();
                    }
                    getExitPointDestState(exitPointName) {
                        if (void 0 === this.impl.exitPoints[exitPointName]) {
                            this.log(this + `: ExitPoint ${exitPointName} does not exist.`);
                            return this;
                        }
                        return this.impl.exitPoints[exitPointName].getDestState();
                    }
                    entry(func) {
                        if (this.impl.appEntryFunc) this.log(`Replacing entry function ${this.impl.appEntryFunc} with ` + func);
                        this.impl.appEntryFunc = func.bind(this);
                        return this;
                    }
                    exit(func) {
                        if (this.impl.appExitFunc) this.log(`Replacing exit function ${this.impl.appExitFunc} with ` + func);
                        this.impl.appExitFunc = func.bind(this);
                        return this;
                    }
                    externalTransitionTo(state, action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: state,
                            action: action,
                            external: true
                        });
                    }
                    transitionToEntryPoint(state, entryPointName, action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: state.getEntryPointDestState(entryPointName),
                            action: action
                        });
                    }
                    transitionToExitPoint(state, exitPointName, action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: state.getExitPointDestState(exitPointName),
                            action: action
                        });
                    }
                    eventUnhandled() {
                        return new StateContext.ReactionResult({
                            caller: this
                        });
                    }
                    internalTransition(action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: this.getStateMachine().getCurrentState(),
                            action: action
                        });
                    }
                    terminate(action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: this.getStateMachine().getFinalState(),
                            action: action
                        });
                    }
                    getParent() {
                        return this.impl.parentContext;
                    }
                    onEntry() {
                        this.log(`Entering: ` + this);
                        if (this.impl.appEntryFunc) this.impl.appEntryFunc();
                    }
                    onExit() {
                        this.log(`Exiting: ` + this);
                        if (this.impl.appExitFunc) this.impl.appExitFunc();
                    }
                    handleEvent(e) {
                        this.log(`Process: ` + e);
                        const reaction = this.impl.reactions[e.getName()];
                        if (reaction) {
                            const result = reaction(e);
                            if (!result) this.log(`Reaction returned undefined: ${e} in ` + this);
                            if (result.destState) {
                                this.log(`Handled: ` + e);
                                return result;
                            }
                            this.log(`Unhandled: ${e} in ` + this);
                        } else this.log(`No reaction: ${e} in ` + this);
                        return this.impl.handleUnhandledEvent(e);
                    }
                }
                module.exports.State = State;
            },
            "./modules/solclient-log/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ConsoleLogImpl = __webpack_require__("./modules/solclient-log/lib/console-log-impl.js").ConsoleLogImpl;
                const GlobalBinding = __webpack_require__("./modules/solclient-log/lib/global-binding.js").GlobalBinding;
                const LogImpl = __webpack_require__("./modules/solclient-log/lib/log-impl.js").LogImpl;
                const LogLevel = __webpack_require__("./modules/solclient-log/lib/log-levels.js").LogLevel;
                const Parameter = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                const SolclientFactory = __webpack_require__("./modules/solclient-factory/api.js").SolclientFactory;
                const {
                    isEnumMember,
                    isFunction
                } = Parameter;
                const {
                    getImpl,
                    getLogLevel,
                    setImpl,
                    setLogLevel
                } = GlobalBinding;
                const forwarder = {};
                function buildLogForwarder() {
                    Object.assign(forwarder, {
                        trace(...args) {
                            const impl = getImpl();
                            if (impl && impl.trace && getLogLevel() >= LogLevel.TRACE) impl.trace.apply(null, [ "solclientjs: ", ...args ]);
                        },
                        debug(...args) {
                            const impl = getImpl();
                            if (impl && impl.debug && getLogLevel() >= LogLevel.DEBUG) impl.debug.apply(null, [ "solclientjs: ", ...args ]);
                        },
                        info(...args) {
                            const impl = getImpl();
                            if (impl && impl.info && getLogLevel() >= LogLevel.INFO) impl.info.apply(null, [ "solclientjs: ", ...args ]);
                        },
                        warn(...args) {
                            const impl = getImpl();
                            if (impl && impl.warn && getLogLevel() >= LogLevel.WARN) impl.warn.apply(null, [ "solclientjs: ", ...args ]);
                        },
                        error(...args) {
                            const impl = getImpl();
                            if (impl && impl.error && getLogLevel() >= LogLevel.ERROR) impl.error.apply(null, [ "solclientjs: ", ...args ]);
                        },
                        fatal(...args) {
                            const impl = getImpl();
                            if (impl && impl.fatal) impl.fatal.apply(null, [ "solclientjs: ", ...args ]);
                        }
                    });
                }
                buildLogForwarder();
                function addGlobalFuncs(source, target) {
                    Object.keys(forwarder).forEach(k => {
                        target[`LOG_` + k.toUpperCase()] = source[k];
                    });
                }
                class LogFormatter {
                    constructor(formatter) {
                        this._formatter = (() => {
                            if ("function" === typeof formatter) return formatter;
                            if ("string" === typeof formatter) return function(...args) {
                                return [ formatter, ...args ];
                            };
                            if (!formatter) return function(...args) {
                                return [ ...args ];
                            };
                            return formatter;
                        })();
                        const self = this;
                        Object.keys(forwarder).forEach(key => {
                            this[key] = function(...args) {
                                return forwarder[key].apply(null, self._formatter(...args));
                            };
                        });
                        addGlobalFuncs(this, this);
                    }
                    get formatter() {
                        return this._formatter;
                    }
                    set formatter(func) {
                        this._formatter = func;
                    }
                    wrap(genericFunction, targetSelf) {
                        const self = this;
                        return function(...args) {
                            return genericFunction.apply(targetSelf, self._formatter(...args));
                        };
                    }
                }
                SolclientFactory.getLogLevel = () => getLogLevel();
                SolclientFactory.setLogLevel = newLevel => {
                    isEnumMember("logLevel", newLevel, LogLevel);
                    setLogLevel(newLevel);
                };
                SolclientFactory.addInitializer(props => {
                    setLogLevel(props.logLevel);
                    const logger = props.logger || getImpl() || new ConsoleLogImpl();
                    Object.keys(new LogImpl()).forEach(key => isFunction(`logger.` + key, logger[key]));
                    setImpl(logger);
                });
                addGlobalFuncs(forwarder, module.exports);
                module.exports.LogImpl = LogImpl;
                module.exports.LogLevel = LogLevel;
                module.exports.Binding = GlobalBinding;
                module.exports.ConsoleLogImpl = ConsoleLogImpl;
                GlobalBinding.setImpl(new ConsoleLogImpl());
                module.exports.LogFormatter = LogFormatter;
            },
            "./modules/solclient-log/lib/console-log-impl.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const LogImpl = __webpack_require__("./modules/solclient-log/lib/log-impl.js").LogImpl;
                const STUB = () => void 0;
                function generateLogHeader(levelStr) {
                    const date = new Date();
                    const levelStrPadding = " ".repeat(6 - levelStr.length);
                    let YY = String(date.getFullYear());
                    let MM = String(date.getMonth() + 1);
                    let DD = String(date.getDate());
                    let hh = String(date.getHours());
                    let mm = String(date.getMinutes());
                    let ss = String(date.getSeconds());
                    let ms = String(date.getMilliseconds());
                    YY = "0".repeat(4 - YY.length) + YY;
                    MM = MM.length < 2 ? `0` + MM : MM;
                    DD = DD.length < 2 ? `0` + DD : DD;
                    hh = hh.length < 2 ? `0` + hh : hh;
                    mm = mm.length < 2 ? `0` + mm : mm;
                    ss = ss.length < 2 ? `0` + ss : ss;
                    ms = ms.length < 3 ? `0` + ms : ms;
                    ms = ms.length < 3 ? `0` + ms : ms;
                    return [ `${YY}-${MM}-${DD} ${hh}:${mm}:${ss}.` + ms, `` + levelStr + levelStrPadding ];
                }
                class ConsoleLogImpl extends LogImpl {
                    constructor(consoleIn) {
                        let _trace = STUB;
                        let _debug = STUB;
                        let _info = STUB;
                        let _warn = STUB;
                        let _error = STUB;
                        let _fatal = STUB;
                        const console = consoleIn || ("undefined" === typeof window ? __webpack_require__.g : window).console;
                        if (console && (console.log || console.warn)) {
                            if (console.log && void 0 !== console.log) {
                                _trace = Function.prototype.bind.call(console.log, console);
                                _debug = Function.prototype.bind.call(console.log, console);
                            } else if (console.debug && "function" === typeof console.debug) {
                                _trace = Function.prototype.bind.call(console.debug, console);
                                _debug = Function.prototype.bind.call(console.debug, console);
                            }
                            if (console.info && void 0 !== console.info) _info = Function.prototype.bind.call(console.info, console); else _info = Function.prototype.bind.call(console.log, console);
                            if (console.warn && void 0 !== console.warn) _warn = Function.prototype.bind.call(console.warn, console); else _warn = Function.prototype.bind.call(console.log, console);
                            if (console.error && void 0 !== console.error) {
                                _error = Function.prototype.bind.call(console.error, console);
                                _fatal = Function.prototype.bind.call(console.error, console);
                            } else {
                                _error = Function.prototype.bind.call(console.log, console);
                                _fatal = Function.prototype.bind.call(console.log, console);
                            }
                        }
                        super((...args) => {
                            _trace(...generateLogHeader("TRACE"), ...args);
                        }, (...args) => {
                            _debug(...generateLogHeader("DEBUG"), ...args);
                        }, (...args) => {
                            _info(...generateLogHeader("INFO"), ...args);
                        }, (...args) => {
                            _warn(...generateLogHeader("WARN"), ...args);
                        }, (...args) => {
                            _error(...generateLogHeader("ERROR"), ...args);
                        }, (...args) => {
                            _fatal(...generateLogHeader("FATAL"), ...args);
                        });
                    }
                }
                module.exports.ConsoleLogImpl = ConsoleLogImpl;
            },
            "./modules/solclient-log/lib/global-binding.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const LogLevel = __webpack_require__("./modules/solclient-log/lib/log-levels.js").LogLevel;
                const state = {
                    impl: null,
                    level: LogLevel.INFO
                };
                const LogBinding = {};
                LogBinding.getImpl = function() {
                    return state.impl;
                };
                LogBinding.setImpl = function(impl) {
                    state.impl = impl;
                };
                LogBinding.getLogLevel = function() {
                    return state.level;
                };
                LogBinding.setLogLevel = function(level) {
                    state.level = level;
                };
                module.exports.GlobalBinding = LogBinding;
            },
            "./modules/solclient-log/lib/log-impl.js": module => {
                class LogImpl {
                    constructor(trace, debug, info, warn, error, fatal) {
                        Object.assign(this, {
                            trace: trace,
                            debug: debug,
                            info: info,
                            warn: warn,
                            error: error,
                            fatal: fatal
                        });
                    }
                    trace() {}
                    debug() {}
                    info() {}
                    warn() {}
                    error() {}
                    fatal() {}
                }
                module.exports.LogImpl = LogImpl;
            },
            "./modules/solclient-log/lib/log-levels.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const LogLevel = {
                    FATAL: 0,
                    ERROR: 1,
                    WARN: 2,
                    INFO: 3,
                    DEBUG: 4,
                    TRACE: 5
                };
                module.exports.LogLevel = Enum.new(LogLevel);
            },
            "./modules/solclient-message-consumer/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ConsumerFlows = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-flows.js").ConsumerFlows;
                const ConsumerFSMEvent = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event.js").ConsumerFSMEvent;
                const ConsumerFSMEventNames = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js").ConsumerFSMEventNames;
                const MessageConsumer = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer.js").MessageConsumer;
                const MessageConsumerAcknowledgeMode = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js").MessageConsumerAcknowledgeMode;
                const MessageConsumerEvent = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event.js").MessageConsumerEvent;
                const MessageConsumerEventName = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js").MessageConsumerEventName;
                const MessageConsumerProperties = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-properties.js").MessageConsumerProperties;
                const QueueBrowser = __webpack_require__("./modules/solclient-message-consumer/lib/queue-browser.js").QueueBrowser;
                const QueueBrowserEventName = __webpack_require__("./modules/solclient-message-consumer/lib/queue-browser-event-names.js").QueueBrowserEventName;
                const QueueBrowserProperties = __webpack_require__("./modules/solclient-message-consumer/lib/queue-browser-properties.js").QueueBrowserProperties;
                module.exports.ConsumerFlows = ConsumerFlows;
                module.exports.ConsumerFSMEvent = ConsumerFSMEvent;
                module.exports.ConsumerFSMEventNames = ConsumerFSMEventNames;
                module.exports.MessageConsumer = MessageConsumer;
                module.exports.MessageConsumerEvent = MessageConsumerEvent;
                module.exports.MessageConsumerAcknowledgeMode = MessageConsumerAcknowledgeMode;
                module.exports.MessageConsumerEventName = MessageConsumerEventName;
                module.exports.MessageConsumerProperties = MessageConsumerProperties;
                module.exports.QueueBrowser = QueueBrowser;
                module.exports.QueueBrowserEventName = QueueBrowserEventName;
                module.exports.QueueBrowserProperties = QueueBrowserProperties;
            },
            "./modules/solclient-message-consumer/lib/application-acks.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum,
                    assert
                } = __webpack_require__("./modules/solclient-eskit/api.js");
                const MessageOutcome = __webpack_require__("./modules/solclient-message/api.js").MessageOutcome;
                const LOG_ERROR = __webpack_require__("./modules/solclient-log/api.js").LOG_ERROR;
                const ApplicationAckState = Enum.new({
                    UNACKED: "UNACKED",
                    ACKED_NOT_SENT: "ACKED_NOT_SENT",
                    ACKED_SENT: "ACKED_SENT"
                });
                class ApplicationAck {
                    constructor(id, state, settlementOutcome) {
                        if (id) {
                            this.exists = true;
                            this.id = id;
                            this.key = id.toString();
                            this.state = state || ApplicationAckState.UNACKED;
                            this.settlementOutcome = settlementOutcome || MessageOutcome.ACCEPTED;
                        } else this.exists = false;
                    }
                    set(id, state, settlementOutcome = void 0) {
                        this.exists = true;
                        this.id = id;
                        this.key = id.toString();
                        this.state = state || ApplicationAckState.UNACKED;
                        this.settlementOutcome = void 0 !== settlementOutcome ? settlementOutcome : null;
                    }
                    clear() {
                        this.exists = false;
                        this.id = null;
                        this.key = null;
                        this.state = null;
                        this.settlementOutcome = null;
                    }
                }
                class ApplicationAckRingBuffer {
                    constructor(size) {
                        assert(size >= 2);
                        this._size = size;
                        this._insertIndex = 0;
                        this._buffer = Array(size).fill(null).map(() => new ApplicationAck());
                        this._index = new Map();
                    }
                    reset() {
                        this._insertIndex = 0;
                        this._buffer.forEach(ack => {
                            ack.exists = false;
                        });
                        this._index.clear();
                    }
                    insert(id, beforeEvictCallback) {
                        assert(beforeEvictCallback);
                        assert(id);
                        const size = this._size;
                        const buffer = this._buffer;
                        const index = this._index;
                        const insertIndex = this._insertIndex;
                        assert(!buffer[insertIndex].exists, "Invariant not enforced (before): insert index not empty");
                        const inserting = buffer[insertIndex];
                        inserting.set(id, ApplicationAckState.UNACKED);
                        if (index.has(inserting.key)) LOG_ERROR(`Duplicate ID: ${index.get(inserting.key)} insertIndex: ` + insertIndex);
                        index.set(inserting.key, insertIndex);
                        const evictingIndex = (insertIndex + 1) % size;
                        const evicting = buffer[evictingIndex];
                        let result;
                        try {
                            result = beforeEvictCallback(evicting.exists ? evicting : null);
                        } finally {
                            this._insertIndex = (insertIndex + 1) % size;
                            if (evicting.exists) {
                                index.delete(evicting.key);
                                evicting.clear();
                            }
                        }
                        assert(!buffer[this._insertIndex].exists, "Invariant not enforced (after): insert index not empty");
                        return result;
                    }
                    get length() {
                        return this._index.size;
                    }
                    front() {
                        if (0 === this.length) return null;
                        const buffer = this._buffer;
                        const insertIndex = this._insertIndex;
                        const size = this._size;
                        const firstIndex = (insertIndex + 1) % size;
                        if (buffer[firstIndex].exists) return buffer[firstIndex];
                        for (let rawIndex = firstIndex, lastIndex = firstIndex + size - 1; rawIndex <= lastIndex; ++rawIndex) {
                            const readIndex = rawIndex % size;
                            const element = buffer[readIndex];
                            if (element.exists) return element;
                        }
                        assert(0 === this._index.size, "#front() failed so buffer must be empty");
                        return null;
                    }
                    forEach(callback) {
                        if (0 === this.length) return;
                        const buffer = this._buffer;
                        const size = this._size;
                        let index = 0;
                        for (let rawIndex = this._insertIndex + 1, lastIndex = this._insertIndex + size; rawIndex <= lastIndex; ++rawIndex) {
                            const readIndex = rawIndex % size;
                            const element = buffer[readIndex];
                            if (element.exists) callback(element, index++, this);
                        }
                        assert(index > 0, "Not empty but did not dispatch");
                    }
                    updateAckState(id, state, settlementOutcome = void 0) {
                        const key = id.toString();
                        assert(this._index.has(key), "Ack key not found");
                        const buffer = this._buffer;
                        const updateIndex = this._index.get(key);
                        const existing = buffer[updateIndex];
                        assert(existing, "Ack key has no entry");
                        existing.state = state;
                        if (void 0 != settlementOutcome) existing.settlementOutcome = settlementOutcome; else if (state === ApplicationAckState.ACKED_NOT_SENT) existing.settlementOutcome = MessageOutcome.ACCEPTED;
                    }
                    has(id) {
                        const key = id.toString();
                        return this._index.has(key);
                    }
                }
                Object.assign(module.exports, {
                    ApplicationAckState: ApplicationAckState,
                    ApplicationAck: ApplicationAck,
                    ApplicationAckRingBuffer: ApplicationAckRingBuffer
                });
            },
            "./modules/solclient-message-consumer/lib/consumer-flows.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const assert = __webpack_require__("./modules/solclient-eskit/api.js").assert;
                const MessageConsumer = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer.js").MessageConsumer;
                const MessageConsumerEventName = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js").MessageConsumerEventName;
                class ConsumerFlows {
                    constructor() {
                        this._allFlows = new Set();
                        this._reconnectingFlows = new Set();
                        this._flowsById = {};
                    }
                    add(flow) {
                        assert(flow instanceof MessageConsumer, "Flow was not a consumer");
                        if (this._allFlows.has(flow)) return flow;
                        const flowUp = () => {
                            this._flowsById[flow.flowId] = flow;
                        };
                        const flowDisposed = () => {
                            const flowId = flow.flowId;
                            this._allFlows.delete(flow);
                            this._reconnectingFlows.delete(flow);
                            const flowById = this._flowsById[flowId];
                            if (flowById === flow) delete this._flowsById[flowId];
                        };
                        const flowReconnecting = () => {
                            flowDisposed();
                            this._reconnectingFlows.add(flow);
                        };
                        const flowReconnected = () => {
                            flowUp();
                            this._allFlows.add(flow);
                            this._reconnectingFlows.delete(flow);
                        };
                        const flowDown = () => {
                            this._reconnectingFlows.delete(flow);
                        };
                        flow._on(MessageConsumerEventName.UP, flowUp);
                        flow._on(MessageConsumerEventName.RECONNECTED, flowReconnected);
                        flow._on(MessageConsumerEventName.DISPOSED, flowDisposed);
                        flow._on(MessageConsumerEventName.RECONNECTING, flowReconnecting);
                        flow._on(MessageConsumerEventName.DOWN, flowDown);
                        flow._on(MessageConsumerEventName.DOWN_ERROR, flowDown);
                        this._allFlows.add(flow);
                        return flow;
                    }
                    get flows() {
                        return Array.from(this._allFlows);
                    }
                    get reconnectingFlows() {
                        return Array.from(this._reconnectingFlows);
                    }
                    getFlowById(flowId) {
                        return this._flowsById[flowId];
                    }
                    disposeAll() {
                        this._allFlows.forEach(flow => flow.dispose());
                    }
                }
                module.exports.ConsumerFlows = ConsumerFlows;
            },
            "./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const ConsumerFSMEventNames = {
                    SESSION_UP: "SESSION_UP",
                    SESSION_UP_NO_AD: "SESSION_UP_NO_AD",
                    SESSION_DOWN: "SESSION_DOWN",
                    SESSION_DISCONNECT: "SESSION_DISCONNECT",
                    FLOW_FAILED: "FLOW_FAILED",
                    FLOW_UP: "FLOW_UP",
                    FLOW_ACTIVE_IND: "FLOW_ACTIVE_IND",
                    FLOW_CLOSE: "FLOW_CLOSE",
                    FLOW_OPEN: "FLOW_OPEN",
                    FLOW_UNBOUND: "FLOW_UNBOUND",
                    ACK: "ACK",
                    ACK_TIMEOUT: "ACK_TIMEOUT",
                    BIND_TIMEOUT: "BIND_TIMEOUT",
                    CREATE_TIMEOUT: "CREATE_TIMEOUT",
                    UNBIND_TIMEOUT: "UNBIND_TIMEOUT",
                    CAN_SEND: "CAN_SEND",
                    TRANSPORT_ERROR: "TRANSPORT_ERROR",
                    DISPOSE: "DISPOSE",
                    VIRTUALROUTER_NAME_CHANGED: "VIRTUALROUTER_NAME_CHANGED",
                    RECONNECT_INTERVAL_TIMEOUT: "RECONNECT_INTERVAL_TIMEOUT",
                    BIND_RESPONSE: "BIND_RESPONSE",
                    CREATE_FAILED: "CREATE_FAILED",
                    CREATE_SUCCESS: "CREATE_SUCCESS"
                };
                module.exports.ConsumerFSMEventNames = Enum.new(ConsumerFSMEventNames);
            },
            "./modules/solclient-message-consumer/lib/consumer-fsm-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const FsmEvent = __webpack_require__("./modules/solclient-fsm/api.js").FsmEvent;
                class ConsumerFSMEvent extends FsmEvent {
                    constructor(spec, details) {
                        super(spec);
                        this.details = details;
                    }
                }
                module.exports.ConsumerFSMEvent = ConsumerFSMEvent;
            },
            "./modules/solclient-message-consumer/lib/consumer-fsm.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const {
                    ApplicationAck,
                    ApplicationAckRingBuffer,
                    ApplicationAckState
                } = __webpack_require__("./modules/solclient-message-consumer/lib/application-acks.js");
                const assert = __webpack_require__("./modules/solclient-eskit/api.js").assert;
                const CapabilityType = __webpack_require__("./modules/solclient-session/api.js").CapabilityType;
                const ConsumerFSMEvent = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event.js").ConsumerFSMEvent;
                const ConsumerFSMEventNames = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js").ConsumerFSMEventNames;
                const ConsumerStateNames = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-state-names.js").ConsumerStateNames;
                const {
                    DestinationFromNetwork,
                    DestinationType,
                    Queue,
                    Topic
                } = __webpack_require__("./modules/solclient-destination/api.js");
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const Long = __webpack_require__("./modules/solclient-convert/api.js").Long;
                const MessageConsumerAcknowledgeMode = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js").MessageConsumerAcknowledgeMode;
                const MessageConsumerEventName = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js").MessageConsumerEventName;
                const MessageDispatcher = __webpack_require__("./modules/solclient-message-consumer/lib/message-dispatcher.js").MessageDispatcher;
                const PrivateFlowEventName = __webpack_require__("./modules/solclient-flow/api.js").PrivateFlowEventName;
                const {
                    QueueAccessType,
                    QueueDescriptor,
                    QueuePermissions,
                    QueueProperties,
                    QueueType
                } = __webpack_require__("./modules/solclient-queue/api.js");
                const {
                    MessageOutcome,
                    RgmidFactory
                } = __webpack_require__("./modules/solclient-message/api.js");
                const {
                    State,
                    StateMachine
                } = __webpack_require__("./modules/solclient-fsm/api.js");
                const {
                    Stats,
                    StatType
                } = __webpack_require__("./modules/solclient-stats/api.js");
                const Timer = __webpack_require__("./modules/solclient-events/api.js").Timer;
                const {
                    TransportAcks,
                    TransportAckResult
                } = __webpack_require__("./modules/solclient-message-consumer/lib/transport-acks.js");
                const RING_BUFFER_SIZE = 512;
                const ZERO_APP_ACK = new ApplicationAck(Long.UZERO, ApplicationAckState.ACKED_SENT, MessageOutcome.ACCEPTED);
                class ConsumerFSM extends StateMachine {
                    constructor({
                        name,
                        consumer,
                        sessionInterface,
                        properties
                    } = {}) {
                        super({
                            name: name
                        });
                        const fsm = this;
                        const formatter = function(...args) {
                            return [ `[session=${sessionInterface.sessionIdHex}]`, `[message-consumer-fsm=${consumer.flowIdDec}]`, ...args ];
                        };
                        const logger = this.logger = new LogFormatter(formatter);
                        const {
                            LOG_INFO,
                            LOG_WARN,
                            LOG_ERROR
                        } = logger;
                        this.log = logger.wrap(this.log, this);
                        const autoAck = properties.acknowledgeMode === MessageConsumerAcknowledgeMode.AUTO;
                        this._consumer = consumer;
                        this._sessionInterface = sessionInterface;
                        this._acknowledgeTimeoutInMsecs = properties.acknowledgeTimeoutInMsecs;
                        this._acknowledgeThreshold = properties.acknowledgeThreshold;
                        this._localPreferredWindowSize = properties.windowSize;
                        this._localMaxWindowSize = properties.windowSize;
                        this._hasAutoAckSupport = autoAck;
                        this._messageDispatch = new MessageDispatcher({
                            emitter: consumer,
                            autoAck: autoAck,
                            logger: logger
                        });
                        this._stats = new Stats();
                        this._resetRemoteConnectionState();
                        this._resetLocalConnectionState();
                        this._midDispatch = false;
                        this._replayStartLocation = properties.replayStartLocation;
                        this._errorCausingReconnect = null;
                        const emitEventActionType = "EMIT";
                        const startDispatchActionType = "DISPATCH";
                        const stopDispatchActionType = "NO_DISPATCH";
                        let postEventActions = [];
                        function preprocessPostEventActions(startIndex) {
                            postEventActions;
                            const actionLocations = {};
                            postEventActions.forEach((action, i, arr) => {
                                function cancelAction(firstActionName, cancellingActionName) {
                                    if (void 0 === actionLocations[firstActionName]) return;
                                    const firstLocation = actionLocations[firstActionName];
                                    firstLocation;
                                    actionLocations[firstActionName] = void 0;
                                    arr[firstLocation] = null;
                                    arr[i] = null;
                                }
                                if (i < startIndex || !action) return;
                                switch (action.type) {
                                  case emitEventActionType:
                                    switch (action.data) {
                                      case MessageConsumerEventName.UP:
                                      case MessageConsumerEventName.ACTIVE:
                                      case MessageConsumerEventName.RECONNECTED:
                                        actionLocations[action.data] = i;
                                        break;

                                      case MessageConsumerEventName.DOWN:
                                      case MessageConsumerEventName.DOWN_ERROR:
                                        cancelAction(MessageConsumerEventName.UP, action.data);
                                        break;

                                      case MessageConsumerEventName.INACTIVE:
                                        cancelAction(MessageConsumerEventName.ACTIVE, action.data);
                                        break;

                                      default:
                                        LOG_ERROR(`Unexpected event in post-event action: ` + action.data);
                                        break;
                                    }
                                    break;

                                  case startDispatchActionType:
                                    actionLocations[action.type] = i;
                                    break;

                                  case stopDispatchActionType:
                                    cancelAction(startDispatchActionType, action.type);
                                    break;

                                  default:
                                    break;
                                }
                            });
                        }
                        function processPostEventActions() {
                            let preprocessedActions = 0;
                            let i;
                            postEventActions;
                            for (i = 0; i < postEventActions.length; ++i) {
                                if (preprocessedActions < postEventActions.length) {
                                    preprocessPostEventActions(i);
                                    preprocessedActions = postEventActions.length;
                                }
                                const action = postEventActions[i];
                                i, action;
                                if (!action) continue;
                                switch (action.type) {
                                  case emitEventActionType:
                                    if (void 0 !== action.error) consumer._emit(action.data, action.error); else consumer._emit(action.data);
                                    break;

                                  case stopDispatchActionType:
                                    break;

                                  case startDispatchActionType:
                                    this.requestStartDispatchFSM();
                                    break;

                                  default:
                                    LOG_ERROR(`Unhandled post event action type: ` + action.type);
                                    break;
                                }
                            }
                            postEventActions = [];
                        }
                        function addPostEventAction(type, data, error) {
                            let newEvent;
                            if (void 0 !== data) newEvent = {
                                type: type,
                                data: data,
                                error: error
                            }; else newEvent = {
                                type: type
                            };
                            postEventActions.push(newEvent);
                            postEventActions.length, newEvent;
                            if (1 === postEventActions.length) fsm.setPostEventAction(processPostEventActions);
                        }
                        const addEventToEmit = (event, error) => {
                            if (!properties.activeIndicationEnabled) if (event === MessageConsumerEventName.INACTIVE || event === MessageConsumerEventName.ACTIVE) return;
                            addPostEventAction(emitEventActionType, event, error);
                        };
                        const requestStartDispatch = () => {
                            addPostEventAction(startDispatchActionType);
                        };
                        const requestStopDispatch = () => {
                            this.requestStopDispatchFSM();
                            addPostEventAction(stopDispatchActionType);
                        };
                        this._addEventToEmit = addEventToEmit;
                        this._requestStartDispatch = requestStartDispatch;
                        this._requestStopDispatch = requestStopDispatch;
                        function emitBindFailed(error) {
                            assert(error instanceof OperationError);
                            consumer._emit(MessageConsumerEventName.CONNECT_FAILED_ERROR, error);
                        }
                        function emitRebindFailed(error) {
                            assert(error instanceof OperationError);
                            consumer._emit(MessageConsumerEventName.DOWN_ERROR, error);
                        }
                        function verifyEndpointSubscription(destination) {
                            let error = null;
                            if (destination) {
                                const subInfo = destination.getSubscriptionInfo();
                                if (subInfo && (subInfo.isShare || subInfo.isNoExport) && !fsm._sessionInterface.isCapable(CapabilityType.SHARED_SUBSCRIPTIONS)) error = new OperationError("Shared Subscriptions not Supported", ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED);
                            }
                            return error;
                        }
                        function verifyNackSettlementOutcomesSupport(requiredSettlementOutcomes) {
                            let error = null;
                            const settlementOutcomes = requiredSettlementOutcomes;
                            if (settlementOutcomes && settlementOutcomes.length > 0) {
                                const isNackRequired = settlementOutcomes.some(v => v === MessageOutcome.FAILED || MessageOutcome.REJECTED);
                                if (isNackRequired && !fsm._sessionInterface.isCapable(CapabilityType.AD_APP_ACK_FAILED)) {
                                    const outcomeNotSupportedError = `Session.capabilitySettlementOutcomeNotSupported: [ ${settlementOutcomes.map(v => MessageOutcome.nameOf(v)).join(", ")} ]`;
                                    LOG_WARN(outcomeNotSupportedError);
                                    error = new OperationError(outcomeNotSupportedError, ErrorSubcode.INVALID_OPERATION);
                                }
                            }
                            return error;
                        }
                        function checkCapabilitiesChoicePoint(curState) {
                            let error = null;
                            if (void 0 !== fsm._replayStartLocation && !fsm._sessionInterface.isCapable(CapabilityType.MESSAGE_REPLAY)) error = new OperationError("Message Replay Not Supported", ErrorSubcode.REPLAY_NOT_SUPPORTED); else if (properties.topicEndpointSubscription) error = verifyEndpointSubscription(properties.topicEndpointSubscription); else if (properties.requiredSettlementOutcomes) error = verifyNackSettlementOutcomesSupport(properties.requiredSettlementOutcomes);
                            if (error) return curState.transitionTo(fsm.Unbound, () => emitBindFailed(error));
                            if (properties.createIfMissing && properties.queueDescriptor && properties.queueDescriptor.durable) return curState.transitionTo(fsm.CreateSent);
                            return curState.transitionTo(fsm.BindSent);
                        }
                        function checkCapabilitiesChoicePointOnRebind(curState, externalTransition = false) {
                            let error = null;
                            if (properties.requiredSettlementOutcomes) error = verifyNackSettlementOutcomesSupport(properties.requiredSettlementOutcomes);
                            if (error) return curState.transitionTo(fsm.Unbound, () => emitBindFailed(error));
                            if (externalTransition) return curState.externalTransitionTo(fsm.Reconnecting.RBindSent);
                            return curState.transitionTo(fsm.Reconnecting.RBindSent);
                        }
                        function handleAccidentalBind(msg) {
                            const correlationTag = sessionInterface.getCorrelationTag();
                            const message = SMFLib.AdProtocolMessage.getCloseMessageConsumer(msg.flowId, correlationTag);
                            sessionInterface.sendControl(message);
                            sessionInterface.enqueueRequest(correlationTag, () => this.handleAccidentalBind(msg), properties.connectTimeoutInMsecs, null, null);
                        }
                        this.unhandledEventReaction(function(event) {
                            switch (event.getName()) {
                              case ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED:
                                LOG_INFO("VirtualRouter name change: clearing all acknowledgement state and partition group ID, if any");
                                fsm._resetRemoteConnectionState();
                                return this;

                              case ConsumerFSMEventNames.FLOW_UNBOUND:
                                LOG_INFO("Received unsolicited unbind. Flow may be manually reconnected.");
                                return this.transitionToUnbound(MessageConsumerEventName.DOWN_ERROR, event.details);

                              case ConsumerFSMEventNames.DISPOSE:
                                fsm._dispose();
                                return fsm.getCurrentState().terminate();

                              case ConsumerFSMEventNames.BIND_RESPONSE:
                                handleAccidentalBind(event.details);
                                return this;

                              default:
                                event.getName(), this.getCurrentState().getName();
                                return this;
                            }
                        });
                        this.initial(function() {
                            return this.transitionTo(fsm.Unbound, context => {
                                LOG_INFO(`Starting ` + context.getStateMachine().getName());
                            });
                        });
                        this.Unbound = new State({
                            name: ConsumerStateNames.UNBOUND,
                            parentContext: fsm
                        }, {
                            emitDisabledEvent() {
                                consumer._emit(MessageConsumerEventName.GM_DISABLED);
                            }
                        }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function() {
                            return this.transitionTo(this);
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function() {
                            return this.transitionTo(this);
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function() {
                            return this.transitionTo(this);
                        }).reaction(ConsumerFSMEventNames.FLOW_OPEN, function() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp);
                        }).reaction(ConsumerFSMEventNames.SESSION_UP, function() {
                            if (fsm._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME)) return this.transitionTo(fsm.Unbound.AwaitFlowOpen);
                            LOG_WARN(`Consumer is not supported by router for this client on sessionId 0x` + fsm._sessionInterface.sessionIdHex);
                            return this.internalTransition(() => this.emitDisabledEvent());
                        }).reaction(ConsumerFSMEventNames.SESSION_UP_NO_AD, function() {
                            return this.internalTransition(() => this.emitDisabledEvent());
                        }).exit(() => {
                            fsm._connectAttempts = properties.connectAttempts;
                        });
                        this.Unbound.AwaitSessionUp = new State({
                            name: ConsumerStateNames.UNBOUND_AWAIT_SESSION_UP,
                            parentContext: this.Unbound
                        }, {
                            emitBindWaiting() {
                                consumer._emit(PrivateFlowEventName.BIND_WAITING);
                            }
                        }).entry(function() {
                            this.emitBindWaiting();
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function() {
                            return this.internalTransition();
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function() {
                            return this.internalTransition();
                        }).reaction(ConsumerFSMEventNames.SESSION_UP, function() {
                            return checkCapabilitiesChoicePoint(this);
                        });
                        this.Unbound.AwaitFlowOpen = new State({
                            name: ConsumerStateNames.UNBOUND_AWAIT_FLOWOPEN,
                            parentContext: this.Unbound
                        }).reaction(ConsumerFSMEventNames.FLOW_OPEN, function() {
                            return checkCapabilitiesChoicePoint(this);
                        });
                        this.BindSentExtensions = {
                            sendBindRequest() {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                const transportAcks = fsm._transportAcks;
                                fsm._endpointEnsure();
                                const endpoint = fsm._endpoint;
                                const subscription = fsm._subscription;
                                const message = SMFLib.AdProtocolMessage.getOpenMessageConsumer(properties.queueDescriptor, properties.queueProperties, endpoint, subscription, correlationTag, properties.windowSize, properties.noLocal, properties.activeIndicationEnabled, transportAcks.lastAcked, transportAcks.lastReceived, properties.browser, fsm._replayStartLocation, consumer.endpointErrorId, consumer.partitionGroupId, properties.requiredSettlementOutcomes && properties.requiredSettlementOutcomes.length > 0);
                                sessionInterface.sendControl(message);
                                sessionInterface.enqueueRequest(correlationTag, this.handleBindTimeout.bind(this), properties.connectTimeoutInMsecs, null, this.handleBindResponse.bind(this));
                                properties.queueDescriptor, properties.queueProperties, 
                                endpoint, subscription, correlationTag, properties.windowSize, 
                                properties.noLocal, properties.activeIndicationEnabled, 
                                transportAcks.lastAcked, transportAcks.lastReceived, 
                                properties.browser, fsm._replayStartLocation, consumer.endpointErrorId, 
                                consumer.partitionGroupId, properties.requiredSettlementOutcomes;
                            },
                            cancelBindRequestTimer() {
                                this.bindRequestTimer.cancel();
                            },
                            handleBindTimeout() {
                                LOG_INFO("Bind timeout");
                                fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.BIND_TIMEOUT
                                }));
                            },
                            handleExpectedBind(msg) {
                                const accessTypeOrDefault = x => void 0 === x ? QueueAccessType.EXCLUSIVE : x;
                                let partitionGroupIdValue = msg.getPartitionGroupId();
                                if (void 0 == partitionGroupIdValue || null == partitionGroupIdValue) {
                                    partitionGroupIdValue = void 0;
                                    fsm._clearPartitionGroupId();
                                }
                                const attrs = {
                                    lastMsgIdAcked: msg.getLastMsgIdAcked(),
                                    flowId: msg.getFlowId(),
                                    accessType: accessTypeOrDefault(msg.getAccessType()),
                                    topicEndpointBytes: msg.getTopicEndpointBytes(),
                                    grantedPermissions: msg.getGrantedPermissions(),
                                    allOthersPermissions: msg.getAllOthersPermissions(),
                                    respectsTTL: msg.getRespectsTTL(),
                                    activeFlow: msg.getActiveFlow(),
                                    wantFlowChangeNotify: msg.getWantFlowChangeNotify(),
                                    discardBehavior: msg.getQueueDiscardBehavior(),
                                    deliveryCountSent: msg.getEndpointDeliveryCountSent(),
                                    endpointId: msg.getEndpointId(),
                                    maxUnackedMessages: msg.getMaxUnackedMessages(),
                                    endpointErrorId: msg.getEndpointErrorId(),
                                    spoolerUniqueId: msg.getSpoolerUniqueId(),
                                    quota: msg.getQuota(),
                                    maxMsgSize: msg.getMaxMsgSize(),
                                    maxRedelivery: msg.getMaxRedelivery(),
                                    partitionGroupId: partitionGroupIdValue
                                };
                                attrs;
                                Object.assign(consumer, {
                                    accessType: attrs.accessType,
                                    queueDiscardBehavior: attrs.discardBehavior,
                                    deliveryCountSent: attrs.deliveryCountSent,
                                    endpointId: attrs.endpointId,
                                    respectsTTL: attrs.respectsTTL,
                                    flowId: attrs.flowId,
                                    permissions: attrs.grantedPermissions,
                                    wantFlowChangeNotify: attrs.wantFlowChangeNotify,
                                    endpointErrorId: attrs.endpointErrorId,
                                    spoolerUniqueId: attrs.spoolerUniqueId,
                                    partitionGroupId: partitionGroupIdValue
                                });
                                if (fsm._sessionInterface.isCapable(CapabilityType.BR_REPLAY_ERRORID)) consumer.endpointErrorId = attrs.endpointErrorId;
                                if (attrs.topicEndpointBytes && attrs.topicEndpointBytes.length) {
                                    attrs.endpoint = DestinationFromNetwork.createDestinationFromBytes(attrs.topicEndpointBytes);
                                    fsm._endpoint, attrs.endpoint;
                                    fsm._endpoint = attrs.endpoint;
                                    const consumerProperties = fsm._consumer._properties;
                                    consumerProperties.queueDescriptor = new QueueDescriptor({
                                        name: attrs.endpoint.name,
                                        type: consumerProperties.queueDescriptor.type,
                                        durable: consumerProperties.queueDescriptor.durable
                                    });
                                }
                                const consumerProperties = fsm._consumer._properties;
                                consumerProperties.queueProperties = new QueueProperties({
                                    respectsTTL: attrs.respectsTTL,
                                    permissions: attrs.allOthersPermissions,
                                    quotaMB: attrs.quota,
                                    maxMessageSize: attrs.maxMsgSize,
                                    discardBehavior: attrs.discardBehavior,
                                    maxMessageRedelivery: attrs.maxRedelivery,
                                    accessType: attrs.accessType
                                });
                                if (!consumerProperties.queueProperties.permissions) consumerProperties.queueProperties.permissions = QueuePermissions.NONE;
                                Object.assign(fsm, {
                                    _active: attrs.activeFlow,
                                    _remoteWindowSize: attrs.maxUnackedMessages
                                });
                                if (Long.UZERO.eq(fsm._transportAcks.lastAcked)) fsm._transportAcks.lastAcked = attrs.lastMsgIdAcked || Long.UZERO; else fsm._transportAcks;
                            },
                            handleBindResponse(msg) {
                                if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.BIND) {
                                    LOG_INFO(`Unexpected message type in bind response: ` + SMFLib.SMFAdProtocolMessageType.describe(msg.msgType));
                                    return fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.FLOW_FAILED
                                    }, new OperationError(`Unexpected bind response: ` + SMFLib.SMFAdProtocolMessageType.describe(msg.msgType), ErrorSubcode.PROTOTOCOL_ERROR)));
                                }
                                const header = msg.smfHeader;
                                const responseCode = header.pm_respcode;
                                if (null === responseCode) {
                                    this._consumer.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                    this._sessionInterface.sessionIdHex;
                                    return;
                                }
                                if (200 !== responseCode) {
                                    const description = header.pm_respstr;
                                    const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                    LOG_INFO("Flow failed (bind):", responseCode, description, ErrorSubcode.describe(errorSubcode));
                                    errorSubcode;
                                    return fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.FLOW_FAILED
                                    }, new OperationError(description, errorSubcode, {
                                        responseCode: responseCode
                                    })));
                                }
                                const respEvent = {
                                    name: ConsumerFSMEventNames.BIND_RESPONSE
                                };
                                return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                            }
                        };
                        this.BindSent = new State({
                            name: ConsumerStateNames.BIND_SENT,
                            parentContext: fsm
                        }, this.BindSentExtensions).entry(function() {
                            fsm._connectAttempts--;
                            this.sendBindRequest();
                            this.bindRequestTimer = Timer.newTimeout(properties.connectTimeoutInMsecs, this.handleBindTimeout);
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp);
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp, () => fsm._addEventToEmit(MessageConsumerEventName.DOWN));
                        }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function() {
                            return this.transitionTo(fsm.UnbindSent);
                        }).reaction(ConsumerFSMEventNames.BIND_TIMEOUT, function() {
                            fsm._connectAttempts;
                            if (fsm._connectAttempts > 0) return this.externalTransitionTo(fsm.BindSent);
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(new OperationError("Bind failed due to timeout", ErrorSubcode.TIMEOUT)));
                        }).reaction(ConsumerFSMEventNames.FLOW_FAILED, function(evt) {
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(evt.details));
                        }).reaction(ConsumerFSMEventNames.BIND_RESPONSE, function(event) {
                            this.handleExpectedBind(event.details);
                            return this.transitionTo(fsm.FlowUp);
                        }).reaction(ConsumerFSMEventNames.FLOW_UP, function() {
                            return this.transitionTo(fsm.FlowUp);
                        }).exit(function() {
                            this.cancelBindRequestTimer();
                        });
                        this.Reconnecting = new State({
                            name: ConsumerStateNames.RECONNECTING,
                            parentContext: fsm
                        }).entry(function() {
                            this._errorCausingReconnect;
                            fsm._errorCausingReconnect;
                            consumer._emit(MessageConsumerEventName.RECONNECTING, fsm._errorCausingReconnect);
                            fsm._connectAttempts = properties.connectAttempts;
                            fsm.reconnectAttempts = properties.reconnectAttempts;
                        }).initial(function() {
                            return checkCapabilitiesChoicePointOnRebind(this, false);
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function() {
                            return this.transitionTo(fsm.Reconnecting.RAwaitSessionUp);
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function() {
                            return this.transitionTo(fsm.Reconnecting.RAwaitSessionUp);
                        });
                        this.Reconnecting.RAwaitSessionUp = new State({
                            name: ConsumerStateNames.RECONNECTING_AWAIT_SESSION_UP,
                            parentContext: this.Reconnecting
                        }).reaction(ConsumerFSMEventNames.SESSION_UP, function() {
                            fsm._connectAttempts = properties.connectAttempts;
                            return checkCapabilitiesChoicePointOnRebind(this, false);
                        });
                        this.Reconnecting.RBindSent = new State({
                            name: ConsumerStateNames.RECONNECTING_BIND_SENT,
                            parentContext: this.Reconnecting
                        }, this.BindSentExtensions).entry(function() {
                            fsm._connectAttempts--;
                            this.sendBindRequest();
                            this.bindRequestTimer = Timer.newTimeout(properties.connectTimeoutInMsecs, this.handleBindTimeout);
                        }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function() {
                            return this.transitionTo(fsm.UnbindSent);
                        }).reaction(ConsumerFSMEventNames.BIND_TIMEOUT, function() {
                            fsm._connectAttempts;
                            if (fsm._connectAttempts > 0) return checkCapabilitiesChoicePointOnRebind(this, true);
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(new OperationError("Rebind failed due to timeout", ErrorSubcode.TIMEOUT)));
                        }).reaction(ConsumerFSMEventNames.FLOW_FAILED, function(evt) {
                            if (fsm.reconnectAttempts > 0 || -1 === fsm.reconnectAttempts) {
                                if (evt && evt.details && evt.details.subcode) if (evt.details.subcode === ErrorSubcode.QUEUE_SHUTDOWN || evt.details.subcode === ErrorSubcode.TOPIC_ENDPOINT_SHUTDOWN || evt.details.subcode === ErrorSubcode.GM_UNAVAILABLE) {
                                    fsm.reconnectAttempts, evt.details.subcode;
                                    return this.transitionTo(fsm.Reconnecting.RAwaitTimer);
                                }
                            } else fsm.reconnectAttempts;
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitRebindFailed(evt.details));
                        }).reaction(ConsumerFSMEventNames.BIND_RESPONSE, function(event) {
                            this.handleExpectedBind(event.details);
                            return this.transitionTo(fsm.FlowUp, () => fsm._addEventToEmit(MessageConsumerEventName.RECONNECTED));
                        }).reaction(ConsumerFSMEventNames.FLOW_UP, function() {
                            return this.transitionTo(fsm.FlowUp, () => fsm._addEventToEmit(MessageConsumerEventName.RECONNECTED));
                        }).exit(function() {
                            this.cancelBindRequestTimer();
                        });
                        this.Reconnecting.RAwaitTimer = new State({
                            name: ConsumerStateNames.RECONNECTING_AWAIT_TIMER,
                            parentContext: this.Reconnecting
                        }, {
                            handleReconnectIntervalTimeout() {
                                fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.RECONNECT_INTERVAL_TIMEOUT
                                }));
                            },
                            cancelReconnectIntervalTimer() {
                                this.reconnectIntervalTimer.cancel();
                            }
                        }).entry(function() {
                            if (fsm.reconnectAttempts > 0) --fsm.reconnectAttempts;
                            properties.reconnectIntervalInMsecs, fsm.reconnectAttempts;
                            this.reconnectIntervalTimer = Timer.newTimeout(properties.reconnectIntervalInMsecs, this.handleReconnectIntervalTimeout);
                        }).exit(function() {
                            this.cancelReconnectIntervalTimer();
                        }).reaction(ConsumerFSMEventNames.RECONNECT_INTERVAL_TIMEOUT, function() {
                            fsm._connectAttempts = properties.connectAttempts;
                            return checkCapabilitiesChoicePointOnRebind(this, false);
                        });
                        const flowUpFSM = this.FlowUp = new State({
                            name: ConsumerStateNames.FLOW_UP,
                            parentContext: fsm
                        }).initial(function() {
                            return this.transitionTo(0 === fsm._active ? flowUpFSM.XferInactive : flowUpFSM.Xfer);
                        }).entry(() => {
                            fsm._replayStartLocation = void 0;
                            if (!fsm._errorCausingReconnect) fsm._addEventToEmit(MessageConsumerEventName.UP); else fsm._errorCausingReconnect = null;
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp);
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp, () => fsm._addEventToEmit(MessageConsumerEventName.DOWN));
                        }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function() {
                            return this.transitionTo(fsm.UnbindSent);
                        }).reaction(ConsumerFSMEventNames.FLOW_UNBOUND, event => fsm.transitionToUnboundFromUp(properties, MessageConsumerEventName.DOWN_ERROR, event.details));
                        flowUpFSM.Xfer = new State({
                            name: ConsumerStateNames.FLOW_UP_XFER,
                            parentContext: flowUpFSM
                        }).entry(() => {
                            fsm._addEventToEmit(MessageConsumerEventName.ACTIVE);
                            fsm._sendAcks(true);
                            fsm._requestStartDispatch();
                        }).exit(() => {
                            fsm._addEventToEmit(MessageConsumerEventName.INACTIVE);
                            fsm._requestStopDispatch();
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function() {
                            fsm._sendAcks(true);
                            return this.eventUnhandled();
                        });
                        flowUpFSM.XferInactive = new State({
                            name: ConsumerStateNames.FLOW_UP_XFER_INACTIVE,
                            parentContext: flowUpFSM
                        }).reaction(ConsumerFSMEventNames.FLOW_ACTIVE_IND, function() {
                            return this.transitionTo(flowUpFSM.Xfer);
                        });
                        this.UnbindSent = new State({
                            name: ConsumerStateNames.UNBIND_SENT,
                            parentContext: fsm
                        }, {
                            sendUnbindRequest() {
                                fsm._endpointClear();
                                try {
                                    const correlationTag = sessionInterface.getCorrelationTag();
                                    const message = SMFLib.AdProtocolMessage.getCloseMessageConsumer(consumer.flowId, correlationTag);
                                    sessionInterface.sendControl(message);
                                    sessionInterface.enqueueRequest(correlationTag, () => this.handleUnbindTimeout(), properties.connectTimeoutInMsecs, null, response => this.handleUnbindResponse(response));
                                    LOG_INFO("Sent consumer unbind request with arguments", {
                                        flowId: consumer.flowId,
                                        correlationTag: correlationTag
                                    });
                                } catch (e) {
                                    LOG_INFO(`Exception in sendUnbindRequest while trying to send unbind request: ` + e);
                                    sessionInterface.getCurrentStateName();
                                    fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.FLOW_UNBOUND
                                    }));
                                }
                            },
                            handleUnbindTimeout() {
                                LOG_INFO("Unbind timeout");
                                return fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.UNBIND_TIMEOUT
                                }));
                            },
                            handleUnbindResponse(msg) {
                                if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.UNBIND) LOG_INFO(`Unexpected message type in bind response: ` + SMFLib.SMFAdProtocolMessageType.describe(msg.msgType));
                                const responseCode = msg.smfHeader.pm_respcode;
                                const description = msg.smfHeader.pm_respstr;
                                const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                consumer.endpointErrorId = msg.getEndpointErrorId();
                                LOG_INFO("Flow failed (unbind):", responseCode, description, ErrorSubcode.describe(errorSubcode));
                                return fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.FLOW_UNBOUND
                                }, new OperationError(description, errorSubcode, responseCode)));
                            }
                        }).entry(function() {
                            this.sendUnbindRequest();
                        }).reaction(ConsumerFSMEventNames.UNBIND_TIMEOUT, function() {
                            return this.externalTransitionTo(fsm.UnbindSent);
                        }).reaction(ConsumerFSMEventNames.FLOW_UNBOUND, () => fsm.transitionToUnbound(MessageConsumerEventName.DOWN));
                        this.CreateSent = new State({
                            name: ConsumerStateNames.CREATE_SENT,
                            parentContext: fsm
                        }, {
                            sendCreateRequest() {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                const message = SMFLib.AdProtocolMessage.getCreate(properties.queueDescriptor, properties.queueProperties, correlationTag);
                                sessionInterface.sendControl(message);
                                sessionInterface.enqueueRequest(correlationTag, this.handleCreateTimeout.bind(this), properties.connectTimeoutInMsecs, null, this.handleCreateResponse.bind(this));
                            },
                            handleCreateTimeout() {
                                LOG_INFO("Create timeout");
                                fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.CREATE_TIMEOUT
                                }));
                            },
                            handleCreateResponse(msg) {
                                if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.CREATE) {
                                    LOG_INFO(`Unexpected message type in create response: ` + SMFLib.SMFAdProtocolMessageType.describe(msg.msgType));
                                    return fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.CREATE_FAILED
                                    }, new OperationError(`Unexpected create response: ` + SMFLib.SMFAdProtocolMessageType.describe(msg.msgType), ErrorSubcode.PROTOTOCOL_ERROR)));
                                }
                                const header = msg.smfHeader;
                                const responseCode = header.pm_respcode;
                                if (200 !== responseCode) {
                                    const description = header.pm_respstr;
                                    const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                    LOG_INFO("Endpoint create failed:", responseCode, description, ErrorSubcode.describe(errorSubcode));
                                    errorSubcode;
                                    if (errorSubcode === ErrorSubcode.ENDPOINT_ALREADY_EXISTS) {
                                        errorSubcode;
                                        const respEvent = {
                                            name: ConsumerFSMEventNames.CREATE_SUCCESS
                                        };
                                        return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                                    }
                                    errorSubcode;
                                    return fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.CREATE_FAILED
                                    }, new OperationError(description, errorSubcode, {
                                        responseCode: responseCode
                                    })));
                                }
                                const respEvent = {
                                    name: ConsumerFSMEventNames.CREATE_SUCCESS
                                };
                                return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                            }
                        }).entry(function() {
                            this.sendCreateRequest();
                        }).reaction(ConsumerFSMEventNames.CREATE_TIMEOUT, function() {
                            return this.externalTransitionTo(fsm.BindSent);
                        }).reaction(ConsumerFSMEventNames.CREATE_SUCCESS, function() {
                            return this.externalTransitionTo(fsm.BindSent);
                        }).reaction(ConsumerFSMEventNames.CREATE_FAILED, function(evt) {
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(evt.details));
                        });
                    }
                    acceptMessage(message) {
                        const {} = this.logger;
                        const messageID = message.getGuaranteedMessageId();
                        const idstr = messageID.toString();
                        const consumer = this._consumer;
                        if (!this._fsmDispatch) {
                            consumer.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                            return false;
                        }
                        if (!consumer.deliveryCountSent) message.setDeliveryCount(-1);
                        const messageSuid = message._getSpoolerUniqueId();
                        if (RgmidFactory.INVALID_SUID.eq(messageSuid)) message._setSpoolerUniqueId(consumer.spoolerUniqueId); else if (void 0 !== consumer.spoolerUniqueId && !RgmidFactory.INVALID_SUID.eq(consumer.spoolerUniqueId)) {
                            const consumerSuidStr = consumer.spoolerUniqueId.toString();
                            const msgSuidStr = messageSuid.toString();
                            consumerSuidStr, msgSuidStr;
                            consumer.spoolerUniqueId = messageSuid;
                        } else if ((void 0 === consumer.spoolerUniqueId || RgmidFactory.INVALID_SUID.eq(consumer.spoolerUniqueId)) && !RgmidFactory.INVALID_SUID.eq(messageSuid)) message._setSpoolerUniqueId(RgmidFactory.INVALID_SUID);
                        const transportAcks = this._transportAcks;
                        const ackResult = transportAcks.tryReceive(messageID, message.getGuaranteedPreviousMessageId());
                        const transportAckRequired = transportAcks.acksPending > this.maxPendingAcks;
                        switch (ackResult) {
                          case TransportAckResult.OK:
                            break;

                          case TransportAckResult.DUPLICATE:
                            consumer.incStat(StatType.RX_DISCARD_DUPLICATE);
                            if (!this._applicationAcks.has(messageID) && !this._oldUnacked.has(idstr)) {
                                idstr;
                                const dupAckRanges = new Map();
                                dupAckRanges.set(MessageOutcome.ACCEPTED, [ [ messageID, messageID ] ]);
                                this._sendAck(dupAckRanges);
                            } else if (transportAckRequired) this._sendAcks(transportAckRequired); else this._setTransportAckTimer();
                            return false;

                          case TransportAckResult.OUT_OF_ORDER:
                            consumer.incStat(StatType.RX_DISCARD_OUT_OF_ORDER);
                            return false;

                          default:
                            assert(false, "Unhandled transport ack result", ackResult);
                            return false;
                        }
                        return this._applicationAcks.insert(messageID, evicting => {
                            let applicationAckRequired = false;
                            if (evicting) switch (evicting.state) {
                              case ApplicationAckState.UNACKED:
                                this._oldUnacked.add(evicting.key);
                                break;

                              case ApplicationAckState.ACKED_NOT_SENT:
                                applicationAckRequired = true;
                                break;

                              case ApplicationAckState.ACKED_SENT:
                                break;

                              default:
                                assert(false, "Unhandled application ack state", ApplicationAckState.describe(evicting.state));
                            }
                            this._midDispatch = true;
                            this._messageDispatch.push(message);
                            this._midDispatch = false;
                            if (transportAckRequired || applicationAckRequired) {
                                transportAckRequired, applicationAckRequired;
                                this._sendAcks(transportAckRequired);
                            } else this._setTransportAckTimer();
                            return true;
                        });
                    }
                    applicationAck(messageId, isAutoAcked = false) {
                        this.applicationSettle(messageId, MessageOutcome.ACCEPTED, isAutoAcked);
                    }
                    applicationSettle(messageId, messageOutcome = MessageOutcome.ACCEPTED, isAutoAcked = false) {
                        const {} = this.logger;
                        const idstr = messageId.toString();
                        switch (messageOutcome) {
                          case MessageOutcome.FAILED:
                            this._consumer.incStat(StatType.RX_SETTLE_FAILED);
                            break;

                          case MessageOutcome.REJECTED:
                            this._consumer.incStat(StatType.RX_SETTLE_REJECTED);
                            break;

                          case MessageOutcome.ACCEPTED:
                            if (!isAutoAcked) this._consumer.incStat(StatType.RX_SETTLE_ACCEPTED);
                            this._consumer.incStat(StatType.RX_ACKED);
                            break;
                        }
                        if (this._oldUnacked.delete(idstr)) {
                            const oldAckRanges = new Map();
                            oldAckRanges.set(messageOutcome, [ [ messageId, messageId ] ]);
                            this._sendAck(oldAckRanges);
                            return;
                        }
                        this._applicationAcks.updateAckState(messageId, ApplicationAckState.ACKED_NOT_SENT, messageOutcome);
                        if (messageOutcome !== MessageOutcome.ACCEPTED) this._sendAcks(true); else this._setTransportAckTimer();
                    }
                    getDestination() {
                        this._endpointEnsure();
                        return this._destination;
                    }
                    isDisconnected() {
                        if (!this.getCurrentState()) return true;
                        return this.getActiveState(ConsumerStateNames.UNBOUND) || this.getActiveState(ConsumerStateNames.UNBOUND_AWAITING_FLOWOPEN);
                    }
                    requestStartDispatchUser() {
                        this._userDispatch = true;
                        this.applyStartDispatch();
                    }
                    requestStartDispatchFSM() {
                        this._fsmDispatch = true;
                        this.applyStartDispatch();
                    }
                    applyStartDispatch() {
                        if (this._userDispatch && this._fsmDispatch) {
                            this.log(`Starting message dispatch (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                            this._messageDispatch.start();
                            this._localMaxWindowSize = this._localPreferredWindowSize;
                            this._sendAcks(true);
                        } else this.log(`Not starting message dispatch (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                    }
                    transitionToUnbound(eventName, error) {
                        const consumer = this._consumer;
                        const {} = this.logger;
                        consumer.userDisconnected;
                        this._clearPartitionGroupId();
                        return this.transitionTo(this.Unbound.AwaitFlowOpen, () => this._addEventToEmit(eventName, error));
                    }
                    transitionToUnboundFromUp(properties, eventName, error) {
                        const consumer = this._consumer;
                        const {} = this.logger;
                        if (error && error instanceof OperationError && error.subcode) if (error.subcode === ErrorSubcode.REPLAY_STARTED) {
                            this._transportAcks.reset();
                            this._applicationAcks.reset();
                        }
                        this._clearPartitionGroupId();
                        if (consumer.endpointErrorId && this._sessionInterface.isCapable(CapabilityType.MESSAGE_REPLAY)) {
                            consumer.endpointErrorId;
                            const unbindAck = SMFLib.AdProtocolMessage.getUnbindAck(consumer._flowId, consumer.endpointErrorId, this._transportAcks.lastAcked);
                            this._sessionInterface.sendControl(unbindAck);
                        }
                        if (-1 === properties.reconnectAttempts || properties.reconnectAttempts > 0) if (error && error instanceof OperationError && error.subcode) if (error.subcode === ErrorSubcode.REPLAY_STARTED || error.subcode === ErrorSubcode.GM_UNAVAILABLE) {
                            this._errorCausingReconnect = error;
                            return this.transitionTo(this.Reconnecting);
                        }
                        return this.transitionTo(this.Unbound.AwaitFlowOpen, () => this._addEventToEmit(eventName, error));
                    }
                    requestStopDispatchUser() {
                        this._userDispatch = false;
                        this.log(`Stop dispatch user (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                        this._messageDispatch.stop();
                    }
                    requestStopDispatchFSM() {
                        this._fsmDispatch = false;
                        this.log(`Stop dispatch FSM (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                        this._sendAcks(true);
                    }
                    _clearTransportAckTimer() {
                        if (!this._transportAckTimer) return;
                        clearTimeout(this._transportAckTimer);
                        this._transportAckTimer = null;
                    }
                    _dispose() {
                        this._clearTransportAckTimer();
                        this._endpointClear();
                        this._destination = void 0;
                        this._unacked = null;
                        this._messageDispatch = null;
                        this._transportAcks = null;
                        this._consumer = null;
                        this._sessionInterface = null;
                    }
                    _endpointClear() {
                        this._endpoint = void 0;
                        this._subscription = void 0;
                    }
                    _endpointEnsure() {
                        if (this._endpoint) return;
                        const sessionInterface = this._sessionInterface;
                        const properties = this._consumer._properties;
                        const queueDescriptor = properties.queueDescriptor;
                        let destination;
                        let endpoint;
                        let subscription;
                        if (queueDescriptor.type === QueueType.QUEUE) {
                            destination = sessionInterface.createDestinationFromDescriptor(queueDescriptor);
                            endpoint = new Queue({
                                name: destination.name,
                                type: DestinationType.QUEUE,
                                offset: 0,
                                bytes: destination.bytes.substr(destination.offset)
                            });
                            subscription = void 0;
                        } else {
                            endpoint = queueDescriptor.name ? sessionInterface.createDestinationFromDescriptor(queueDescriptor) : new Topic({
                                name: "\0?",
                                offset: 0,
                                bytes: "\0"
                            });
                            subscription = properties.topicEndpointSubscription || sessionInterface.createTemporaryDestination(DestinationType.TOPIC);
                            destination = subscription;
                        }
                        Object.assign(this, {
                            _destination: destination,
                            _endpoint: endpoint,
                            _subscription: subscription
                        });
                        properties.queueDescriptor = new QueueDescriptor({
                            name: endpoint.name,
                            type: queueDescriptor.type,
                            durable: queueDescriptor.durable
                        });
                    }
                    _resetLocalConnectionState() {
                        Object.assign(this, {
                            _remoteWindowSize: 0,
                            _active: void 0,
                            _fsmDispatch: false,
                            _userDispatch: true
                        });
                    }
                    _clearPartitionGroupId() {
                        const {} = this.logger;
                        this._consumer.partitionGroupId = void 0;
                    }
                    _resetRemoteConnectionState() {
                        const {} = this.logger;
                        this._transportAcks = new TransportAcks();
                        this._applicationAcks = new ApplicationAckRingBuffer(RING_BUFFER_SIZE);
                        this._oldUnacked = new Set();
                        this._consumer.endpointErrorId = void 0;
                        this._consumer.partitionGroupId = void 0;
                    }
                    _sendAck(applicationAcks) {
                        const transportAck = SMFLib.AdProtocolMessage.getAck(this._consumer.flowId, this._transportAcks.lastReceived, this.windowSize, applicationAcks);
                        this._sessionInterface.sendControl(transportAck);
                    }
                    _addAckToRanges(acksPendingState, applicationAck = null) {
                        const currentRange = acksPendingState.currentRange;
                        const ackRanges = acksPendingState.ackRanges;
                        const allMessageOutcomes = MessageOutcome.values;
                        const currentRangeLength = currentRange.length;
                        if (applicationAck && applicationAck.state !== ApplicationAckState.UNACKED) if (0 === currentRangeLength || currentRangeLength > 0 && currentRange[currentRangeLength - 1].settlementOutcome === applicationAck.settlementOutcome) {
                            currentRange.push(applicationAck);
                            return;
                        } else if (currentRangeLength > 0 && currentRange[currentRangeLength - 1].settlementOutcome !== applicationAck.settlementOutcome) {
                            const rangeOutcome = currentRange[currentRangeLength - 1].settlementOutcome;
                            ackRanges[rangeOutcome].push(currentRange);
                            acksPendingState.currentRange = [];
                            acksPendingState.currentRange.push(applicationAck);
                            return;
                        }
                        if (currentRangeLength) {
                            const rangeOutcome = currentRange[currentRangeLength - 1].settlementOutcome;
                            ackRanges[rangeOutcome].push(currentRange);
                        }
                        let totalRangeLen = 0;
                        for (let i = 0; i < allMessageOutcomes.length; i++) totalRangeLen += ackRanges[allMessageOutcomes[i]].length;
                        if (null === applicationAck || totalRangeLen === SMFLib.AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
                            const bareRanges = new Map();
                            let hasAnyBareRanges = false;
                            for (let i = 0; i < allMessageOutcomes.length; i++) if (ackRanges[allMessageOutcomes[i]].length > 0) {
                                bareRanges.set(allMessageOutcomes[i], ackRanges[allMessageOutcomes[i]].map(range => [ range[0].id, range[range.length - 1].id ]));
                                hasAnyBareRanges = true;
                            }
                            if (hasAnyBareRanges || acksPendingState.forceTransportAck) {
                                const {} = this.logger;
                                this._sendAck(bareRanges);
                                const failedBareRanges = bareRanges.get(MessageOutcome.FAILED);
                                const rejectedBareRanges = bareRanges.get(MessageOutcome.REJECTED);
                                this._transportAcks.lastReceived, bareRanges.has(MessageOutcome.ACCEPTED) && bareRanges.get(MessageOutcome.ACCEPTED).map(g => `[${g[0]}..${g[1]}]`), 
                                bareRanges.has(MessageOutcome.FAILED) && (failedBareRanges[0][0], 
                                failedBareRanges[0][1]), bareRanges.has(MessageOutcome.REJECTED) && (rejectedBareRanges[0][0], 
                                rejectedBareRanges[0][1]);
                                this._transportAcks.setAcked();
                                acksPendingState.forceTransportAck = false;
                            }
                            for (let i = 0; i < allMessageOutcomes.length; i++) ackRanges[allMessageOutcomes[i]].forEach(ackRange => {
                                ackRange.forEach(ack => {
                                    if (ack.state !== ApplicationAckState.ACKED_SENT) try {
                                        this._applicationAcks.updateAckState(ack.id, ApplicationAckState.ACKED_SENT);
                                    } catch (e) {
                                        const LOG_ERROR = this.logger.LOG_ERROR;
                                        LOG_ERROR(`Marking ack ${ack.id} as sent failed: ` + e);
                                    }
                                });
                            });
                            acksPendingState.ackRanges = [];
                            for (let i = 0; i < allMessageOutcomes.length; i++) acksPendingState.ackRanges[allMessageOutcomes[i]] = [];
                        }
                        acksPendingState.currentRange = [];
                    }
                    _sendAcks(forceTransportAck = false) {
                        this._clearTransportAckTimer();
                        const applicationAcks = this._applicationAcks;
                        const transportAcks = this._transportAcks;
                        const allMessageOutcomes = MessageOutcome.values;
                        const acksPendingState = {
                            forceTransportAck: forceTransportAck || transportAcks.acksPending > 0,
                            ackRanges: [],
                            currentRange: []
                        };
                        for (let i = 0; i < allMessageOutcomes.length; i++) acksPendingState.ackRanges[allMessageOutcomes[i]] = [];
                        const front = this._applicationAcks.front();
                        if (0 === this._oldUnacked.size && front && front.state !== ApplicationAckState.UNACKED) this._addAckToRanges(acksPendingState, ZERO_APP_ACK);
                        applicationAcks.forEach(ack => this._addAckToRanges(acksPendingState, ack));
                        this._addAckToRanges(acksPendingState);
                        assert(false === acksPendingState.forceTransportAck);
                        assert(0 === acksPendingState.currentRange.length);
                        for (let i = 0; i < allMessageOutcomes.length; i++) assert(0 === acksPendingState.ackRanges[allMessageOutcomes[i]].length);
                    }
                    _setTransportAckTimer() {
                        if (this._transportAckTimer) return;
                        if (this._consumer.disposed) return;
                        this._transportAckTimer = setTimeout(() => this._sendAcks(true), this._acknowledgeTimeoutInMsecs);
                    }
                    get maxWindowSize() {
                        return Math.min(this._localMaxWindowSize, this._remoteWindowSize || Number.POSITIVE_INFINITY);
                    }
                    get windowSize() {
                        return this.maxWindowSize - this._messageDispatch.length;
                    }
                    get maxPendingAcks() {
                        return this.windowSize * this._acknowledgeThreshold / 100;
                    }
                    get hasAutoAckSupport() {
                        return this._hasAutoAckSupport;
                    }
                }
                module.exports.ConsumerFSM = ConsumerFSM;
            },
            "./modules/solclient-message-consumer/lib/consumer-state-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const ConsumerStateNames = {
                    UNBOUND: "UNBOUND",
                    UNBOUND_AWAIT_SESSION_UP: "UNBOUND_AWAIT_SESSION_UP",
                    UNBOUND_AWAIT_FLOWOPEN: "UNBOUND_AWAIT_FLOWOPEN",
                    UNBOUND_AWAIT_ANY: "UNBOUND_AWAIT_ANY",
                    BIND_SENT: "BIND_SENT",
                    FLOW_UP: "FLOW_UP",
                    FLOW_UP_XFER: "FLOW_UP_XFER",
                    FLOW_UP_XFER_INACTIVE: "FLOW_UP_XFER_INACTIVE",
                    UNBIND_SENT: "UNBIND_SENT",
                    RECONNECTING: "RECONNECTING",
                    RECONNECTING_BIND_SENT: "RECONNECTING_BIND_SENT",
                    RECONNECTING_AWAIT_SESSION_UP: "RECONNECTING_AWAIT_SESSION_UP",
                    RECONNECTING_AWAIT_TIMER: "RECONNECTING_AWAIT_TIMER",
                    CREATE_SENT: "CREATE_SENT"
                };
                module.exports.ConsumerStateNames = Enum.new(ConsumerStateNames);
            },
            "./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessageConsumerAcknowledgeMode = {
                    AUTO: "AUTO",
                    CLIENT: "CLIENT"
                };
                module.exports.MessageConsumerAcknowledgeMode = Enum.new(MessageConsumerAcknowledgeMode);
            },
            "./modules/solclient-message-consumer/lib/message-consumer-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessageConsumerEventName = {
                    UP: "MessageConsumerEventName_up",
                    DOWN: "MessageConsumerEventName_down",
                    ACTIVE: "MessageConsumerEventName_active",
                    INACTIVE: "MessageConsumerEventName_inactive",
                    DOWN_ERROR: "MessageConsumerEventName_downError",
                    RECONNECTING: "MessageConsumerEventName_reconnecting",
                    RECONNECTED: "MessageConsumerEventName_reconnected",
                    CONNECT_FAILED_ERROR: "MessageConsumerEventName_connectFailedError",
                    GM_DISABLED: "MessageConsumerEventName_GMDisabled",
                    DISPOSED: "MessageConsumerEventName_disposed",
                    MESSAGE: "MessageConsumerEventName_message",
                    SUBSCRIPTION_OK: "MessageConsumerEventName_ok",
                    SUBSCRIPTION_ERROR: "MessageConsumerEventName_error"
                };
                module.exports.MessageConsumerEventName = Enum.new(MessageConsumerEventName);
            },
            "./modules/solclient-message-consumer/lib/message-consumer-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/api.js").ErrorSubcode;
                class MessageConsumerEvent {
                    constructor(messageConsumerEventName, infoStr, responseCode = void 0, errorSubcode = 0, correlationKey = void 0, reason = void 0) {
                        this._messageConsumerEventName = messageConsumerEventName;
                        this._infoStr = infoStr;
                        this._responseCode = responseCode;
                        this._errorSubcode = errorSubcode;
                        this._correlationKey = correlationKey;
                        this._reason = reason;
                    }
                    get messageConsumerEventName() {
                        return this._messageConsumerEventName;
                    }
                    get name() {
                        return this._messageConsumerEventName;
                    }
                    get infoStr() {
                        return this._infoStr;
                    }
                    get responseCode() {
                        return this._responseCode;
                    }
                    get errorSubcode() {
                        return this._errorSubcode;
                    }
                    get subcode() {
                        return this._errorSubcode;
                    }
                    get correlationKey() {
                        return this._correlationKey;
                    }
                    get reason() {
                        return this._reason;
                    }
                    set reason(value) {
                        this._reason = value;
                    }
                    get requestEventCode() {
                        return;
                    }
                    ["inspect"]() {
                        return {
                            messageConsumerEventName: this.messageConsumerEventName,
                            infoStr: this.infoStr,
                            responseCode: this.responseCode,
                            errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                            correlationKey: this.correlationKey ? this.correlationKey.toString() : null,
                            reason: this.reason ? this.reason : null
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.MessageConsumerEvent = MessageConsumerEvent;
            },
            "./modules/solclient-message-consumer/lib/message-consumer-properties-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    AbstractQueueDescriptor,
                    QueueDescriptor,
                    QueueDescriptorValidator,
                    QueueProperties,
                    QueuePropertiesValidator,
                    QueueType
                } = __webpack_require__("./modules/solclient-queue/api.js");
                const APIPropertiesValidators = __webpack_require__("./modules/solclient-util/api.js").APIPropertiesValidators;
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const MessageConsumerAcknowledgeMode = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js").MessageConsumerAcknowledgeMode;
                const {
                    OperationError,
                    ErrorSubcode
                } = __webpack_require__("./modules/solclient-error/api.js");
                const ReplayStartLocation = __webpack_require__("./modules/solclient-replaystart/api.js").ReplayStartLocation;
                const {
                    validateInstance,
                    valBoolean,
                    valInstance,
                    valIsMember,
                    valNumber,
                    valRange,
                    valTopicStringOrEmpty
                } = APIPropertiesValidators;
                function valTopicEndpointSubscription(typeDesc, instance) {
                    if (instance.queueDescriptor.getType() === QueueType.TOPIC_ENDPOINT) {
                        if (instance.queueDescriptor.isDurable() && !instance.createIfMissing) if (!instance.topicEndpointSubscription) throw new OperationError("topicEndpointSubscription must be set when queueDescriptor " + "refers to a durable topic endpoint and not allowed to create.", ErrorSubcode.PARAMETER_CONFLICT);
                    } else if (instance.topicEndpointSubscription) throw new OperationError("topicEndpointSubscription is set, but queueDescriptor " + "refers to a queue that is not of type QueueType.TOPIC_ENDPOINT", ErrorSubcode.PARAMETER_CONFLICT);
                }
                const MessageConsumerPropertiesValidator = {
                    validate(prefix, instance, rawProperties) {
                        if (Object.prototype.hasOwnProperty.call(rawProperties, "transportAcknowledgeTimeoutInMsecs") && Object.prototype.hasOwnProperty.call(rawProperties, "acknowledgeTimeoutInMsecs")) throw new OperationError(prefix + ` validation: transportAcknowledgeTimeoutInMsecs and acknowledgeTimeoutInMsecs are mutually exclusive`, ErrorSubcode.PARAMETER_CONFLICT);
                        if (Object.prototype.hasOwnProperty.call(rawProperties, "transportAcknowledgeThresholdPercentage") && Object.prototype.hasOwnProperty.call(rawProperties, "acknowledgeThreshold")) throw new OperationError(prefix + ` validation: transportAcknowledgeThresholdPercentage and acknowledgeThreshold are mutually exclusive`, ErrorSubcode.PARAMETER_CONFLICT);
                        const v = validateInstance.bind(null, prefix, instance);
                        if (!(instance.queueDescriptor instanceof AbstractQueueDescriptor || instance.queueDescriptor instanceof QueueDescriptor)) throw new OperationError(prefix + ` validation: queue descriptor must be ` + "an AbstractQueueDescriptor or a QueueDescriptor", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        QueueDescriptorValidator.validate(instance.queueDescriptor);
                        if (instance.queueProperties) {
                            if (instance.queueDescriptor.durable && !instance.createIfMissing) throw new OperationError(prefix + ` validation: queueProperties cannot be set unless ` + "queueDescriptor refers to a temporary queue, or createIfMissing is set.", ErrorSubcode.PARAMETER_CONFLICT);
                            v("queueProperties", [ valInstance, QueueProperties, "QueueProperties" ]);
                            QueuePropertiesValidator.validate(instance.queueProperties);
                            if (!instance.queueDescriptor.durable && Check.something(instance.queueProperties.accessType)) throw new OperationError(prefix + ` validation: queueProperties cannot specify accessType ` + "in creation of a temporary queue", ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        if (instance.queueDescriptor.type === QueueType.TOPIC_ENDPOINT) {
                            if (instance.queueDescriptor.durable && !instance.createIfMissing && !instance.topicEndpointSubscription) throw new OperationError(prefix + ` validation: topicEndpointSubscription must be set for durable ` + "topic endpoints unless creation is allowed.", ErrorSubcode.PARAMETER_CONFLICT);
                        } else if (instance.topicEndpointSubscription) throw new OperationError(prefix + ` validation: topicEndpointSubscription cannot be set unless ` + "descriptor.type is TOPIC_ENDPOINT", ErrorSubcode.PARAMETER_CONFLICT);
                        v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                        v("connectAttempts", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("topicEndpointSubscription", [ valTopicEndpointSubscription ], [ valTopicStringOrEmpty ]);
                        v("acknowledgeMode", [ valIsMember, MessageConsumerAcknowledgeMode, "MessageConsumerAcknowledgeMode" ]);
                        v("transportAcknowledgeTimeoutInMsecs", [ valNumber ], [ valRange, 20, 1500 ]);
                        v("transportAcknowledgeThresholdPercentage", [ valNumber ], [ valRange, 1, 75 ]);
                        v("activeIndicationEnabled", [ valBoolean ]);
                        v("noLocal", [ valBoolean ]);
                        v("windowSize", [ valNumber ], [ valRange, 1, 255 ]);
                        v("reconnectIntervalInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                        if (instance.replayStartLocation && !(instance.replayStartLocation instanceof ReplayStartLocation)) throw new OperationError(prefix + ` validation: replayStartLocation must be ` + "an instance of ReplayStartLocation", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                };
                module.exports.MessageConsumerPropertiesValidator = MessageConsumerPropertiesValidator;
            },
            "./modules/solclient-message-consumer/lib/message-consumer-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const QueueLib = __webpack_require__("./modules/solclient-queue/api.js");
                const APIProperties = __webpack_require__("./modules/solclient-util/api.js").APIProperties;
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const MessageConsumerAcknowledgeMode = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js").MessageConsumerAcknowledgeMode;
                const Topic = __webpack_require__("./modules/solclient-destination/api.js").Topic;
                const DEFAULTS = {
                    queueDescriptor: void 0,
                    queueProperties: void 0,
                    connectTimeoutInMsecs: 1e4,
                    connectAttempts: 3,
                    topicEndpointSubscription: void 0,
                    acknowledgeMode: MessageConsumerAcknowledgeMode.AUTO,
                    requiredSettlementOutcomes: [],
                    transportAcknowledgeTimeoutInMsecs: 1e3,
                    transportAcknowledgeThresholdPercentage: 60,
                    activeIndicationEnabled: false,
                    noLocal: false,
                    windowSize: 255,
                    _browser: false,
                    replayStartLocation: void 0,
                    reconnectAttempts: -1,
                    reconnectIntervalInMsecs: 3e3,
                    createIfMissing: false
                };
                class MessageConsumerProperties extends APIProperties {
                    constructor(options) {
                        super(DEFAULTS, options);
                    }
                    get queueDescriptor() {
                        return Check.something(this._queueDescriptor) ? this._queueDescriptor : DEFAULTS.queueDescriptor;
                    }
                    set queueDescriptor(value) {
                        if (value instanceof QueueLib.AbstractQueueDescriptor) this._queueDescriptor = value; else if (value) this._queueDescriptor = value.name ? new QueueLib.QueueDescriptor(value) : new QueueLib.AbstractQueueDescriptor(value); else this._queueDescriptor = value;
                    }
                    get queueProperties() {
                        return Check.something(this._queueProperties) ? this._queueProperties : DEFAULTS.queueProperties;
                    }
                    set queueProperties(value) {
                        if (value) this._queueProperties = new QueueLib.QueueProperties(value); else this._queueProperties = value;
                    }
                    get connectTimeoutInMsecs() {
                        return Check.something(this._bindTimeoutInMsecs) ? this._bindTimeoutInMsecs : DEFAULTS.connectTimeoutInMsecs;
                    }
                    set connectTimeoutInMsecs(value) {
                        this._bindTimeoutInMsecs = value;
                    }
                    get connectAttempts() {
                        return Check.something(this._connectAttempts) ? this._connectAttempts : DEFAULTS.connectAttempts;
                    }
                    set connectAttempts(val) {
                        this._connectAttempts = val;
                    }
                    get topicEndpointSubscription() {
                        return this._topicEndpointSubscription;
                    }
                    set topicEndpointSubscription(val) {
                        if ("string" === typeof val) this._topicEndpointSubscription = Topic.createFromName(val); else this._topicEndpointSubscription = val;
                    }
                    get acknowledgeMode() {
                        return Check.something(this._acknowledgeMode) ? this._acknowledgeMode : DEFAULTS.acknowledgeMode;
                    }
                    set acknowledgeMode(value) {
                        this._acknowledgeMode = value;
                    }
                    get requiredSettlementOutcomes() {
                        return Check.something(this._requiredSettlementOutcomes) && Check.array(this._requiredSettlementOutcomes) ? this._requiredSettlementOutcomes : DEFAULTS.requiredSettlementOutcomes;
                    }
                    set requiredSettlementOutcomes(value) {
                        this._requiredSettlementOutcomes = value;
                    }
                    get acknowledgeTimeoutInMsecs() {
                        return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                    }
                    set acknowledgeTimeoutInMsecs(val) {
                        this._transportAcknowledgeTimeoutInMsecs = val;
                    }
                    get acknowledgeThreshold() {
                        return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                    }
                    set acknowledgeThreshold(value) {
                        this._transportAcknowledgeThresholdPercentage = value;
                    }
                    get transportAcknowledgeTimeoutInMsecs() {
                        return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                    }
                    set transportAcknowledgeTimeoutInMsecs(val) {
                        this._transportAcknowledgeTimeoutInMsecs = val;
                    }
                    get transportAcknowledgeThresholdPercentage() {
                        return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                    }
                    set transportAcknowledgeThresholdPercentage(value) {
                        this._transportAcknowledgeThresholdPercentage = value;
                    }
                    get activeIndicationEnabled() {
                        return Check.something(this._activeIndicationEnabled) ? this._activeIndicationEnabled : DEFAULTS.activeIndicationEnabled;
                    }
                    set activeIndicationEnabled(newValue) {
                        this._activeIndicationEnabled = newValue;
                    }
                    get noLocal() {
                        return Check.something(this._noLocal) ? this._noLocal : DEFAULTS.noLocal;
                    }
                    set noLocal(newValue) {
                        this._noLocal = newValue;
                    }
                    get windowSize() {
                        return Check.something(this._windowSize) ? this._windowSize : DEFAULTS.windowSize;
                    }
                    set windowSize(val) {
                        this._windowSize = val;
                    }
                    get browser() {
                        return Check.something(this._browser) ? this._browser : DEFAULTS._browser;
                    }
                    set browser(newValue) {
                        this._browser = newValue;
                    }
                    get replayStartLocation() {
                        return Check.something(this._replayStartLocation) ? this._replayStartLocation : DEFAULTS.replayStartLocation;
                    }
                    set replayStartLocation(newValue) {
                        this._replayStartLocation = newValue;
                    }
                    get reconnectAttempts() {
                        return Check.something(this._reconnectAttempts) ? this._reconnectAttempts : DEFAULTS.reconnectAttempts;
                    }
                    set reconnectAttempts(newValue) {
                        this._reconnectAttempts = newValue;
                    }
                    get reconnectIntervalInMsecs() {
                        return Check.something(this._reconnectIntervalInMsecs) ? this._reconnectIntervalInMsecs : DEFAULTS.reconnectIntervalInMsecs;
                    }
                    set reconnectIntervalInMsecs(newValue) {
                        this._reconnectIntervalInMsecs = newValue;
                    }
                    get createIfMissing() {
                        return Check.something(this._createIfMissing) ? this._createIfMissing : DEFAULTS.createIfMissing;
                    }
                    set createIfMissing(newValue) {
                        this._createIfMissing = newValue;
                    }
                }
                module.exports.MessageConsumerProperties = MessageConsumerProperties;
            },
            "./modules/solclient-message-consumer/lib/message-consumer.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const CapabilityType = __webpack_require__("./modules/solclient-session/api.js").CapabilityType;
                const ConsumerFSM = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm.js").ConsumerFSM;
                const ConsumerFSMEvent = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event.js").ConsumerFSMEvent;
                const ConsumerFSMEventNames = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js").ConsumerFSMEventNames;
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const {
                    Flow,
                    FlowOperation
                } = __webpack_require__("./modules/solclient-flow/api.js");
                const MessageConsumerEvent = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event.js").MessageConsumerEvent;
                const MessageOutcome = __webpack_require__("./modules/solclient-message/api.js").MessageOutcome;
                const MessageConsumerEventName = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js").MessageConsumerEventName;
                const MessageConsumerProperties = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-properties.js").MessageConsumerProperties;
                const MessageConsumerPropertiesValidator = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-properties-validator.js").MessageConsumerPropertiesValidator;
                const {
                    Queue,
                    Topic
                } = __webpack_require__("./modules/solclient-destination/api.js");
                const {
                    QueueAccessType,
                    QueuePermissions,
                    QueueDiscardBehavior
                } = __webpack_require__("./modules/solclient-queue/api.js");
                function formatEventName(eventName) {
                    return `MessageConsumerEventName.` + MessageConsumerEventName.describe(eventName);
                }
                let localCounter = 0;
                function getConsumerLocalName() {
                    return `ConsumerFSM ` + localCounter++;
                }
                class MessageConsumer extends Flow {
                    constructor({
                        properties,
                        sessionInterfaceFactory
                    } = {}) {
                        const applyProperties = new MessageConsumerProperties(properties);
                        MessageConsumerPropertiesValidator.validate(applyProperties.browser ? "QueueBrowserProperties" : "MessageConsumerProperties", applyProperties, properties);
                        super(applyProperties, sessionInterfaceFactory, {
                            direct: MessageConsumerEventName.MESSAGE,
                            emits: MessageConsumerEventName.values,
                            formatEventName: formatEventName
                        });
                        const superFormatter = this.logger.formatter;
                        this.logger.formatter = (...args) => superFormatter("[message-consumer]", ...args);
                        this._active = void 0;
                        this._fsm = this._makeFSM();
                        this.endpointErrorId = void 0;
                        this.partitionGroupId = void 0;
                        this._on(MessageConsumerEventName.ACTIVE, () => this._onFlowActive(true));
                        this._on(MessageConsumerEventName.INACTIVE, () => this._onFlowActive(false));
                        this._on(MessageConsumerEventName.DOWN_ERROR, this._onFlowDisconnected.bind(this));
                        this._on(MessageConsumerEventName.UP, this._onFlowUp.bind(this));
                        this._fsm.start();
                    }
                    _makeFSM() {
                        const properties = this._properties;
                        const name = `` + getConsumerLocalName();
                        return new ConsumerFSM({
                            name: name,
                            consumer: this,
                            sessionInterface: this._sessionInterface,
                            properties: properties
                        });
                    }
                    start() {
                        this._operationCheck(FlowOperation.START);
                        this._fsm.requestStartDispatchUser();
                    }
                    stop() {
                        this._operationCheck(FlowOperation.STOP);
                        this._fsm.requestStopDispatchUser();
                    }
                    connect() {
                        if (null !== this._sessionInterface.getCapability(CapabilityType.GUARANTEED_MESSAGE_CONSUME) && !this._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME)) throw new OperationError("Consumer is not supported by router for this client", ErrorSubcode.INVALID_OPERATION, null);
                        super.connect();
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.FLOW_OPEN
                        }));
                    }
                    disconnect() {
                        super.disconnect();
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.FLOW_CLOSE
                        }));
                    }
                    getDestination() {
                        const destination = this._fsm.getDestination();
                        if (destination instanceof Queue) return new Queue(destination);
                        return new Topic(destination);
                    }
                    _disconnectSession() {
                        super._disconnectSession();
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.SESSION_DISCONNECT
                        }));
                    }
                    _operationCheck(operation) {
                        super._operationCheck(operation);
                        switch (operation) {
                          case FlowOperation.GET_DESTINATION:
                            if (this._isDisconnected()) throw new OperationError("Cannot get destination of a disconnected flow", ErrorSubcode.INVALID_OPERATION);
                            break;

                          default:
                        }
                    }
                    applicationAck(messageId, isAutoAcked = false) {
                        const {} = this.logger;
                        this._fsm.applicationAck(messageId, isAutoAcked);
                    }
                    applicationSettle(messageId, settlementOutcome) {
                        const {} = this.logger;
                        MessageOutcome.nameOf(settlementOutcome);
                        this._fsm.applicationSettle(messageId, settlementOutcome);
                    }
                    getDisposedEvent() {
                        return MessageConsumerEventName.DISPOSED;
                    }
                    handleDataMessage(message) {
                        const {} = this.logger;
                        message.setMessageConsumer(this);
                        this._fsm.acceptMessage(message);
                    }
                    handleUncorrelatedControlMessage(message) {
                        const LOG_INFO = this.logger.LOG_INFO;
                        LOG_INFO("Handling uncorrelated control message");
                        const msgType = message.msgType;
                        const SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
                        switch (msgType) {
                          case SMFAdProtocolMessageType.UNBIND:
                            {
                                const responseCode = message.smfHeader.pm_respcode;
                                const description = message.smfHeader.pm_respstr;
                                const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                message.getEndpointErrorId();
                                if (void 0 !== message.getEndpointErrorId()) this.endpointErrorId = message.getEndpointErrorId();
                                this.processFSMEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.FLOW_UNBOUND
                                }, new OperationError(description, errorSubcode, responseCode)));
                            }
                            break;

                          case SMFAdProtocolMessageType.FLOWCHANGEUPDATE:
                            this.processFSMEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.FLOW_ACTIVE_IND
                            }, {
                                active: message.getActiveFlow()
                            }));
                            break;

                          default:
                            SMFAdProtocolMessageType.describe(msgType);
                        }
                    }
                    getProperties() {
                        return super.getProperties();
                    }
                    onVRNChanged() {
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED
                        }));
                    }
                    get accessType() {
                        return this._accessType;
                    }
                    set accessType(value) {
                        this._accessType = value;
                    }
                    get active() {
                        return this._active;
                    }
                    set active(value) {
                        if (value !== this._active) this._emit(value ? MessageConsumerEventName.ACTIVE : MessageConsumerEventName.INACTIVE);
                        this._active = value;
                    }
                    get queueDiscardBehavior() {
                        return this._queueDiscardBehavior;
                    }
                    set queueDiscardBehavior(value) {
                        this._queueDiscardBehavior = value;
                    }
                    get respectsTTL() {
                        return this._respectsTTL;
                    }
                    set respectsTTL(value) {
                        this._respectsTTL = value;
                    }
                    get flowId() {
                        return this._flowId;
                    }
                    set flowId(value) {
                        this._flowId = value;
                    }
                    get permissions() {
                        return this._permissions || 0;
                    }
                    set permissions(value) {
                        this._permissions = value;
                    }
                    _onFlowActive(isActive) {
                        const {} = this.logger;
                        this._flowId;
                        this._active = isActive;
                    }
                    _onFlowDisconnected(error) {
                        const LOG_INFO = this.logger.LOG_INFO;
                        LOG_INFO(this + ` disconnected: ${error}.message`);
                    }
                    _disposeFSM() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        LOG_INFO("Disposing FSM");
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.DISPOSE
                        }));
                    }
                    _onFlowUp() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        LOG_INFO(`Flow is up: flowId = ` + this._flowId);
                    }
                    ["inspect"]() {
                        return Object.assign(super["inspect"](), {
                            destination: this._destination,
                            accessType: QueueAccessType.describe(this.accessType),
                            permissions: QueuePermissions.describe(this.permissions),
                            respectsTTL: this.respectsTTL,
                            active: this.wantFlowChangeNotify ? this.active : "(indications disabled)",
                            wantFlowChangeNotify: this.wantFlowChangeNotify,
                            queueDiscardBehavior: QueueDiscardBehavior.describe(this.queueDiscardBehavior),
                            maxWindowSize: this._fsm.maxWindowSize
                        });
                    }
                    toString() {
                        return util_inspect(this);
                    }
                    _isDisconnected() {
                        return this._fsm.isDisconnected();
                    }
                    addSubscription(topic, correlationKey, requestTimeout) {
                        const callback = (success, subCode, respCode, respText) => {
                            if (success) {
                                const event = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_OK, respText, respCode, subCode, correlationKey, `Topic: ` + topic.getName());
                                this._emit(MessageConsumerEventName.SUBSCRIPTION_OK, event);
                            } else {
                                const error = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_ERROR, respText, respCode, subCode, correlationKey, `Topic: ` + topic.getName());
                                this._emit(MessageConsumerEventName.SUBSCRIPTION_ERROR, error);
                            }
                        };
                        this._sessionInterface.updateQueueSubscription(topic, this._fsm.getDestination(), true, this, callback, requestTimeout);
                    }
                    removeSubscription(topic, correlationKey, requestTimeout) {
                        const callback = (success, subCode, respCode, respText) => {
                            if (success) {
                                const event = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_OK, respText, respCode, subCode, correlationKey, `Topic: ` + topic.getName());
                                this._emit(MessageConsumerEventName.SUBSCRIPTION_OK, event);
                            } else {
                                const error = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_ERROR, respText, respCode, subCode, correlationKey, `Topic: ` + topic.getName());
                                this._emit(MessageConsumerEventName.SUBSCRIPTION_ERROR, error);
                            }
                        };
                        this._sessionInterface.updateQueueSubscription(topic, this._fsm.getDestination(), false, this, callback, requestTimeout);
                    }
                }
                module.exports.MessageConsumer = MessageConsumer;
            },
            "./modules/solclient-message-consumer/lib/message-dispatcher.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageConsumerEventName = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js").MessageConsumerEventName;
                function formatEventName(x) {
                    return `MessageConsumerEventName.` + MessageConsumerEventName.describe(x);
                }
                class MessageDispatcher {
                    constructor({
                        emitter,
                        autoAck,
                        logger
                    } = {}) {
                        Object.assign(this, {
                            emitter: emitter,
                            queue: [],
                            dispatch: true,
                            formatEventName: formatEventName,
                            logger: logger
                        });
                        this._dispatchOne = autoAck ? this._dispatchOneAutoAck : this._dispatchOneBare;
                        this.emitter.setOnFirstDirectListener(this._onFirstMessageListener.bind(this));
                        this._availableListener = true;
                    }
                    start() {
                        this.dispatch = true;
                        this._flush();
                    }
                    stop() {
                        this.dispatch = false;
                    }
                    get length() {
                        return this.queue.length;
                    }
                    push(message) {
                        const {} = this.logger;
                        this.queue.push(message);
                        if (this.dispatch) this._flush(); else message.getGuaranteedMessageId();
                    }
                    _onFirstMessageListener() {
                        const {} = this.logger;
                        if (!this._availableListener) {
                            this.queue.length;
                            this.dispatch;
                            this._availableListener = true;
                        }
                        this._flush();
                    }
                    _flush() {
                        const {} = this.logger;
                        while (this.queue.length && this.dispatch && this.emitter.directListenerCount() > 0) this._dispatchOne(this.queue.shift());
                        if (this.queue.length && this.dispatch && 0 === this.emitter.directListenerCount() && this._availableListener) this._availableListener = false;
                    }
                    _dispatchOneAutoAck(message) {
                        const LOG_WARN = this.logger.LOG_WARN;
                        let caught = null;
                        caught = this._dispatchOneBare(message);
                        if (caught) LOG_WARN(`Suppressing message acknowledgement for message ${message.getGuaranteedMessageId()} because client threw exception from listener`, caught); else {
                            if (message.isAcknowledged) {
                                LOG_WARN(`Consumer configured to auto-acknowledge messages, but message ${message.getGuaranteedMessageId()} was application acknowledged`);
                                return;
                            }
                            message._autoAcknowledge();
                        }
                    }
                    _dispatchOneBare(message) {
                        const LOG_WARN = this.logger.LOG_WARN;
                        let caught;
                        if (0 === this.listenerCount) LOG_WARN(`No listeners to dispatch message ` + message.getGuaranteedMessageId());
                        try {
                            this.emitter.emitDirect(message);
                        } catch (ex) {
                            caught = this.emitter.formatErrorEvent(ex, MessageConsumerEventName.MESSAGE, message);
                            this.emitter.emit("error", caught);
                        }
                        return caught;
                    }
                }
                module.exports = {
                    MessageDispatcher: MessageDispatcher
                };
            },
            "./modules/solclient-message-consumer/lib/queue-browser-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const QueueBrowserEventName = {
                    UP: "QueueBrowserEventName_up",
                    DOWN: "QueueBrowserEventName_down",
                    DOWN_ERROR: "QueueBrowserEventName_downError",
                    CONNECT_FAILED_ERROR: "QueueBrowserEventName_connectFailedError",
                    GM_DISABLED: "QueueBrowserEventName_GMDisabled",
                    DISPOSED: "QueueBrowserEventName_disposed",
                    MESSAGE: "QueueBrowserEventName_message"
                };
                module.exports.QueueBrowserEventName = Enum.new(QueueBrowserEventName);
            },
            "./modules/solclient-message-consumer/lib/queue-browser-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const QueueLib = __webpack_require__("./modules/solclient-queue/api.js");
                const APIProperties = __webpack_require__("./modules/solclient-util/api.js").APIProperties;
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const DEFAULTS = {
                    queueDescriptor: void 0,
                    connectTimeoutInMsecs: 1e4,
                    connectAttempts: 3,
                    windowSize: 255,
                    transportAcknowledgeTimeoutInMsecs: 1e3,
                    transportAcknowledgeThresholdPercentage: 60
                };
                class QueueBrowserProperties extends APIProperties {
                    constructor(options) {
                        super(DEFAULTS, options);
                    }
                    get queueDescriptor() {
                        return Check.something(this._queueDescriptor) ? this._queueDescriptor : DEFAULTS.queueDescriptor;
                    }
                    set queueDescriptor(value) {
                        if (value) this._queueDescriptor = new QueueLib.QueueDescriptor(value); else this._queueDescriptor = value;
                    }
                    get connectTimeoutInMsecs() {
                        return Check.something(this._bindTimeoutInMsecs) ? this._bindTimeoutInMsecs : DEFAULTS.connectTimeoutInMsecs;
                    }
                    set connectTimeoutInMsecs(value) {
                        this._bindTimeoutInMsecs = value;
                    }
                    get connectAttempts() {
                        return Check.something(this._connectAttempts) ? this._connectAttempts : DEFAULTS.connectAttempts;
                    }
                    set connectAttempts(val) {
                        this._connectAttempts = val;
                    }
                    get windowSize() {
                        return Check.something(this._windowSize) ? this._windowSize : DEFAULTS.windowSize;
                    }
                    set windowSize(val) {
                        this._windowSize = val;
                    }
                    get transportAcknowledgeTimeoutInMsecs() {
                        return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                    }
                    set transportAcknowledgeTimeoutInMsecs(val) {
                        this._transportAcknowledgeTimeoutInMsecs = val;
                    }
                    get transportAcknowledgeThresholdPercentage() {
                        return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                    }
                    set transportAcknowledgeThresholdPercentage(value) {
                        this._transportAcknowledgeThresholdPercentage = value;
                    }
                }
                module.exports.QueueBrowserProperties = QueueBrowserProperties;
            },
            "./modules/solclient-message-consumer/lib/queue-browser.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const EventEmitter = __webpack_require__("./modules/solclient-events/api.js").EventEmitter;
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const MessageConsumerEventName = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js").MessageConsumerEventName;
                const QueueBrowserEventName = __webpack_require__("./modules/solclient-message-consumer/lib/queue-browser-event-names.js").QueueBrowserEventName;
                function formatEventName(eventName) {
                    return `QueueBrowserEventName.` + QueueBrowserEventName.describe(eventName);
                }
                class QueueBrowser extends EventEmitter {
                    constructor(messageConsumer) {
                        super({
                            direct: QueueBrowserEventName.MESSAGE,
                            emits: QueueBrowserEventName.values,
                            formatEventName: formatEventName
                        });
                        this._messageConsumer = messageConsumer;
                        this.logger = new LogFormatter((...args) => [ "[queue-browser]", ...args ]);
                        this._setupEventListers();
                    }
                    _setupEventListers() {
                        this._messageConsumer.on(MessageConsumerEventName.UP, this._onConsumerUp.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.CONNECT_FAILED_ERROR, this._onConsumerConnectFailed.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.DOWN, this._onConsumerDown.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.DOWN_ERROR, this._onConsumerDownError.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.MESSAGE, this._onConsumerMessage.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.DISPOSED, this._onConsumerDisposed.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.GM_DISABLED, this._onConsumerGMDisabled.bind(this));
                    }
                    _onConsumerMessage(event) {
                        this.emit(QueueBrowserEventName.MESSAGE, event);
                    }
                    _onConsumerUp(event) {
                        this.emit(QueueBrowserEventName.UP, event);
                    }
                    _onConsumerConnectFailed(event) {
                        this.emit(QueueBrowserEventName.CONNECT_FAILED_ERROR, event);
                    }
                    _onConsumerDown(event) {
                        this.emit(QueueBrowserEventName.DOWN, event);
                    }
                    _onConsumerDownError(event) {
                        this.emit(QueueBrowserEventName.DOWN_ERROR, event);
                    }
                    _onConsumerDisposed(event) {
                        this.emit(QueueBrowserEventName.DISPOSED, event);
                    }
                    _onConsumerGMDisabled(event) {
                        this.emit(QueueBrowserEventName.GM_DISABLED, event);
                    }
                    connect() {
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        try {
                            this._messageConsumer.connect();
                        } catch (error) {
                            LOG_ERROR(error.toString());
                            throw error;
                        }
                    }
                    disconnect() {
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        try {
                            this._messageConsumer.disconnect();
                        } catch (error) {
                            LOG_ERROR(error.toString());
                            throw error;
                        }
                    }
                    start() {
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        try {
                            this._messageConsumer.start();
                        } catch (error) {
                            LOG_ERROR(error.toString());
                            throw error;
                        }
                    }
                    stop() {
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        try {
                            this._messageConsumer.stop();
                        } catch (error) {
                            LOG_ERROR(error.toString());
                            throw error;
                        }
                    }
                    removeMessageFromQueue(message) {
                        this._messageConsumer.applicationAck(message._guaranteedMsgId);
                        message._acked = true;
                    }
                }
                module.exports.QueueBrowser = QueueBrowser;
            },
            "./modules/solclient-message-consumer/lib/transport-acks.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const Long = __webpack_require__("./modules/solclient-convert/api.js").Long;
                const TransportAckResult = Enum.new({
                    OK: 0,
                    DUPLICATE: 1,
                    OUT_OF_ORDER: 2
                });
                class TransportAcks {
                    constructor(id = 0) {
                        const base = "number" === typeof id ? Long.fromNumber(id, true) : Long.fromValue(id);
                        this.lastAcked = base;
                        this._acksPending = 0;
                    }
                    reset() {
                        this._acksPending = 0;
                        this.lastAcked = Long.ZERO;
                    }
                    tryReceive(messageID, prevMessageID) {
                        if (this._lastReceived.lt(prevMessageID)) {
                            this._lastReceived;
                            return TransportAckResult.OUT_OF_ORDER;
                        }
                        if (this._lastReceived.gte(messageID)) {
                            this._lastReceived;
                            this._acksPending++;
                            return TransportAckResult.DUPLICATE;
                        }
                        this._lastReceived = messageID;
                        this._acksPending++;
                        return TransportAckResult.OK;
                    }
                    setAcked() {
                        this._lastAcked = Long.fromValue(this._lastReceived);
                        this._acksPending = 0;
                    }
                    get acksPending() {
                        return this._acksPending;
                    }
                    get lastAcked() {
                        return this._lastAcked;
                    }
                    set lastAcked(value) {
                        value.toString();
                        Object.assign(this, {
                            _lastAcked: Long.fromValue(value),
                            _lastReceived: Long.fromValue(value)
                        });
                    }
                    get lastReceived() {
                        return this._lastReceived;
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports = {
                    TransportAcks: TransportAcks,
                    TransportAckResult: TransportAckResult
                };
            },
            "./modules/solclient-message-publisher/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const MessagePublisher = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher.js").MessagePublisher;
                const MessagePublisherAcknowledgeMode = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js").MessagePublisherAcknowledgeMode;
                const MessagePublisherEventName = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-event-names.js").MessagePublisherEventName;
                const MessagePublisherProperties = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-properties.js").MessagePublisherProperties;
                const MessagePublisherPropertiesValidator = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-properties-validator.js").MessagePublisherPropertiesValidator;
                const PublisherFSMEvent = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event.js").PublisherFSMEvent;
                const PublisherFSMEventNames = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js").PublisherFSMEventNames;
                module.exports.MessagePublisherAcknowledgeMode = MessagePublisherAcknowledgeMode;
                module.exports.MessagePublisher = MessagePublisher;
                module.exports.MessagePublisherProperties = MessagePublisherProperties;
                module.exports.PublisherFSMEvent = PublisherFSMEvent;
                module.exports.PublisherFSMEventNames = PublisherFSMEventNames;
                module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;
                module.exports.MessagePublisherEventName = MessagePublisherEventName;
            },
            "./modules/solclient-message-publisher/lib/message-ids.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const Long = __webpack_require__("./modules/solclient-convert/api.js").Long;
                const DEFAULTS = {
                    _lastAcked: Long.fromNumber(0, true),
                    _lastSent: Long.fromNumber(0, true),
                    _next: Long.fromNumber(1, true)
                };
                const longToString = v => v.toString(10);
                class MessageIds {
                    constructor(attrs) {
                        Object.assign(this, DEFAULTS, attrs);
                    }
                    get lastAcked() {
                        return this._lastAcked;
                    }
                    set lastAcked(value) {
                        this._lastAcked = Long.fromValue(value);
                    }
                    get lastSent() {
                        return this._lastSent;
                    }
                    setLastSent(id) {
                        this._lastSent = Long.fromValue(id);
                        this._next = this._lastSent.add(1);
                    }
                    get next() {
                        return this._next;
                    }
                    ["inspect"]() {
                        return {
                            lastAcked: longToString(this.lastAcked),
                            lastSent: longToString(this.lastSent),
                            next: longToString(this.next)
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.MessageIds = MessageIds;
            },
            "./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessagePublisherAcknowledgeMode = {
                    PER_MESSAGE: "PER_MESSAGE",
                    WINDOWED: "WINDOWED"
                };
                module.exports.MessagePublisherAcknowledgeMode = Enum.new(MessagePublisherAcknowledgeMode);
            },
            "./modules/solclient-message-publisher/lib/message-publisher-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessagePublisherEventName = Enum.new({
                    ACKNOWLEDGED_MESSAGE: "MessagePublisherEventName_acknowledgedMessage",
                    CONNECT_FAILED_ERROR: "MessagePublisherEventName_connectFailedError",
                    CAN_SEND: "MessagePublisherEventName_canSend",
                    DISPOSED: "MessagePublisherEventName_disposed",
                    DOWN: "MessagePublisherEventName_down",
                    FLOW_NAME_CHANGED: "MessagePublisherEventName_flowNameChanged",
                    GUARANTEED_MESSAGING_DOWN: "MessagePublisherEventName_guaranteedMessagingDown",
                    REJECTED_MESSAGE: "MessagePublisherEventName_rejectedMessage",
                    DISCONNECT_FAILED_ERROR: "MessagePublisherEventName_disconnectFailedError",
                    UP: "MessagePublisherEventName_up",
                    TRANSPORT_FULL: "MessagePublisherEventName_transportFull"
                });
                module.exports.MessagePublisherEventName = MessagePublisherEventName;
            },
            "./modules/solclient-message-publisher/lib/message-publisher-properties-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const APIPropertiesValidators = __webpack_require__("./modules/solclient-util/api.js").APIPropertiesValidators;
                const MessagePublisherAcknowledgeMode = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js").MessagePublisherAcknowledgeMode;
                const {
                    validateInstance,
                    valBoolean,
                    valIsMember,
                    valNumber,
                    valRange
                } = APIPropertiesValidators;
                const MessagePublisherPropertiesValidator = {
                    validate(instance) {
                        const v = validateInstance.bind(null, "MessagePublisherProperties", instance);
                        v("enabled", [ valBoolean ]);
                        v("windowSize", [ valNumber ], [ valRange, 1, 255 ]);
                        v("acknowledgeTimeoutInMsecs", [ valNumber ], [ valRange, 20, 6e4 ]);
                        v("acknowledgeMode", [ valIsMember, MessagePublisherAcknowledgeMode, "MessagePublisherAcknowledgeMode" ]);
                        v("connectRetryCount", [ valNumber ], [ valRange, 0, Number.MAX_VALUE ]);
                        v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                    }
                };
                module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;
            },
            "./modules/solclient-message-publisher/lib/message-publisher-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
                const APIProperties = __webpack_require__("./modules/solclient-util/api.js").APIProperties;
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const MessagePublisherAcknowledgeMode = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js").MessagePublisherAcknowledgeMode;
                const TransportCapabilities = __webpack_require__("./modules/solclient-transport/api.js").TransportCapabilities;
                function defaultEnablePublisher() {
                    const ProfileBinding = SolclientFactoryLib.ProfileBinding;
                    const binding = ProfileBinding.value;
                    const globallyEnabled = binding.guaranteedMessagingEnabled;
                    const webSocketAvailable = TransportCapabilities.web.webSocket();
                    return globallyEnabled && webSocketAvailable;
                }
                function getDefaults() {
                    return {
                        enabled: defaultEnablePublisher(),
                        windowSize: 50,
                        acknowledgeTimeoutInMsecs: 2e3,
                        acknowledgeMode: MessagePublisherAcknowledgeMode.PER_MESSAGE,
                        connectRetryCount: 3,
                        connectTimeoutInMsecs: 5e3
                    };
                }
                class MessagePublisherProperties extends APIProperties {
                    constructor(options) {
                        super(getDefaults(), options || {});
                    }
                    get enabled() {
                        return this._enabled;
                    }
                    set enabled(newValue) {
                        this._enabled = newValue;
                    }
                    get windowSize() {
                        return Check.defined(this._windowSize) ? this._windowSize : getDefaults().windowSize;
                    }
                    set windowSize(newValue) {
                        this._windowSize = newValue;
                    }
                    get acknowledgeTimeoutInMsecs() {
                        return Check.defined(this._acknowledgeTimeoutInMsecs) ? this._acknowledgeTimeoutInMsecs : getDefaults().acknowledgeTimeoutInMsecs;
                    }
                    set acknowledgeTimeoutInMsecs(newValue) {
                        this._acknowledgeTimeoutInMsecs = newValue;
                    }
                    get acknowledgeMode() {
                        return this._acknowledgeMode || MessagePublisherAcknowledgeMode.PER_MESSAGE;
                    }
                    set acknowledgeMode(newValue) {
                        this._acknowledgeMode = newValue;
                    }
                    get connectRetryCount() {
                        return Check.defined(this._connectRetryCount) ? this._connectRetryCount : getDefaults().connectRetryCount;
                    }
                    set connectRetryCount(newValue) {
                        this._connectRetryCount = newValue;
                    }
                    get connectTimeoutInMsecs() {
                        return Check.defined(this._connectTimeoutInMsecs) ? this._connectTimeoutInMsecs : getDefaults().connectTimeoutInMsecs;
                    }
                    set connectTimeoutInMsecs(newValue) {
                        this._connectTimeoutInMsecs = newValue;
                    }
                    ["inspect"]() {
                        return {
                            enabled: this.enabled,
                            windowSize: this.windowSize,
                            acknowledgeTimeoutInMsecs: this.acknowledgeTimeoutInMsecs,
                            acknowledgeMode: MessagePublisherAcknowledgeMode.describe(this.acknowledgeMode),
                            connectRetryCount: this.connectRetryCount,
                            connectTimeoutInMsecs: this.connectTimeoutInMsecs
                        };
                    }
                }
                module.exports.MessagePublisherProperties = MessagePublisherProperties;
            },
            "./modules/solclient-message-publisher/lib/message-publisher.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const {
                    Flow,
                    PrivateFlowEventName
                } = __webpack_require__("./modules/solclient-flow/api.js");
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const MessagePublisherEventName = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-event-names.js").MessagePublisherEventName;
                const MessagePublisherProperties = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-properties.js").MessagePublisherProperties;
                const PublisherFSM = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm.js").PublisherFSM;
                const PublisherFSMEvent = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event.js").PublisherFSMEvent;
                const PublisherFSMEventNames = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js").PublisherFSMEventNames;
                const LOG_WARN = new LogFormatter().LOG_WARN;
                class MessagePublisher extends Flow {
                    constructor({
                        properties,
                        sessionInterfaceFactory
                    } = {}) {
                        const applyProperties = new MessagePublisherProperties(properties);
                        super(applyProperties, sessionInterfaceFactory, {
                            direct: MessagePublisherEventName.ACKNOWLEDGED_MESSAGE,
                            emits: MessagePublisherEventName.values
                        });
                        this._fsm = this._makeFSM();
                        const logger = new LogFormatter();
                        logger.formatter = function(...args) {
                            return [ "[message-publisher]", ...args ];
                        };
                        this.log = logger.wrap(this.log, this);
                        this._bindWaiting = true;
                        this.on(PrivateFlowEventName.BIND_WAITING, this._onBindWaiting.bind(this));
                        this.on(MessagePublisherEventName.CONNECT_FAILED_ERROR, this._onBindFailed.bind(this));
                        this.on(MessagePublisherEventName.DOWN, this._onDown.bind(this));
                        this.on(MessagePublisherEventName.UP, this._onUp.bind(this));
                    }
                    _onBindFailed() {
                        this._bindWaiting = false;
                    }
                    _onBindWaiting() {
                        this._bindWaiting = true;
                    }
                    _onDown() {
                        this._bindWaiting = false;
                    }
                    _onUp() {
                        this._bindWaiting = false;
                    }
                    _makeFSM() {
                        return new PublisherFSM({
                            publisher: this,
                            name: "PublisherFSM",
                            sessionInterface: this._sessionInterface,
                            properties: this._properties
                        });
                    }
                    get flowId() {
                        return this._flowId;
                    }
                    set flowId(value) {
                        this._flowId = value;
                    }
                    get name() {
                        return this._flowName;
                    }
                    set name(value) {
                        this._flowName = value;
                    }
                    get publisherId() {
                        return this._publisherId;
                    }
                    set publisherId(value) {
                        this._publisherId = value;
                    }
                    get properties() {
                        return this._properties.clone();
                    }
                    connect() {
                        super.connect();
                        if (!this._fsm.getCurrentState()) this._fsm.start();
                    }
                    _disconnectSession() {
                        super._disconnectSession();
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.FLOW_CLOSE
                        }));
                    }
                    getDisposedEvent() {
                        return MessagePublisherEventName.DISPOSED;
                    }
                    handleAck(id) {
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.ACK
                        }, {
                            ack: id
                        }));
                    }
                    handleNack(id, ctrlMessage) {
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.ACK
                        }, {
                            nack: id,
                            ctrlMessage: ctrlMessage
                        }));
                    }
                    handleUncorrelatedControlMessage(message) {
                        const msgType = message.msgType;
                        const SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
                        switch (msgType) {
                          case SMFAdProtocolMessageType.CLIENTACK:
                            {
                                const id = message.getLastMsgIdAcked();
                                if (message.smfHeader.pm_respcode > 299) this.handleNack(id, message); else this.handleAck(id);
                                break;
                            }

                          case SMFAdProtocolMessageType.CLIENTNACK:
                            {
                                const id = message.getLastMsgIdAcked();
                                this.handleNack(id, message);
                                break;
                            }

                          case SMFAdProtocolMessageType.CLOSEPUBFLOW:
                            this.processFSMEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.FLOW_UNBOUND
                            }));
                            break;

                          default:
                            LOG_WARN(`Dropping unhandled AD control message for ` + this, SMFAdProtocolMessageType.describe(msgType));
                        }
                    }
                    prepareAdMessageAndSend(dataMsg) {
                        return this._fsm.prepareAdMessageAndSend(dataMsg);
                    }
                    isBindWaiting() {
                        return this._bindWaiting;
                    }
                    ["inspect"]() {
                        return Object.assign(super["inspect"](), {
                            name: this.name,
                            publisherId: this.publisherId
                        });
                    }
                    toString() {
                        return util_inspect(this);
                    }
                    _disposeFSM() {
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.DISPOSE
                        }));
                    }
                    _isDisconnected() {
                        return this._fsm.isDisconnected();
                    }
                }
                module.exports.MessagePublisher = MessagePublisher;
            },
            "./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const PublisherFSMEventNames = {
                    SESSION_UP: "PublisherSessionUp",
                    SESSION_UP_NO_AD: "PublisherSessionUpNoAD",
                    SESSION_DOWN: "PublisherSessionDown",
                    FLOW_FAILED: "MessagePublisherFailed",
                    FLOW_UP: "MessagePublisherUp",
                    FLOW_CLOSE: "MessagePublisherClose",
                    FLOW_UNBOUND: "MessagePublisherUnbound",
                    TRANSPORT_FULL: "PublisherTransportFull",
                    ACK: "PublisherAck",
                    ACK_TIMEOUT: "PublisherAckTimeout",
                    BIND_TIMEOUT: "PublisherBindTimeout",
                    UNBIND_TIMEOUT: "PublisherUnbindTimeout",
                    CAN_SEND: "PublisherCanSend",
                    TRANSPORT_ERROR: "PublisherTransportError",
                    RESEND_COMPLETE: "PublisherResendComplete",
                    DISPOSE: "PublisherDispose"
                };
                module.exports.PublisherFSMEventNames = Enum.new(PublisherFSMEventNames);
            },
            "./modules/solclient-message-publisher/lib/publisher-fsm-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const FsmEvent = __webpack_require__("./modules/solclient-fsm/api.js").FsmEvent;
                class PublisherFSMEvent extends FsmEvent {
                    constructor(spec, details, smfmessage) {
                        super(spec);
                        Object.assign(this, details);
                        Object.assign(this, smfmessage);
                    }
                    getEventText() {
                        return this._eventText;
                    }
                }
                module.exports.PublisherFSMEvent = PublisherFSMEvent;
            },
            "./modules/solclient-message-publisher/lib/publisher-fsm.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const SolclientSession = __webpack_require__("./modules/solclient-session/api.js");
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const Long = __webpack_require__("./modules/solclient-convert/api.js").Long;
                const MessageIds = __webpack_require__("./modules/solclient-message-publisher/lib/message-ids.js").MessageIds;
                const MessagePublisherAcknowledgeMode = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js").MessagePublisherAcknowledgeMode;
                const MessagePublisherEventName = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-event-names.js").MessagePublisherEventName;
                const PrivateFlowEventName = __webpack_require__("./modules/solclient-flow/api.js").PrivateFlowEventName;
                const PublisherFSMEvent = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event.js").PublisherFSMEvent;
                const PublisherFSMEventNames = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js").PublisherFSMEventNames;
                const PublisherStateNames = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-state-names.js").PublisherStateNames;
                const {
                    State,
                    StateMachine
                } = __webpack_require__("./modules/solclient-fsm/api.js");
                const StatType = __webpack_require__("./modules/solclient-stats/api.js").StatType;
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/api.js").TransportReturnCode;
                const ConnectReason = {
                    INIT: 0,
                    RESUME: 1,
                    FAILOVER: 2
                };
                class PublisherFSM extends StateMachine {
                    constructor({
                        publisher,
                        name,
                        sessionInterface,
                        properties
                    } = {}) {
                        super({
                            name: name
                        });
                        const fsm = this;
                        const currentState = () => {
                            const state = fsm.getCurrentState();
                            return state ? state.getName() : "<not running>";
                        };
                        this.logger = new LogFormatter((...args) => [ `[session=${sessionInterface.sessionIdHex}]`, `[message-publisher-fsm=${publisher.flowIdDec}]`, `[${currentState()}]`, ...args ]);
                        this.log = this.logger.wrap(this.log, this);
                        const {
                            LOG_INFO,
                            LOG_WARN
                        } = this.logger;
                        Object.assign(this, {
                            _publisher: publisher,
                            _acknowledgeMode: properties.acknowledgeMode,
                            _acknowledgeTimeoutInMsecs: properties.acknowledgeTimeoutInMsecs,
                            _sessionInterface: sessionInterface,
                            _windowSize: properties.windowSize,
                            _stateEvents: []
                        });
                        this._guaranteedEnabled = properties.enabled;
                        this._sendWindow = properties.windowSize;
                        this._resetConnectedInfo();
                        this._notifiedWindowClosed = false;
                        this._transportFlowControlled = true;
                        this.initial(function() {
                            return this.transitionTo(fsm.PublisherUnbound, context => {
                                context.getStateMachine().getName();
                            });
                        });
                        fsm.unhandledEventReaction(function(event) {
                            switch (event.getName()) {
                              case PublisherFSMEventNames.FLOW_UNBOUND:
                                this._guaranteedEnabled = false;
                                this._publisher.emit(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN);
                                return this.transitionTo(fsm.PublisherUnbound, context => {
                                    context.getStateMachine().getName();
                                });

                              case PublisherFSMEventNames.DISPOSE:
                                break;

                              case PublisherFSMEventNames.TRANSPORT_FULL:
                                break;

                              case PublisherFSMEventNames.CAN_SEND:
                                break;

                              default:
                                event.getName();
                            }
                            return this;
                        });
                        fsm.PublisherUnbound = new State({
                            name: PublisherStateNames.UNBOUND,
                            parentContext: fsm
                        }, {
                            emitDownAndBindWaiting() {
                                publisher.emit(MessagePublisherEventName.DOWN);
                                publisher.emit(PrivateFlowEventName.BIND_WAITING);
                            }
                        }).entry(function() {
                            this.emitDownAndBindWaiting();
                            fsm._connectRetryCount = properties.connectRetryCount;
                        }).reaction(PublisherFSMEventNames.FLOW_UNBOUND, function() {
                            return this.internalTransition();
                        }).reaction(PublisherFSMEventNames.SESSION_UP, function() {
                            return this.transitionTo(fsm.PublisherOpenFlowSent);
                        });
                        fsm.PublisherOpenFlowSent = new State({
                            name: PublisherStateNames.OPENFLOWSENT,
                            parentContext: fsm
                        }, {
                            emitOpenFlowFailedError(details) {
                                publisher.emit(MessagePublisherEventName.CONNECT_FAILED_ERROR, details);
                            },
                            handleOpenFlowResponse(adpMsg) {
                                const smfRespHeader = adpMsg.smfHeader;
                                const respCode = smfRespHeader.pm_respcode;
                                if (adpMsg.msgType !== SMFLib.SMFAdProtocolMessageType.OPENPUBFLOW) return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    returnCode: respCode,
                                    description: `Unexpected response: ` + SMFLib.SMFAdProtocolMessageType.describe(adpMsg.msgType)
                                }));
                                if (null === respCode) {
                                    publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                    sessionInterface.sessionIdHex;
                                    return null;
                                }
                                if (200 !== respCode) {
                                    const respStr = smfRespHeader.pm_respstr;
                                    const mappedSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respStr);
                                    return fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.FLOW_FAILED
                                    }, {
                                        subcode: mappedSubcode,
                                        returnCode: respCode,
                                        description: respStr
                                    }));
                                }
                                const lastMsgIDAcked = adpMsg.getLastMsgIdAcked();
                                const window = adpMsg.getWindow();
                                const flowId = adpMsg.getFlowId();
                                const flowName = adpMsg.getFlowName();
                                const publisherId = adpMsg.getPublisherId();
                                lastMsgIDAcked, window, flowId, flowName, publisherId;
                                fsm._messageIds;
                                if (void 0 === window) return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    description: "Window parameter not found"
                                }));
                                if (window > this._windowSize) return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    description: "Invalid window negotiation"
                                }));
                                fsm._sendWindow = window - fsm._unackedList.length;
                                if (fsm._sendWindow < 0) fsm._sendWindow = 0;
                                Object.assign(fsm._publisher, {
                                    name: flowName,
                                    flowId: flowId,
                                    publisherId: publisherId
                                });
                                fsm._guaranteedEnabled = true;
                                if (fsm._connectReason === ConnectReason.INIT || fsm._connectReason === ConnectReason.FAILOVER) {
                                    fsm._messageIds.setLastSent(lastMsgIDAcked);
                                    fsm._messageIds, lastMsgIDAcked, fsm._connectReason;
                                    if (fsm._connectReason === ConnectReason.FAILOVER) publisher.emit(MessagePublisherEventName.FLOW_NAME_CHANGED, {
                                        messages: [ ...fsm._unackedList ],
                                        count: fsm._unackedList.length
                                    });
                                    fsm._connectReason = ConnectReason.RESUME;
                                    fsm._unackedList.forEach(message => {
                                        const oldId = message.getGuaranteedMessageId();
                                        fsm._renumber(message);
                                        oldId, message.getGuaranteedMessageId();
                                        fsm._messageIds.setLastSent(message.getGuaranteedMessageId());
                                    });
                                } else fsm._unackedList.forEach(message => {
                                    message.setFlowId(flowId);
                                    message.setPublisherId(publisher.publisherId);
                                    flowId, message.getGuaranteedMessageId();
                                });
                                const payloadSizeLimit = fsm._sessionInterface.getCapability(SolclientSession.CapabilityType.MAX_GUARANTEED_MSG_SIZE).getValue();
                                fsm._unackedList.forEach(message => {
                                    if (payloadSizeLimit < message._memoized_payload.length) LOG_WARN(`Message size ${message._memoized_payload.length} above broker limit ` + payloadSizeLimit);
                                });
                                if (fsm._unackedList.length) {
                                    fsm._handleAck(lastMsgIDAcked, false, adpMsg, true);
                                    fsm._firstUnackedToSend = fsm._unackedList[0];
                                } else fsm._messageIds.lastAcked = Long.fromValue(lastMsgIDAcked);
                                fsm._messageIds;
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_UP
                                }));
                            },
                            handleOpenFlowTimeout() {
                                LOG_INFO("Open publisher connection timeout");
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.BIND_TIMEOUT
                                }));
                            },
                            handleUnknownFlowName() {
                                LOG_INFO("Flow name unknown, republish required");
                                fsm._resetConnectedInfo(true);
                                return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
                            },
                            sendOpenFlow() {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                correlationTag;
                                const openPubFlowMsg = SMFLib.AdProtocolMessage.getOpenMessagePublisher(fsm._messageIds.lastAcked, fsm._messageIds.lastSent, properties.windowSize, fsm._publisher._flowName, correlationTag);
                                fsm._messageIds.lastAcked, fsm._messageIds.lastSent, 
                                properties.windowSize, fsm._publisher._flowName;
                                sessionInterface.sendControl(openPubFlowMsg);
                                sessionInterface.enqueueRequest(correlationTag, () => this.handleOpenFlowTimeout(), properties.connectTimeoutInMsecs, null, rxMsgObj => this.handleOpenFlowResponse(rxMsgObj));
                            }
                        }).entry(function() {
                            try {
                                this.sendOpenFlow();
                            } catch (e) {
                                LOG_WARN(`Exception during bind attempt: ` + e);
                                fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.SESSION_DOWN
                                }));
                            }
                        }).reaction(PublisherFSMEventNames.FLOW_CLOSE, function() {
                            return this.transitionTo(fsm.PublisherCloseFlowSent);
                        }).reaction(PublisherFSMEventNames.FLOW_UP, function() {
                            return this.transitionTo(fsm.PublisherUp);
                        }).reaction(PublisherFSMEventNames.SESSION_DOWN, function() {
                            return this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.BIND_TIMEOUT, function() {
                            if (fsm._connectRetryCount > 0) {
                                fsm._connectRetryCount--;
                                return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
                            }
                            this.emitOpenFlowFailedError({
                                subcode: ErrorSubcode.TIMEOUT,
                                description: "Open publisher connection failed due to timeout"
                            });
                            return this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.FLOW_FAILED, function(pEvent) {
                            const {
                                subcode,
                                returnCode,
                                description
                            } = pEvent;
                            subcode, returnCode, description;
                            switch (pEvent.subcode) {
                              case ErrorSubcode.UNKNOWN_FLOW_NAME:
                                return this.handleUnknownFlowName();

                              default:
                                this.emitOpenFlowFailedError({
                                    event: pEvent,
                                    subcode: subcode,
                                    returnCode: returnCode,
                                    description: description
                                });
                                fsm._resetConnectedInfo();
                            }
                            return this.transitionTo(fsm.PublisherUnbound);
                        });
                        fsm.PublisherCloseFlowSent = new State({
                            name: PublisherStateNames.CLOSEFLOWSENT,
                            parentContext: fsm
                        }, {
                            handleCloseFlowResponse(response) {
                                const smfRespHeader = response.smfHeader;
                                const respCode = smfRespHeader.pm_respcode;
                                if (response.msgType !== SMFLib.SMFAdProtocolMessageType.CLOSEPUBFLOW) return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    returnCode: respCode,
                                    description: `Unexpected response: ` + SMFLib.SMFAdProtocolMessageType.describe(response.msgType)
                                }));
                                if (null === respCode) {
                                    publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                    sessionInterface.sessionIdHex;
                                    return null;
                                }
                                if (200 !== respCode) fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    returnCode: respCode,
                                    description: smfRespHeader.pm_respstr
                                }));
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_UNBOUND
                                }));
                            },
                            handleCloseFlowTimeout() {
                                LOG_INFO("Close publisher connection timeout.");
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.UNBIND_TIMEOUT
                                }));
                            },
                            sendCloseFlow() {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                const closePubFlowMsg = SMFLib.AdProtocolMessage.getCloseMessagePublisher(fsm._publisher.flowId, correlationTag);
                                sessionInterface.sendControl(closePubFlowMsg);
                                sessionInterface.enqueueRequest(correlationTag, () => this.handleCloseFlowTimeout(), properties.connectTimeoutInMsecs, null, rxMsgObj => this.handleCloseFlowResponse(rxMsgObj));
                            }
                        }).entry(function() {
                            this.sendCloseFlow();
                            return this;
                        }).reaction(PublisherFSMEventNames.ACK, function(event) {
                            fsm._handleAckEvent(event);
                            return this.internalTransition();
                        }).reaction(PublisherFSMEventNames.FLOW_UNBOUND, function() {
                            return this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.FLOW_FAILED, function() {
                            this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.UNBIND_TIMEOUT, function() {
                            return this.transitionTo(fsm.PublisherCloseFlowSent);
                        });
                        fsm.PublisherUp = new State({
                            name: PublisherStateNames.UP,
                            parentContext: fsm
                        }, {
                            emitFlowUp() {
                                publisher.emit(MessagePublisherEventName.UP);
                            }
                        }).initial(function() {
                            return this.transitionTo(fsm._unackedList.length ? fsm.PublisherRetransmitting : fsm.PublisherDataXfer);
                        }).entry(function() {
                            fsm._scheduleStateEvents(fsm.PublisherUp, () => this.emitFlowUp());
                            return this;
                        }).reaction(PublisherFSMEventNames.ACK, function(event) {
                            fsm._handleAckEvent(event);
                            return this.internalTransition();
                        }).reaction(PublisherFSMEventNames.ACK_TIMEOUT, function() {
                            fsm._firstUnackedToSend = fsm._unackedList[0];
                            return this.transitionTo(fsm.PublisherRetransmitting);
                        }).reaction(PublisherFSMEventNames.FLOW_CLOSE, function() {
                            return this.transitionTo(fsm.PublisherCloseFlowSent);
                        }).reaction(PublisherFSMEventNames.SESSION_DOWN, function() {
                            return this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function() {
                            return this.internalTransition();
                        });
                        fsm.PublisherDataXfer = new State({
                            name: PublisherStateNames.DATA_XFER,
                            parentContext: fsm.PublisherUp
                        }).entry(() => {
                            fsm._transportFlowControlled = false;
                            fsm._scheduleStateEvents(fsm.PublisherDataXfer, () => fsm._maybeEmitCanSend());
                        }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function() {
                            return this.transitionTo(fsm.PublisherFlowControlled);
                        }).exit(() => {
                            fsm._transportFlowControlled = true;
                        });
                        fsm.PublisherFlowControlled = new State({
                            name: PublisherStateNames.FLOW_CONTROLLED,
                            parentContext: fsm.PublisherUp
                        }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function() {
                            LOG_INFO("Attempt to send while flow controlled");
                            return this.internalTransition();
                        }).reaction(PublisherFSMEventNames.CAN_SEND, function() {
                            return this.transitionTo(fsm.PublisherRetransmitting);
                        });
                        fsm.PublisherRetransmitting = new State({
                            name: PublisherStateNames.RETRANSMITTING,
                            parentContext: fsm.PublisherUp
                        }, {
                            retransmit() {
                                try {
                                    fsm._resendFromUnacked();
                                } catch (ex) {
                                    if (ex instanceof OperationError && ex.subcode === ErrorSubcode.INSUFFICIENT_SPACE) fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.TRANSPORT_FULL
                                    })); else {
                                        LOG_INFO(`Publisher resendFromUnacked failed: ` + ex);
                                        fsm.processEvent(new PublisherFSMEvent({
                                            name: PublisherFSMEventNames.FLOW_FAILED
                                        }));
                                    }
                                }
                            }
                        }).entry(function() {
                            this.retransmit();
                        }).reaction(PublisherFSMEventNames.RESEND_COMPLETE, function() {
                            return this.transitionTo(fsm.PublisherDataXfer);
                        }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function() {
                            fsm._unackedList.length;
                            return this.transitionTo(fsm.PublisherFlowControlled);
                        });
                    }
                    isDisconnected() {
                        if (!this.getCurrentState()) return true;
                        return !!this.getActiveState(PublisherStateNames.UNBOUND);
                    }
                    prepareAdMessageAndSend(dataMsg) {
                        if (!this._guaranteedEnabled) throw new OperationError("Session does not provide Guaranteed Message Publish capability", ErrorSubcode.GM_UNAVAILABLE, "close flow received from message-router");
                        if (this._sendWindow <= 0) {
                            this._publisher.incStat(StatType.TX_WINDOW_CLOSED);
                            this._notifiedWindowClosed = true;
                            throw new OperationError("Guaranteed Message Window Closed", ErrorSubcode.INSUFFICIENT_SPACE);
                        }
                        const unackedList = this._unackedList;
                        const LOG_INFO = this.logger.LOG_INFO;
                        if (dataMsg._payload_is_memoized) {
                            dataMsg._payload_is_memoized = false;
                            dataMsg._memoized_csumm = void 0;
                            dataMsg._memoized_payload = void 0;
                        }
                        const dupMsg = dataMsg.clone();
                        const payloadSize = SMFLib.Codec.Encode.adaptMessageToSmf_payloadMemoize(dupMsg);
                        var payloadSizeLimit = 0;
                        try {
                            payloadSizeLimit = this._sessionInterface.getCapability(SolclientSession.CapabilityType.MAX_GUARANTEED_MSG_SIZE).getValue();
                        } catch (e) {
                            LOG_INFO("Can't pre-check payload size, broker not connected yet?");
                            e.stack;
                        }
                        if (0 < payloadSizeLimit && payloadSize > payloadSizeLimit) throw new OperationError(`Encoded payload size (${payloadSize}) exceeds broker size limit (MAX_GUARANTEED_MSG_SIZE, ${payloadSizeLimit})`, ErrorSubcode.MESSAGE_TOO_LARGE);
                        --this._sendWindow;
                        this._renumber(dupMsg);
                        this._cloneNumbers(dupMsg, dataMsg);
                        unackedList.push(dupMsg);
                        const msgId = dupMsg.getGuaranteedMessageId();
                        this._messageIds.setLastSent(msgId);
                        msgId, unackedList.length, this._sendWindow;
                        if (this._transportFlowControlled) {
                            if (void 0 === this._firstUnackedToSend) this._firstUnackedToSend = dupMsg;
                            return TransportReturnCode.OK;
                        }
                        let returnCode;
                        try {
                            returnCode = this._sessionInterface.sendToTransport(dupMsg);
                            if (returnCode !== TransportReturnCode.OK) if (returnCode === TransportReturnCode.NO_SPACE) {
                                returnCode = TransportReturnCode.OK;
                                this._firstUnackedToSend = dupMsg;
                                this.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.TRANSPORT_FULL
                                }));
                            } else returnCode; else dupMsg.setRedelivered(true);
                            this._startAckTimer();
                        } catch (ex) {
                            if (ex instanceof OperationError) {
                                ErrorSubcode.describe(ex.subcode), ex.message;
                                unackedList.pop();
                                this._messageIds.setLastSent(dupMsg.getGuaranteedPreviousMessageId());
                                ++this._sendWindow;
                                throw ex;
                            } else {
                                ex.message;
                                throw ex;
                            }
                        }
                        return TransportReturnCode.OK;
                    }
                    _handleAckEvent(event) {
                        this._publisher.incStat(StatType.TX_ACKS_RXED);
                        this._handleAck(event.ack || event.nack, !!event.nack, event.ctrlMessage);
                    }
                    _handleAck(id, nack, ctrlMessage = void 0, openFlow = false) {
                        const {
                            _messageIds: messageIds,
                            _unackedList: unackedList
                        } = this;
                        const LOG_INFO = this.logger.LOG_INFO;
                        if (messageIds.lastAcked.gte(id)) {
                            if (openFlow) this._messageIds; else LOG_INFO(`Dropping ack: remote ack for ${id}, local ids ` + this._messageIds);
                            return;
                        }
                        const reportAcked = [];
                        while (unackedList.length && id.gte(unackedList[0].getGuaranteedMessageId())) reportAcked.push(unackedList.shift());
                        if (-1 === unackedList.indexOf(this._firstUnackedToSend)) this._firstUnackedToSend = unackedList[0];
                        this._sendWindow += reportAcked.length;
                        this._sendWindow;
                        messageIds.lastAcked = id;
                        const reportNacked = nack ? reportAcked.pop() : null;
                        const numAcked = reportAcked.length;
                        if (numAcked) if (this._acknowledgeMode === MessagePublisherAcknowledgeMode.PER_MESSAGE) {
                            numAcked, unackedList.length;
                            for (let i = 0; i < numAcked; ++i) this._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, reportAcked[i]);
                        } else {
                            const lastAckedMessage = reportAcked[numAcked - 1];
                            lastAckedMessage.getGuaranteedMessageId();
                            this._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, lastAckedMessage);
                        }
                        if (reportNacked) {
                            reportNacked.getGuaranteedMessageId();
                            this._publisher.emit(MessagePublisherEventName.REJECTED_MESSAGE, reportNacked, ctrlMessage);
                        }
                        unackedList.length;
                        if (unackedList.length) this._resetAckTimer(); else this._clearAckTimer();
                        this._maybeEmitCanSend();
                    }
                    _maybeEmitCanSend() {
                        const {} = this.logger;
                        if (!this._notifiedWindowClosed) return;
                        if (0 === this._sendWindow) return;
                        this._notifiedWindowClosed = false;
                        this._publisher.emit(MessagePublisherEventName.CAN_SEND);
                    }
                    _resendFromUnacked() {
                        const {
                            LOG_ERROR,
                            LOG_INFO
                        } = this.logger;
                        const list = this._unackedList;
                        let resendIndex = list.indexOf(this._firstUnackedToSend);
                        if (-1 === resendIndex) {
                            if (this._firstUnackedToSend) LOG_ERROR(`Could not find first Unacked Messages in unacked message list: msgId = ` + this._firstUnackedToSend.getGuaranteedMessageId);
                            if (0 === list.length) {
                                this._messageIds.toString();
                                this.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.RESEND_COMPLETE
                                }));
                            }
                            return;
                        }
                        resendIndex, list.length, list.map(m => m.getGuaranteedMessageId().toString());
                        while (resendIndex < list.length) {
                            if (list[resendIndex].getPublisherId() !== this._publisher.publisherId) LOG_ERROR(`Resending on invalid publisherId '${list[resendIndex].getPublisherId()}'when it should be '${this._publisher.publisherId}'`);
                            const returnCode = this._sessionInterface.sendData(list[resendIndex]);
                            if (returnCode === TransportReturnCode.NO_SPACE) {
                                this._firstUnackedToSend = list[resendIndex];
                                LOG_INFO("Publisher sendMessage blocked due to insufficient space, wait for CAN_SEND");
                                this.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.TRANSPORT_FULL
                                }));
                                return;
                            }
                            if (returnCode !== TransportReturnCode.OK) return;
                            list[resendIndex].setRedelivered(true);
                            resendIndex++;
                            this._startAckTimer();
                        }
                        this._messageIds.toString();
                        this.processEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.RESEND_COMPLETE
                        }));
                    }
                    _resetConnectedInfo(failover = false) {
                        const {} = this.logger;
                        if (this._ackTimer) this._clearAckTimer();
                        Object.assign(this, {
                            _messageIds: new MessageIds()
                        });
                        Object.assign(this._publisher, {
                            publisherId: void 0,
                            flowId: void 0,
                            flowName: null
                        });
                        if (failover) this._connectReason = ConnectReason.FAILOVER; else {
                            this._unackedList = [];
                            this._connectReason = ConnectReason.INIT;
                        }
                    }
                    _clearAckTimer() {
                        const {} = this.logger;
                        this._ackTimer && this._ackTimer;
                        if (!this._ackTimer) return;
                        clearTimeout(this._ackTimer);
                        this._ackTimer = null;
                    }
                    _emitStateEvents() {
                        const {} = this.logger;
                        while (this._stateEvents.length) {
                            const pair = this._stateEvents.shift();
                            const state = pair[0];
                            const event = pair[1];
                            if (this.getActiveState(state.getName())) event.apply(state);
                        }
                    }
                    _handleAckTimeout() {
                        const {} = this.logger;
                        this._ackTimer = null;
                        this._publisher.incStat(StatType.TX_ACK_TIMEOUT);
                        this.processEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.ACK_TIMEOUT
                        }));
                    }
                    _renumber(message) {
                        const messageIds = this._messageIds;
                        const current = messageIds.next;
                        message.setGuaranteedPreviousMessageId(messageIds.lastSent);
                        message.setGuaranteedMessageId(current);
                        const publisher = this._publisher;
                        message.setFlowId(publisher.flowId);
                        message.setPublisherId(publisher.publisherId);
                    }
                    _cloneNumbers(fromMsg, toMsg) {
                        toMsg.setGuaranteedPreviousMessageId(fromMsg.getGuaranteedPreviousMessageId());
                        toMsg.setGuaranteedMessageId(fromMsg.getGuaranteedMessageId());
                        toMsg.setFlowId(fromMsg.getFlowId());
                        toMsg.setPublisherId(fromMsg.getPublisherId());
                    }
                    _resetAckTimer() {
                        this._clearAckTimer();
                        this._startAckTimer();
                    }
                    _scheduleStateEvents(state, event) {
                        this._stateEvents.push([ state, event ]);
                        this._setPostEventAction(() => this._emitStateEvents(), "Emit state events");
                    }
                    _setPostEventAction(action, desc = "No action") {
                        const LOG_WARN = this.logger.LOG_WARN;
                        if (this._postEventAction && this._postEventAction.desc === desc) return;
                        if (this._postEventAction && this._postEventAction.desc) LOG_WARN(`Replacing post event action ${this._postEventAction.desc} with ` + desc);
                        this._postEventAction = {
                            action: action || (() => {}),
                            desc: desc
                        };
                        this.setPostEventAction(() => {
                            this._postEventAction.action();
                            this._postEventAction = null;
                        });
                    }
                    _startAckTimer() {
                        if (this._ackTimer) return;
                        this._ackTimer = setTimeout(() => this._handleAckTimeout(), this._acknowledgeTimeoutInMsecs);
                    }
                }
                module.exports.PublisherFSM = PublisherFSM;
            },
            "./modules/solclient-message-publisher/lib/publisher-state-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const PublisherStateNames = {
                    UNBOUND: "PublisherUnbound",
                    OPENFLOWSENT: "PublisherOpenFlowSent",
                    UP: "PublisherUp",
                    FAILED: "PublisherFailed",
                    CLOSEFLOWSENT: "PublisherCloseFlowSent",
                    DATA_XFER: "PublisherDataXfer",
                    FLOW_CONTROLLED: "MessagePublisherFlowControlled",
                    RETRANSMITTING: "PublisherRetransmitting"
                };
                module.exports.PublisherStateNames = Enum.new(PublisherStateNames);
            },
            "./modules/solclient-message-tracing/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Baggage = __webpack_require__("./modules/solclient-message-tracing/lib/baggage.js").Baggage;
                const TraceContext = __webpack_require__("./modules/solclient-message-tracing/lib/message-trace-context.js").TraceContext;
                const TraceContextSetter = __webpack_require__("./modules/solclient-message-tracing/lib/message-trace-context-setter.js").TraceContextSetter;
                const MessageTracingSupport = __webpack_require__("./modules/solclient-message-tracing/lib/message-tracing-support.js").MessageTracingSupport;
                module.exports.Baggage = Baggage;
                module.exports.TraceContext = TraceContext;
                module.exports.TraceContextSetter = TraceContextSetter;
                module.exports.MessageTracingSupport = MessageTracingSupport;
            },
            "./modules/solclient-message-tracing/lib/baggage.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    isStringOrNothing
                } = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                class Baggage {
                    getBaggage() {
                        return this._baggage || null;
                    }
                    setBaggage(value) {
                        this._setBaggage(isStringOrNothing("baggage", value));
                    }
                    _setBaggage(value) {
                        this._baggage = value;
                    }
                }
                module.exports.Baggage = Baggage;
            },
            "./modules/solclient-message-tracing/lib/message-trace-context-setter.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Parameter = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const BufferImpl = __webpack_require__("./node_modules/buffer/index.js").Buffer;
                const {
                    isNumber,
                    isBoolean,
                    isString,
                    isStringOrNothing
                } = Parameter;
                const uint8ArrayToString = Convert.uint8ArrayToString;
                class TraceContextSetter {
                    constructor() {
                        this._traceId = null;
                        this._spanId = null;
                        this._isSampled = false;
                        this._traceState = null;
                        this._version = 1;
                    }
                    clone() {
                        const _clonedContextSetter = new TraceContextSetter();
                        _clonedContextSetter._setSpanId(this._spanId);
                        _clonedContextSetter._setTraceId(this._traceId);
                        _clonedContextSetter._setSampled(this._isSampled);
                        _clonedContextSetter._setTraceState(this._traceState);
                        _clonedContextSetter._setVersion(this._version);
                        return _clonedContextSetter;
                    }
                    static get TRACE_ID_BYTES_LENGTH() {
                        return 16;
                    }
                    static get SPAN_ID_BYTES_LENGTH() {
                        return 8;
                    }
                    get version() {
                        return this._version || 1;
                    }
                    setVersion(value) {
                        this._setVersion(isNumber("version", value));
                    }
                    _setVersion(value) {
                        this._version = value;
                    }
                    get traceId() {
                        return this._traceId;
                    }
                    setTraceId(value) {
                        this._setTraceId(isString("traceId", value));
                    }
                    _setTraceId(value) {
                        this._traceId = value;
                    }
                    get spanId() {
                        return this._spanId;
                    }
                    setSpanId(value) {
                        this._setSpanId(isString("spanId", value));
                    }
                    _setSpanId(value) {
                        this._spanId = value;
                    }
                    get isSampled() {
                        return this._isSampled || false;
                    }
                    setSampled(value) {
                        this._setSampled(isBoolean("isSampled", value));
                    }
                    _setSampled(value) {
                        this._isSampled = value;
                    }
                    get traceState() {
                        return this._traceState;
                    }
                    setTraceState(value) {
                        this._setTraceState(isStringOrNothing("traceState", value));
                    }
                    _setTraceState(value) {
                        this._traceState = value;
                    }
                    static fromTraceContext(traceContextValue) {
                        if (null == traceContextValue) return null;
                        let traceContextBuffer = null;
                        if (BufferImpl.isBuffer(traceContextValue)) traceContextBuffer = traceContextValue; else if ("string" === typeof traceContextValue) traceContextBuffer = BufferImpl.from(traceContextValue, "latin1");
                        if (!traceContextBuffer || traceContextBuffer.length < 32) return null;
                        try {
                            const traceContextBytes = new Uint8Array(traceContextBuffer).buffer;
                            let bytesRead = 0;
                            const traceContextSetter = new TraceContextSetter();
                            const firstByte = traceContextBytes.slice(bytesRead, bytesRead + 1);
                            const byte1DataView = new DataView(firstByte, 0, 1);
                            let byte1 = byte1DataView.getUint8(bytesRead);
                            const version = byte1 >> 4;
                            traceContextSetter.setVersion(version);
                            const isSampled = 4 == (15 & byte1);
                            traceContextSetter.setSampled(isSampled);
                            bytesRead++;
                            const traceId16Bytes = traceContextBytes.slice(bytesRead, bytesRead + 16);
                            const traceId = uint8ArrayToString(traceId16Bytes, "hex");
                            traceContextSetter.setTraceId(traceId);
                            bytesRead += TraceContextSetter.TRACE_ID_BYTES_LENGTH;
                            const spanId8Bytes = traceContextBytes.slice(bytesRead, bytesRead + 8);
                            const spanId = uint8ArrayToString(spanId8Bytes, "hex");
                            traceContextSetter.setSpanId(spanId);
                            bytesRead += TraceContextSetter.SPAN_ID_BYTES_LENGTH;
                            bytesRead++;
                            bytesRead += 4;
                            const traceStateLengthBytes = traceContextBytes.slice(bytesRead, bytesRead + 2);
                            const traceStateLengthDataView = new DataView(traceStateLengthBytes, 0, traceStateLengthBytes.byteLength);
                            const traceStateLength = traceStateLengthDataView.getUint16(0, false);
                            bytesRead += 2;
                            if (traceStateLength > 0) {
                                const traceStateBytes = traceContextBytes.slice(bytesRead, bytesRead + traceStateLength);
                                const traceState = uint8ArrayToString(traceStateBytes);
                                traceContextSetter.setTraceState(traceState);
                            }
                            return traceContextSetter;
                        } catch (ex) {
                            return null;
                        }
                    }
                }
                module.exports.TraceContextSetter = TraceContextSetter;
            },
            "./modules/solclient-message-tracing/lib/message-trace-context.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Parameter = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const TraceContextSetter = __webpack_require__("./modules/solclient-message-tracing/lib/message-trace-context-setter.js").TraceContextSetter;
                const {
                    isBoolean,
                    isStringOrNothing
                } = Parameter;
                const {
                    stringToUint8Array,
                    hexStringToUint8Array
                } = Convert;
                class TraceContext {
                    constructor(traceContextSetter) {
                        this._traceId = isStringOrNothing("traceId", traceContextSetter.traceId);
                        this._spanId = isStringOrNothing("spanId", traceContextSetter.spanId);
                        this._isSampled = isBoolean("isSampled", traceContextSetter.isSampled);
                        this._traceState = traceContextSetter.traceState;
                        this._version = traceContextSetter.version;
                    }
                    static clone(toClone) {
                        const newContextSetter = new TraceContextSetter();
                        newContextSetter._setSpanId(toClone.getSpanId());
                        newContextSetter._setTraceId(toClone.getTraceId());
                        newContextSetter._setSampled(toClone.getIsSampled());
                        newContextSetter._setTraceState(toClone.getTraceState());
                        newContextSetter._setVersion(toClone.getVersion());
                        return new TraceContext(newContextSetter);
                    }
                    get version() {
                        return this._version || 1;
                    }
                    getVersion() {
                        return this.version;
                    }
                    get MAX_TRACE_STATE_LENGTH() {
                        return 512;
                    }
                    get traceId() {
                        return this._traceId;
                    }
                    getTraceId() {
                        return this._traceId;
                    }
                    get spanId() {
                        return this._spanId;
                    }
                    getSpanId() {
                        return this._spanId;
                    }
                    get isSampled() {
                        return this._isSampled;
                    }
                    getIsSampled() {
                        return this._isSampled || false;
                    }
                    get traceState() {
                        return this._traceState;
                    }
                    getTraceState() {
                        return this._traceState || null;
                    }
                    getTruncatedTraceState() {
                        return this._standardTraceStateTruncation(this.MAX_TRACE_STATE_LENGTH);
                    }
                    getEncodedTraceContext() {
                        if (null == this.traceId || null == this.spanId) return null;
                        const traceStateLength = null == this.traceState ? 0 : this.traceState.length;
                        const contentBuffer = new ArrayBuffer(32 + traceStateLength);
                        let offsetPos = 0;
                        const contentBufferDataView = new DataView(contentBuffer);
                        let byte1 = 0;
                        byte1 |= this.version << 4;
                        byte1 |= this.isSampled ? 4 : 0;
                        contentBufferDataView.setUint8(offsetPos, byte1, false);
                        offsetPos++;
                        const traceId16byte = hexStringToUint8Array(this.traceId);
                        for (let i = 0; i < 16; i++) contentBufferDataView.setUint8(offsetPos + i, traceId16byte[i], false);
                        offsetPos += 16;
                        const spanId8byte = hexStringToUint8Array(this.spanId);
                        for (let i = 0; i < 8; i++) contentBufferDataView.setUint8(offsetPos + i, spanId8byte[i], false);
                        offsetPos += 8;
                        contentBufferDataView.setUint8(offsetPos, 1, false);
                        offsetPos++;
                        contentBufferDataView.setUint16(offsetPos, 0, false);
                        contentBufferDataView.setUint16(offsetPos + 2, 0, false);
                        offsetPos += 4;
                        if (null == this.traceState) {
                            contentBufferDataView.setUint16(offsetPos, 0, false);
                            offsetPos += 2;
                        } else {
                            const truncatedTraceState = this.getTruncatedTraceState();
                            if (null != truncatedTraceState) {
                                const traceStateLength = truncatedTraceState.length;
                                const traceStateLengthBytes = new Uint16Array([ traceStateLength ]);
                                contentBufferDataView.setUint16(offsetPos, traceStateLengthBytes, false);
                                offsetPos += 2;
                                const traceStateBytes = stringToUint8Array(truncatedTraceState);
                                for (let i = 0; i < traceStateBytes.length; i++) contentBufferDataView.setUint8(offsetPos + i, traceStateBytes[i], false);
                                offsetPos += traceStateBytes.length;
                            }
                        }
                        return new Uint8Array(contentBuffer);
                    }
                    _standardTraceStateTruncation(maxTraceStateLength) {
                        if (!this._traceState || null == this._traceState) return null; else if (this._traceState.length < maxTraceStateLength) return this._traceState;
                        const ignoredMembers = new Array();
                        const traceStateBuilderArray = new Array();
                        let traceStateBuilderArrayLength = 0;
                        const listMembers = this._traceState.split(",");
                        for (let i = 0; i < listMembers.length; i++) {
                            let listMember = listMembers[i];
                            if ("" !== listMember && null != listMember) {
                                let currentMemberLength = listMember.length;
                                if (currentMemberLength > 128) ignoredMembers.push(listMember); else {
                                    let newExpectedLength = traceStateBuilderArrayLength + currentMemberLength + (traceStateBuilderArrayLength > 0 ? 1 : 0);
                                    if (newExpectedLength <= maxTraceStateLength) {
                                        traceStateBuilderArray.push(listMember);
                                        traceStateBuilderArrayLength += currentMemberLength + (traceStateBuilderArrayLength > 0 ? 1 : 0);
                                    } else ignoredMembers.push(listMember);
                                }
                            }
                        }
                        for (let i = 0; i < ignoredMembers.length; i++) {
                            let currentMember = ignoredMembers[i];
                            let currentMemberLength = currentMember.length;
                            let newExpectedLength = traceStateBuilderArrayLength + currentMemberLength + (traceStateBuilderArrayLength > 0 ? 1 : 0);
                            if (newExpectedLength <= maxTraceStateLength) {
                                traceStateBuilderArray.push(currentMember);
                                traceStateBuilderArrayLength += currentMemberLength + (traceStateBuilderArrayLength > 0 ? 1 : 0);
                            }
                        }
                        return traceStateBuilderArray.join(",");
                    }
                    toString() {
                        return "{traceId=" + this.getTraceId() + ", spanId=" + this.getSpanId() + ", sampled=" + this.isSampled + ", traceState=" + (null == this.traceState ? "}" : "'" + this.traceState + "'}");
                    }
                }
                module.exports.TraceContext = TraceContext;
            },
            "./modules/solclient-message-tracing/lib/message-tracing-support.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const {} = __webpack_require__("./modules/solclient-message-tracing/lib/baggage.js");
                const TraceContext = __webpack_require__("./modules/solclient-message-tracing/lib/message-trace-context.js").TraceContext;
                const TraceContextSetter = __webpack_require__("./modules/solclient-message-tracing/lib/message-trace-context-setter.js").TraceContextSetter;
                class MessageTracingSupport {
                    constructor() {}
                    getTraceContextSetter() {
                        if (null == this._traceContextSetter || void 0 == this._traceContextSetter) this._traceContextSetter = new TraceContextSetter();
                        return this._traceContextSetter;
                    }
                    getTransportContext() {
                        return this._transportContext;
                    }
                    _setTransportContext(contextSetter) {
                        if (null != contextSetter) this._transportContext = new TraceContext(contextSetter);
                    }
                    getCreationContext() {
                        return this._creationContext;
                    }
                    _setCreationContext(contextSetter) {
                        if (null != contextSetter) this._creationContext = new TraceContext(contextSetter);
                    }
                    getBaggage() {
                        return this._baggage;
                    }
                    _setBaggage(value) {
                        this._baggage = value;
                    }
                }
                module.exports.MessageTracingSupport = MessageTracingSupport;
            },
            "./modules/solclient-message/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ReplicationGroupMessageId,
                    RgmidFactory
                } = __webpack_require__("./modules/solclient-message/lib/replication-group-message-id.js");
                const Message = __webpack_require__("./modules/solclient-message/lib/message.js").Message;
                const MessageCacheStatus = __webpack_require__("./modules/solclient-message/lib/message-cache-status.js").MessageCacheStatus;
                const MessageDeliveryModeType = __webpack_require__("./modules/solclient-message/lib/message-delivery-mode-types.js").MessageDeliveryModeType;
                const MessageDumpFlag = __webpack_require__("./modules/solclient-message/lib/message-dump-flags.js").MessageDumpFlag;
                const MessageDumpStandardProvider = __webpack_require__("./modules/solclient-message/lib/message-dump-standard-provider.js").MessageDumpStandardProvider;
                const MessageDumpUtil = __webpack_require__("./modules/solclient-message/lib/message-dump-util.js").MessageDumpUtil;
                const MessageType = __webpack_require__("./modules/solclient-message/lib/message-types.js").MessageType;
                const MessageOutcome = __webpack_require__("./modules/solclient-message/lib/message-outcomes.js").MessageOutcome;
                const MessageUserCosType = __webpack_require__("./modules/solclient-message/lib/message-user-cos-types.js").MessageUserCosType;
                const SolclientFactory = __webpack_require__("./modules/solclient-factory/api.js").SolclientFactory;
                SolclientFactory.createMessage = SolclientFactory.createFactory(() => new Message());
                SolclientFactory.createReplicationGroupMessageId = SolclientFactory.createFactory(id => RgmidFactory.fromString(id));
                module.exports.Message = Message;
                module.exports.MessageCacheStatus = MessageCacheStatus;
                module.exports.MessageDeliveryModeType = MessageDeliveryModeType;
                module.exports.MessageDumpFlag = MessageDumpFlag;
                module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;
                module.exports.MessageDumpUtil = MessageDumpUtil;
                module.exports.MessageType = MessageType;
                module.exports.MessageOutcome = MessageOutcome;
                module.exports.MessageUserCosType = MessageUserCosType;
                module.exports.ReplicationGroupMessageId = ReplicationGroupMessageId;
                module.exports.RgmidFactory = RgmidFactory;
            },
            "./modules/solclient-message/lib/message-cache-status.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessageCacheStatus = {
                    LIVE: 0,
                    CACHED: 1,
                    SUSPECT: 2
                };
                module.exports.MessageCacheStatus = Enum.new(MessageCacheStatus);
            },
            "./modules/solclient-message/lib/message-delivery-mode-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessageDeliveryModeType = {
                    DIRECT: 0,
                    PERSISTENT: 1,
                    NON_PERSISTENT: 2
                };
                module.exports.MessageDeliveryModeType = Enum.new(MessageDeliveryModeType);
            },
            "./modules/solclient-message/lib/message-dump-flags.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessageDumpFlag = {
                    MSGDUMP_BRIEF: 0,
                    MSGDUMP_FULL: 1
                };
                module.exports.MessageDumpFlag = Enum.new(MessageDumpFlag);
            },
            "./modules/solclient-message/lib/message-dump-standard-provider.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
                const MessageDumpUtilLib = __webpack_require__("./modules/solclient-message/lib/message-dump-util.js");
                const Destination = __webpack_require__("./modules/solclient-destination/api.js").Destination;
                const LOG_ERROR = __webpack_require__("./modules/solclient-log/api.js").LOG_ERROR;
                const Long = __webpack_require__("./modules/solclient-convert/api.js").Long;
                const MessageCacheStatus = __webpack_require__("./modules/solclient-message/lib/message-cache-status.js").MessageCacheStatus;
                const MessageDeliveryModeType = __webpack_require__("./modules/solclient-message/lib/message-delivery-mode-types.js").MessageDeliveryModeType;
                const MessageDumpFlag = __webpack_require__("./modules/solclient-message/lib/message-dump-flags.js").MessageDumpFlag;
                const MessageUserCosType = __webpack_require__("./modules/solclient-message/lib/message-user-cos-types.js").MessageUserCosType;
                const {
                    SDTMapContainer,
                    SDTFieldType
                } = __webpack_require__("./modules/solclient-sdt/api.js");
                const StringUtils = __webpack_require__("./modules/solclient-util/api.js").StringUtils;
                const MessageDumpStandardProvider = {
                    fpDestination(message) {
                        const dest = message.getDestination();
                        if (null !== dest && dest instanceof Destination) return [ "Destination", true, dest.toString(), null ];
                        return [ "Destination", false, "", null ];
                    },
                    fpSenderId(message) {
                        return [ "SenderId", void 0 !== message.getSenderId() && null !== message.getSenderId(), message.getSenderId(), null ];
                    },
                    fpAppmsgType(message) {
                        return [ "AppMessageType", void 0 !== message.getApplicationMessageType() && null !== message.getApplicationMessageType(), message.getApplicationMessageType(), null ];
                    },
                    fpAppMsgId(message) {
                        return [ "AppMessageID", void 0 !== message.getApplicationMessageId() && null !== message.getApplicationMessageId(), message.getApplicationMessageId(), null ];
                    },
                    fpSequenceNumber(message) {
                        const sequenceNum = message.getSequenceNumber();
                        if ("number" === typeof sequenceNum) return [ "SequenceNumber", true, sequenceNum, null ];
                        return [ "SequenceNumber", false, "", null ];
                    },
                    fpTopicSequenceNumber(message) {
                        const topicSeqNo = message.getTopicSequenceNumber();
                        if (Long.isLong(topicSeqNo)) return [ "TopicSequenceNumber", true, topicSeqNo.toString(), null ];
                        return [ "TopicSequenceNumber", false, "", null ];
                    },
                    fpCorrelationId(message) {
                        return [ "CorrelationId", void 0 !== message.getCorrelationId() && null !== message.getCorrelationId(), message.getCorrelationId(), null ];
                    },
                    fpHttpContentType(message) {
                        return [ "HTTP Content Type", void 0 !== message.getHttpContentType() && null !== message.getHttpContentType(), message.getHttpContentType(), null ];
                    },
                    fpHttpContentEncoding(message) {
                        return [ "HTTP Content Encoding", void 0 !== message.getHttpContentEncoding() && null !== message.getHttpContentEncoding(), message.getHttpContentEncoding(), null ];
                    },
                    fpSendTimestamp(message) {
                        const timestamp = message.getSenderTimestamp();
                        if ("number" === typeof timestamp) {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            return [ "SendTimestamp", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                        }
                        return [ "SendTimestamp", false, "", null ];
                    },
                    fpRcvTimestamp(message) {
                        const timestamp = message.getReceiverTimestamp();
                        if ("number" === typeof timestamp) {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            return [ "RcvTimestamp", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                        }
                        return [ "RcvTimestamp", false, "", null ];
                    },
                    fpClassOfService(message) {
                        const cos = message.getUserCos();
                        if ("number" === typeof cos) return [ "Class Of Service", true, MessageUserCosType.nameOf(message.getUserCos()), null ];
                        return [ "Class Of Service", false, "", null ];
                    },
                    fpDeliveryMode(message) {
                        const mode = message.getDeliveryMode();
                        if ("number" === typeof mode) return [ "DeliveryMode", true, MessageDeliveryModeType.nameOf(message.getDeliveryMode()), null ];
                        return [ "DeliveryMode", false, "", null ];
                    },
                    fpGuaranteedMsgId(message) {
                        const msgId = message.getGuaranteedMessageId();
                        if (Long.isLong(msgId)) return [ "Message Id", true, msgId.toString(10), null ];
                        return [ "Message Id", false, "", null ];
                    },
                    fpReplicationGroupMessageId(message) {
                        const rgmid = message.getReplicationGroupMessageId();
                        if (void 0 === rgmid) return [ "Replication Group Message Id", false, "", null ];
                        return [ "Replication Group Message Id", true, rgmid.toString(), null ];
                    },
                    fpTimeToLive(message) {
                        const timeToLive = message.getTimeToLive();
                        if ("number" === typeof timeToLive) {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            const d = new Date();
                            return [ "TimeToLive", true, `${timeToLive} (${mdu.formatDate(d.getTime() + timeToLive)})`, null ];
                        }
                        return [ "TimeToLive", false, "", null ];
                    },
                    fpExpiration(message) {
                        const timestamp = message.getGMExpiration();
                        if ("number" === typeof timestamp) {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            return [ "Expiration", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                        }
                        return [ "Expiration", false, "", null ];
                    },
                    fpMessageDMQEligible(message) {
                        return [ "DMQ Eligible", message.isDMQEligible(), "", null ];
                    },
                    fpMessageRedelivered(message) {
                        return [ "Message Re-delivered", message.isRedelivered(), "", null ];
                    },
                    fpMessageDeliveryCount(message) {
                        try {
                            return [ "Message Delivery Count", true, message.getDeliveryCount(), null ];
                        } catch (e) {
                            return [ "Message Delivery Count", false, "", null ];
                        }
                    },
                    fpDiscardIndication(message) {
                        return [ "Discard Indication", message.isDiscardIndication(), "", null ];
                    },
                    fpAckImmediately(message) {
                        return [ "ACK Immediately", message.isAcknowledgeImmediately(), "", null ];
                    },
                    fpElidingEligible(message) {
                        return [ "Eliding Eligible", message.isElidingEligible(), "", null ];
                    },
                    fpReplyMessage(message) {
                        return [ "Reply Message", message.isReplyMessage(), "", null ];
                    },
                    fpReplyTo(message) {
                        const replyTo = message.getReplyTo();
                        if (null !== replyTo && replyTo instanceof Destination) return [ "ReplyTo", true, replyTo.toString(), null ];
                        return [ "ReplyTo", false, "", null ];
                    },
                    fpDeliverToOne(message) {
                        return [ "Deliver To One", message.isDeliverToOne(), "", null ];
                    },
                    fpCacheMessage(message) {
                        return [ "Message from cache", message.getCacheStatus() !== MessageCacheStatus.LIVE, "", null ];
                    },
                    fpCacheRequestId(message) {
                        const cacheRequestId = message.getCacheRequestId();
                        if ("number" === typeof cacheRequestId) return [ "Cache Request Id", true, cacheRequestId, null ];
                        return [ "Cache Request Id", false, "", null ];
                    },
                    fpUserPropertyMap(message, flags) {
                        const propMap = message.getUserPropertyMap();
                        if (null !== propMap && propMap instanceof SDTMapContainer) {
                            const value = propMap.getKeys().length + ` entries`;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) try {
                                const mdu = MessageDumpUtilLib.MessageDumpUtil;
                                detailValue = mdu.printMap(propMap, 2);
                            } catch (e) {
                                LOG_ERROR(e.message, e.stack);
                                detailValue = "Error";
                            }
                            return [ "User Property Map", true, value, detailValue ];
                        }
                        return [ "User Property Map", false, "", null ];
                    },
                    fpCorrelationTag(message) {
                        const strValue = message.getCorrelationKey();
                        return [ "Correlation Tag Pointer", void 0 !== strValue && null !== strValue, strValue, null ];
                    },
                    fpUserData(message) {
                        if (StringUtils.notEmpty(message.getUserData())) return [ "User Data", true, `len=` + message.getUserData().length, DebugLib.Debug.formatDumpBytes(message.getUserData(), true, 2) ];
                        return [ "User Data", false, "", null ];
                    },
                    fpXmlMetadata(message, flags) {
                        const xmlMetadata = message.getXmlMetadata();
                        if (StringUtils.notEmpty(xmlMetadata)) {
                            const value = `len=` + xmlMetadata.length;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) detailValue = DebugLib.Debug.formatDumpBytes(xmlMetadata, true, 2);
                            return [ "XML Metadata", true, value, detailValue ];
                        }
                        return [ "XML Metadata", false, "", null ];
                    },
                    fpTracingCreationContext(message, flags) {
                        const _creationContext = message.getCreationContext();
                        const isPresent = null != _creationContext && null != _creationContext.getTraceId() && null != _creationContext.getSpanId();
                        let detailValue = null;
                        if (flags && flags === MessageDumpFlag.MSGDUMP_FULL) detailValue = null != _creationContext ? _creationContext.toString() : null;
                        return [ "Tracing CreationContext", isPresent, detailValue, null ];
                    },
                    fpTracingTransportContext(message, flags) {
                        const _transportContext = message.getTransportContext();
                        const isPresent = null != _transportContext && null != _transportContext.getTraceId() && null != _transportContext.getSpanId();
                        let detailValue = null;
                        if (flags && flags === MessageDumpFlag.MSGDUMP_FULL) detailValue = null != _transportContext ? _transportContext.toString() : null;
                        return [ "Trace Context SMF Parameter", isPresent, detailValue, null ];
                    },
                    fpTracingBaggage(message, flags) {
                        const isPresent = null != message.getBaggage() && null != message.getBaggage().getBaggage();
                        let detailValue = null;
                        if (flags && flags === MessageDumpFlag.MSGDUMP_FULL) {
                            const _baggage = message.getBaggage();
                            detailValue = null != _baggage ? _baggage.getBaggage() : null;
                        }
                        return [ "Tracing Baggage", isPresent, detailValue, null ];
                    },
                    fpSdtStream(message, flags) {
                        const sdtFieldValue = message.getSdtContainer();
                        if (null !== sdtFieldValue && sdtFieldValue.getType() === SDTFieldType.STREAM) {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            const value = mdu.countItems(sdtFieldValue.getValue()) + ` entries`;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) try {
                                detailValue = mdu.printStream(sdtFieldValue.getValue(), 2);
                            } catch (e) {
                                LOG_ERROR(e.message, e.stack);
                                detailValue = "Error";
                            }
                            return [ "SDT Stream", true, value, detailValue ];
                        }
                        return [ "SDT Stream", false, "", null ];
                    },
                    fpSdtMap(message, flags) {
                        const sdtFieldValue = message.getSdtContainer();
                        if (null !== sdtFieldValue && sdtFieldValue.getType() === SDTFieldType.MAP) {
                            const value = sdtFieldValue.getValue().getKeys().length + ` entries`;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) try {
                                const mdu = MessageDumpUtilLib.MessageDumpUtil;
                                detailValue = mdu.printMap(sdtFieldValue.getValue(), 2);
                            } catch (e) {
                                LOG_ERROR(e.message, e.stack);
                                detailValue = "Error";
                            }
                            return [ "SDT Map", true, value, detailValue ];
                        }
                        return [ "SDT Map", false, "", null ];
                    },
                    fpBinaryAttachment(message, flags) {
                        if (!message._binaryAttachment || message._binaryAttachment.length < 1) return [ "Binary Attachment", false, "", null ];
                        const att = message._binaryAttachment.toString("latin1");
                        const value = `len=` + att.length;
                        let detailValue = null;
                        if (flags === MessageDumpFlag.MSGDUMP_FULL) detailValue = DebugLib.Debug.formatDumpBytes(att, true, 2);
                        return [ "Binary Attachment", true, value, detailValue ];
                    },
                    fpXmlContent(message, flags) {
                        const xml = message.getXmlContent();
                        if (StringUtils.notEmpty(xml)) {
                            const value = `len=` + xml.length;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) detailValue = DebugLib.Debug.formatDumpBytes(xml, true, 2);
                            return [ "XML", true, value, detailValue ];
                        }
                        return [ "XML", false, "", null ];
                    }
                };
                module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;
            },
            "./modules/solclient-message/lib/message-dump-util.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
                const MessageDumpStandardProviderLib = __webpack_require__("./modules/solclient-message/lib/message-dump-standard-provider.js");
                const {
                    SDTFieldType,
                    SDTMapContainer,
                    SDTStreamContainer,
                    SDTUnsupportedValueError,
                    SDTValueErrorSubcode
                } = __webpack_require__("./modules/solclient-sdt/api.js");
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const MessageDumpFlag = __webpack_require__("./modules/solclient-message/lib/message-dump-flags.js").MessageDumpFlag;
                const {
                    StringBuffer,
                    StringUtils
                } = __webpack_require__("./modules/solclient-util/api.js");
                const MessageDumpState = {
                    get dumpProviders() {
                        const providers = MessageDumpStandardProviderLib.MessageDumpStandardProvider;
                        return Object.keys(providers).map(k => providers[k]);
                    }
                };
                const MessageDumpUtil = {
                    getOutOfRangeValue(rawData) {
                        if ("string" === typeof rawData) return `<out of range>
` + DebugLib.Debug.formatDumpBytes(rawData);
                        return `<out of range>
` + DebugLib.Debug.formatDumpBytes(rawData.toString("latin1"));
                    },
                    getValue(sdtField) {
                        let value = null;
                        try {
                            value = sdtField.getValue();
                            return value;
                        } catch (e) {
                            if (e instanceof SDTUnsupportedValueError) {
                                if (e.getSubcode() === SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE) return this.getOutOfRangeValue(e.getSourceData());
                            } else if (e instanceof OperationError && e.subcode === ErrorSubcode.PARAMETER_INVALID_TYPE) return "<invalid type>";
                            throw e;
                        }
                    },
                    printMap(sdtMap, indent) {
                        if (Check.nothing(sdtMap) || !(sdtMap instanceof SDTMapContainer)) return null;
                        const lines = [];
                        const strIndent = StringUtils.padRight("", indent, " ");
                        const keys = sdtMap.getKeys().sort();
                        keys.forEach(key => {
                            const sdtFieldValue = sdtMap.getField(key);
                            const type = sdtFieldValue.getType();
                            const value = this.getValue(sdtFieldValue);
                            let strValue;
                            switch (type) {
                              case SDTFieldType.MAP:
                                strValue = `
` + this.printMap(value, indent + 2);
                                break;

                              case SDTFieldType.STREAM:
                                strValue = `
` + this.printStream(value, indent + 2);
                                break;

                              case SDTFieldType.BYTEARRAY:
                                strValue = DebugLib.Debug.formatDumpBytes(value.toString("latin1"), false, 0);
                                if (null !== strValue && "\n" === strValue.substr(-1)) strValue = strValue.substring(0, strValue.length - 1);
                                break;

                              default:
                                strValue = null !== value ? value.toString() : null;
                            }
                            lines.push(`${strIndent}Key '${key}' (${SDTFieldType.nameOf(type)}): ` + strValue);
                        });
                        return lines.join("\n");
                    },
                    printStream(sdtStream, indent) {
                        if (Check.nothing(sdtStream) || !(sdtStream instanceof SDTStreamContainer)) return null;
                        sdtStream.rewind();
                        const lines = [];
                        const strIndent = StringUtils.padRight("", indent, " ");
                        while (sdtStream.hasNext()) {
                            const sdtFieldValue = sdtStream.getNext();
                            const type = sdtFieldValue.getType();
                            const value = this.getValue(sdtFieldValue);
                            let strValue;
                            switch (type) {
                              case SDTFieldType.MAP:
                                strValue = `
` + this.printMap(value, indent + 2);
                                break;

                              case SDTFieldType.STREAM:
                                strValue = `
` + this.printStream(value, indent + 2);
                                break;

                              case SDTFieldType.BYTEARRAY:
                                strValue = DebugLib.Debug.formatDumpBytes(value.toString("latin1"), false, 0);
                                if (null !== strValue && "\n" === strValue.substr(-1)) strValue = strValue.substring(0, strValue.length - 1);
                                break;

                              case SDTFieldType.DESTINATION:
                                strValue = value.toString();
                                break;

                              default:
                                strValue = null !== value ? value.toString() : null;
                            }
                            lines.push(`${strIndent}(${SDTFieldType.nameOf(type)}): ` + strValue);
                        }
                        sdtStream.rewind();
                        return lines.join("\n");
                    },
                    countItems(sdtStream) {
                        if (Check.nothing(sdtStream) || !(sdtStream instanceof SDTStreamContainer)) return 0;
                        sdtStream.rewind();
                        let count = 0;
                        while (sdtStream.hasNext()) {
                            sdtStream.getNext();
                            count++;
                        }
                        sdtStream.rewind();
                        return count;
                    },
                    formatDate(timeStamp) {
                        return new Date(timeStamp).toString();
                    },
                    dump(message, flags, separator, colPadding) {
                        const sb = new StringBuffer();
                        let theSeparator = "\n";
                        let needSeparator = false;
                        let theColPadding = 40;
                        if (void 0 !== separator && null !== separator && "string" === typeof separator) theSeparator = separator;
                        if (void 0 !== colPadding && null !== colPadding && "number" === typeof colPadding) theColPadding = colPadding;
                        MessageDumpState.dumpProviders.forEach((provider, index) => {
                            const [ key, isPresent, value, detailValue ] = provider(message, flags);
                            if (!isPresent) return;
                            if (needSeparator) sb.append(theSeparator);
                            if (null === value || 0 === value.length) sb.append(key); else {
                                sb.append(StringUtils.padRight(key + `:`, theColPadding, " "));
                                sb.append(value);
                            }
                            if (null !== detailValue && flags & MessageDumpFlag.MSGDUMP_FULL) {
                                sb.append("\n");
                                if (0 !== detailValue.indexOf("  ")) sb.append("  ");
                                sb.append(detailValue);
                                if ("\n" !== detailValue.substr(-1) && index < MessageDumpState.dumpProviders.length - 1) sb.append("\n");
                            }
                            needSeparator = true;
                        });
                        return sb.toString();
                    }
                };
                module.exports.MessageDumpUtil = MessageDumpUtil;
            },
            "./modules/solclient-message/lib/message-outcomes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessageOutcome = {
                    ACCEPTED: 0,
                    FAILED: 1,
                    REJECTED: 3
                };
                module.exports.MessageOutcome = Enum.new(MessageOutcome);
            },
            "./modules/solclient-message/lib/message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessageType = {
                    BINARY: 0,
                    MAP: 1,
                    STREAM: 2,
                    TEXT: 3
                };
                module.exports.MessageType = Enum.new(MessageType);
            },
            "./modules/solclient-message/lib/message-user-cos-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MessageUserCosType = {
                    COS1: 0,
                    COS2: 1,
                    COS3: 2
                };
                module.exports.MessageUserCosType = Enum.new(MessageUserCosType);
            },
            "./modules/solclient-message/lib/message.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const clone = __webpack_require__("./modules/solclient-util/api.js").clone;
                const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
                const SDTCodec = __webpack_require__("./modules/solclient-sdt/api.js").Codec;
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const Destination = __webpack_require__("./modules/solclient-destination/api.js").Destination;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const LOG_WARN = __webpack_require__("./modules/solclient-log/api.js").LOG_WARN;
                const MessageCacheStatus = __webpack_require__("./modules/solclient-message/lib/message-cache-status.js").MessageCacheStatus;
                const MessageDeliveryModeType = __webpack_require__("./modules/solclient-message/lib/message-delivery-mode-types.js").MessageDeliveryModeType;
                const MessageDumpFlag = __webpack_require__("./modules/solclient-message/lib/message-dump-flags.js").MessageDumpFlag;
                const MessageDumpUtil = __webpack_require__("./modules/solclient-message/lib/message-dump-util.js").MessageDumpUtil;
                const MessageType = __webpack_require__("./modules/solclient-message/lib/message-types.js").MessageType;
                const MessageOutcome = __webpack_require__("./modules/solclient-message/lib/message-outcomes.js").MessageOutcome;
                const MessageUserCosType = __webpack_require__("./modules/solclient-message/lib/message-user-cos-types.js").MessageUserCosType;
                const Parameter = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                const RgmidFactory = __webpack_require__("./modules/solclient-message/lib/replication-group-message-id.js").RgmidFactory;
                const {
                    SDTField,
                    SDTFieldType,
                    SDTMapContainer,
                    SDTUnsupportedValueError
                } = __webpack_require__("./modules/solclient-sdt/api.js");
                const {
                    Baggage,
                    MessageTracingSupport
                } = __webpack_require__("./modules/solclient-message-tracing/api.js");
                const ProfileBinding = SolclientFactoryLib.ProfileBinding;
                const {
                    utf8ToUcs2,
                    anythingToBuffer
                } = Convert;
                const {
                    isBoolean,
                    isEnumMember,
                    isInstanceOf,
                    isInstanceOfOrNothing,
                    isNumberOrNothing,
                    isStringOrNothing
                } = Parameter;
                const MESSAGE_CLONE_OPTIONS = {
                    circular: false,
                    includeNonEnumerable: false
                };
                function initMessage(message) {
                    message._deliveryMode = MessageDeliveryModeType.DIRECT;
                    message._userCos = MessageUserCosType.COS1;
                    message._cacheStatus = MessageCacheStatus.LIVE;
                    message._spoolerUniqueId = void 0;
                    message._priority = void 0;
                    message._deliveryCount = -1;
                    message._traceContextSetter = null;
                    message._creationContext = null;
                    message._transportContext = null;
                    message._baggage = new Baggage();
                }
                function clearMessage(message) {
                    const fields = Object.keys(message);
                    fields.forEach(f => delete message[f]);
                }
                function clearExtendedVarLenParameters(message) {
                    message._transportContext = null;
                }
                class Message extends MessageTracingSupport {
                    constructor() {
                        super();
                        initMessage(this);
                    }
                    getType() {
                        return this._messageType || MessageType.BINARY;
                    }
                    setApplicationMessageId(value) {
                        this._applicationMessageId = isStringOrNothing("applicationMessageId", value);
                    }
                    getApplicationMessageId() {
                        return this._applicationMessageId;
                    }
                    setApplicationMessageType(value) {
                        this._applicationMessageType = isStringOrNothing("applicationMessageType", value);
                    }
                    getApplicationMessageType() {
                        return this._applicationMessageType;
                    }
                    getBinaryAttachment() {
                        if (this._binaryAttachment && ProfileBinding.value.byteArrayAsString) return this._binaryAttachment.toString("latin1");
                        return this._binaryAttachment;
                    }
                    setBinaryAttachment(value) {
                        if (value) this._messageType = MessageType.BINARY;
                        this._setBinaryAttachment(anythingToBuffer(value));
                    }
                    _setBinaryAttachment(value) {
                        this._binaryAttachment = value;
                    }
                    getCacheRequestId() {
                        return this._cacheRequestId;
                    }
                    _setCacheRequestID(cacheRequestID) {
                        this._cacheRequestId = cacheRequestID;
                    }
                    getCorrelationId() {
                        return this._correlationId;
                    }
                    setCorrelationId(value) {
                        this._correlationId = isStringOrNothing("correlationId", value);
                    }
                    getCorrelationKey() {
                        return this._correlationKey || null;
                    }
                    setCorrelationKey(value) {
                        this._correlationKey = value;
                    }
                    isDeliverToOne() {
                        return this._deliverToOne || false;
                    }
                    setDeliverToOne(value) {
                        this._setDeliverToOne(this._deliverToOne = isBoolean("deliverToOne", value));
                    }
                    _setDeliverToOne(value) {
                        this._deliverToOne = value;
                    }
                    getDeliveryMode() {
                        return this._deliveryMode;
                    }
                    setDeliveryMode(value) {
                        this._setDeliveryMode(isEnumMember("deliveryMode", value, MessageDeliveryModeType));
                    }
                    _setDeliveryMode(value) {
                        this._deliveryMode = value;
                    }
                    getDestination() {
                        return this._destination;
                    }
                    setDestination(value) {
                        this._setDestination(isInstanceOf("destination", value, Destination));
                    }
                    _setDestination(value) {
                        this._destination = value;
                    }
                    isDiscardIndication() {
                        return this._discardIndication || false;
                    }
                    setDiscardIndication(value) {
                        this._setDiscardIndication(isBoolean("discardIndication", value));
                    }
                    _setDiscardIndication(value) {
                        this._discardIndication = value;
                    }
                    isElidingEligible() {
                        return this._elidingEligible || false;
                    }
                    setElidingEligible(value) {
                        this._setElidingEligible(isBoolean("setElidingEligible", value));
                    }
                    _setElidingEligible(value) {
                        this._elidingEligible = value;
                    }
                    getHttpContentEncoding() {
                        return this._httpContentEncoding;
                    }
                    setHttpContentEncoding(value) {
                        this._httpContentEncoding = isStringOrNothing("httpContentEncoding", value);
                        if ("" === this._httpContentEncoding) delete this._httpContentEncoding;
                    }
                    getHttpContentType() {
                        return this._httpContentType;
                    }
                    setHttpContentType(value) {
                        this._httpContentType = isStringOrNothing("httpContentType", value);
                        if ("" === this._httpContentType) delete this._httpContentType;
                    }
                    getPublisherId() {
                        return this._publisherId;
                    }
                    setPublisherId(value) {
                        this._publisherId = value;
                    }
                    getPublisherMessageId() {
                        return this._publisherMsgId;
                    }
                    setPublisherMessageId(value) {
                        this._publisherMsgId = value;
                    }
                    getTimeToLive() {
                        return this._timeToLive;
                    }
                    setTimeToLive(value) {
                        const MAX_MESSAGE_TTL_MS = 10 * 365 * 24 * 60 * 60 * 1e3;
                        if (null === value || void 0 === value) {
                            this._timeToLive = value;
                            return;
                        }
                        if ("number" !== typeof value || isNaN(value)) throw new OperationError("Invalid type for time to live", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        if (value < 0 || value > MAX_MESSAGE_TTL_MS) throw new OperationError("Invalid time to live value", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        this._timeToLive = value;
                    }
                    getGMExpiration() {
                        return this._expiration;
                    }
                    setGMExpiration(value) {
                        this._expiration = isNumberOrNothing("GMExpiration", value);
                    }
                    isDMQEligible() {
                        return this._dmqEligible || false;
                    }
                    setDMQEligible(value) {
                        this._setDMQEligible(isBoolean("DMQEligible", value));
                    }
                    _setDMQEligible(value) {
                        this._dmqEligible = value;
                    }
                    getFlowId() {
                        return this._flowId;
                    }
                    setFlowId(value) {
                        this._flowId = value;
                    }
                    getGuaranteedPreviousMessageId() {
                        return this._guaranteedPrevMsgId;
                    }
                    setGuaranteedPreviousMessageId(value) {
                        this._guaranteedPrevMsgId = value;
                    }
                    _setSpoolerUniqueId(value) {
                        this._spoolerUniqueId = value;
                    }
                    _getSpoolerUniqueId() {
                        if (void 0 === this._spoolerUniqueId) return RgmidFactory.INVALID_SUID;
                        return this._spoolerUniqueId;
                    }
                    getMessageConsumer() {
                        return this._consumer;
                    }
                    setMessageConsumer(value) {
                        this._consumer = value;
                    }
                    getGuaranteedMessageId() {
                        return this._guaranteedMsgId;
                    }
                    setGuaranteedMessageId(value) {
                        this._guaranteedMsgId = value;
                    }
                    _setSpoolerMessageId(value) {
                        this._spoolerMessageId = value;
                    }
                    getReplicationGroupMessageId() {
                        if (void 0 === this._spoolerUniqueId || RgmidFactory.INVALID_SUID.eq(this._spoolerUniqueId)) return;
                        const smid = this._spoolerMessageId || this._guaranteedMsgId;
                        return RgmidFactory.from({
                            suid: this._spoolerUniqueId,
                            msgid: smid
                        });
                    }
                    getTopicSequenceNumber() {
                        return this._topicSequenceNumber;
                    }
                    setTopicSequenceNumber(topicSeqNo) {
                        this._topicSequenceNumber = topicSeqNo;
                    }
                    getDeliveryCount() {
                        if (-1 === this._deliveryCount) throw new OperationError("Endpoint does not report delivery count.", ErrorSubcode.INVALID_OPERATION);
                        return this._deliveryCount;
                    }
                    setDeliveryCount(deliveryCount) {
                        this._deliveryCount = deliveryCount;
                    }
                    settle(messageSettlementOutcome) {
                        if (this._acked) throw new OperationError("Message can only be settled once", ErrorSubcode.MESSAGE_ALREADY_ACKNOWLEDGED);
                        if (this._deliveryMode === MessageDeliveryModeType.DIRECT) throw new OperationError("Cannot settle a DIRECT message", ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
                        if (!this._consumer) throw new OperationError("Cannot settle a locally-created message", ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
                        if (!this._consumer._sessionInterface.canAck) throw new OperationError("Cannot settle using associated session", ErrorSubcode.SESSION_NOT_CONNECTED);
                        if (!this._consumer.canAck) throw new OperationError("Cannot settle using associated Message Consumer", ErrorSubcode.INVALID_OPERATION);
                        if (this._consumer.getProperties().browser) throw new OperationError("Messages delivered to a Queue Browser can only be deleted by calling QueueBrowser.removeMessageFromQueue()", ErrorSubcode.INVALID_OPERATION);
                        if (this._consumer._fsm.hasAutoAckSupport) {
                            LOG_WARN(`Consumer configured to auto-acknowledge messages, so message ${this._guaranteedMsgId} cannot be application settled`);
                            return;
                        }
                        const settlementOutcome = messageSettlementOutcome;
                        if (-1 === MessageOutcome.values.indexOf(settlementOutcome)) throw new OperationError(`Settlement outcome for message must be valid`, ErrorSubcode.INVALID_OPERATION);
                        const doesConsumerSupportOutcome = this._consumer.getProperties().requiredSettlementOutcomes.some(v => v === settlementOutcome);
                        if (settlementOutcome != MessageOutcome.ACCEPTED && !doesConsumerSupportOutcome) throw new OperationError(`solace.MessageOutcome.${MessageOutcome.nameOf(settlementOutcome)} not supported for this Message Consumer`, ErrorSubcode.INVALID_OPERATION);
                        this._consumer.applicationSettle(this._guaranteedMsgId, settlementOutcome);
                        this._acked = true;
                    }
                    get isSettled() {
                        return this._acked || false;
                    }
                    _validateBeforeAcknowledge() {
                        if (this._acked) throw new OperationError("Message can only be acknowledged once", ErrorSubcode.MESSAGE_ALREADY_ACKNOWLEDGED);
                        if (this._deliveryMode === MessageDeliveryModeType.DIRECT) throw new OperationError("Cannot acknowledge a DIRECT message", ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
                        if (!this._consumer) throw new OperationError("Cannot acknowledge a locally-created message", ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
                        if (!this._consumer._sessionInterface.canAck) throw new OperationError("Cannot acknowledge using associated session", ErrorSubcode.SESSION_NOT_CONNECTED);
                        if (!this._consumer.canAck) throw new OperationError("Cannot acknowledge using associated Message Consumer", ErrorSubcode.INVALID_OPERATION);
                        if (this._consumer.getProperties().browser) throw new OperationError("Messages delivered to a Queue Browser can only be deleted by calling QueueBrowser.removeMessageFromQueue()", ErrorSubcode.INVALID_OPERATION);
                    }
                    acknowledge() {
                        this._validateBeforeAcknowledge();
                        if (this._consumer._fsm.hasAutoAckSupport) {
                            LOG_WARN(`Consumer configured to auto-acknowledge messages, so message ${this._guaranteedMsgId} cannot be application acknowledge`);
                            return;
                        }
                        this._consumer.applicationAck(this._guaranteedMsgId, false);
                        this._acked = true;
                    }
                    _autoAcknowledge() {
                        this._validateBeforeAcknowledge();
                        this._consumer.applicationAck(this._guaranteedMsgId, true);
                        this._acked = true;
                    }
                    get isAcknowledged() {
                        return this._acked || false;
                    }
                    isAcknowledgeImmediately() {
                        return this._ackImmediately || false;
                    }
                    setAcknowledgeImmediately(value) {
                        this._setAcknowledgeImmediately(isBoolean("acknowledgeImmediately", value));
                    }
                    _setAcknowledgeImmediately(value) {
                        this._ackImmediately = value;
                    }
                    getCacheStatus() {
                        return this._cacheStatus;
                    }
                    _setCacheStatus(cacheStatus) {
                        this._cacheStatus = cacheStatus;
                    }
                    isReplyMessage() {
                        return this._replyMessage || false;
                    }
                    isRedelivered() {
                        return this._redelivered || false;
                    }
                    setRedelivered(value) {
                        this._redelivered = value;
                    }
                    setAsReplyMessage(value) {
                        this._replyMessage = isBoolean("asReplyMessage", value);
                    }
                    getReceiverTimestamp() {
                        return this._receiverTimestamp;
                    }
                    getReplyTo() {
                        return this._replyTo;
                    }
                    setReplyTo(value) {
                        this._replyTo = isInstanceOfOrNothing("replyTo", value, Destination);
                    }
                    getSenderId() {
                        return this._senderId;
                    }
                    setSenderId(value) {
                        this._senderId = isStringOrNothing("senderId", value);
                    }
                    getSenderTimestamp() {
                        return this._senderTimestamp;
                    }
                    setSenderTimestamp(value) {
                        this._senderTimestamp = isNumberOrNothing("senderTimestamp", value);
                    }
                    getSequenceNumber() {
                        if (this._sequenceNumberError) throw this._sequenceNumberError;
                        return this._sequenceNumber;
                    }
                    setSequenceNumber(value) {
                        if (value instanceof SDTUnsupportedValueError) this._sequenceNumberError = value; else {
                            this._sequenceNumber = isNumberOrNothing("sequenceNumber", value);
                            this._sequenceNumberError = void 0;
                            this._autoSequenceNumber = false;
                        }
                    }
                    getUserCos() {
                        return this._userCos;
                    }
                    getPriority() {
                        return this._priority;
                    }
                    setUserCos(value) {
                        this._setUserCos(isEnumMember("userCos", value, MessageUserCosType));
                    }
                    _setUserCos(value) {
                        this._userCos = value;
                    }
                    setPriority(value) {
                        if (void 0 === value || null === value) {
                            this._setPriority(void 0);
                            return;
                        }
                        if ("number" !== typeof value || isNaN(value)) throw new OperationError("Invalid type for message priority", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        if (value < 0 || value > 255) throw new OperationError("Invalid priority value", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        this._setPriority(value);
                    }
                    _setPriority(value) {
                        this._priority = value;
                    }
                    getUserData() {
                        return this._userData;
                    }
                    setUserData(value) {
                        this._setUserData(isStringOrNothing("userData", value));
                    }
                    _setUserData(value) {
                        this._userData = value;
                    }
                    getXmlContent() {
                        return this._xmlContent;
                    }
                    getXmlContentDecoded() {
                        return this._xmlContent ? utf8ToUcs2(this._xmlContent) : this._xmlContent;
                    }
                    setXmlContent(value) {
                        const setValue = isStringOrNothing("xmlContent", value);
                        this._xmlContent = setValue ? unescape(encodeURIComponent(setValue)) : setValue;
                    }
                    _setXmlContentInternal(value) {
                        this._xmlContent = isStringOrNothing("xmlContentInternal", value);
                    }
                    setXmlMetadata(value) {
                        this._setXmlMetadata(isStringOrNothing("xmlMetadata", value));
                    }
                    _setXmlMetadata(value) {
                        this._xmlMetadata = value;
                    }
                    getXmlMetadata() {
                        return this._xmlMetadata;
                    }
                    get binaryMetadataChunk() {
                        return this._binaryMetaChunk || null;
                    }
                    set binaryMetadataChunk(meta) {
                        this._binaryMetaChunk = meta;
                    }
                    get smfHeader() {
                        return this._smfHeader;
                    }
                    set smfHeader(val) {
                        this._smfHeader = val;
                    }
                    get hasAutoSequenceNumber() {
                        return this._autoSequenceNumber || false;
                    }
                    set hasAutoSequenceNumber(value) {
                        this._autoSequenceNumber = value;
                    }
                    get hasAutoSenderTimestamp() {
                        return this._autoSenderTimestamp || false;
                    }
                    set hasAutoSenderTimestamp(value) {
                        this._autoSenderTimestamp = value;
                    }
                    getUserPropertyMap() {
                        return this._userPropertyMap;
                    }
                    setUserPropertyMap(value) {
                        this._userPropertyMap = isInstanceOfOrNothing("userPropertyMap", value, SDTMapContainer);
                    }
                    setSdtContainer(container) {
                        const structuredContainer = isInstanceOfOrNothing("sdtContainer", container, SDTField);
                        if (null === structuredContainer || void 0 === structuredContainer) {
                            this._structuredContainer = null;
                            this.setBinaryAttachment(null);
                            return;
                        }
                        this._setBinaryAttachment(null);
                        const sdtType = structuredContainer.getType();
                        switch (sdtType) {
                          case SDTFieldType.MAP:
                            this._messageType = MessageType.MAP;
                            break;

                          case SDTFieldType.STREAM:
                            this._messageType = MessageType.STREAM;
                            break;

                          case SDTFieldType.STRING:
                            this._messageType = MessageType.TEXT;
                            break;

                          default:
                            throw new OperationError("Invalid parameter: expected SDTField Type of " + "MAP, STREAM, or STRING.", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        this._structuredContainer = structuredContainer;
                    }
                    getSdtContainer() {
                        const msgType = this.getType();
                        const binaryAttachment = this._binaryAttachment;
                        const binaryAttachmentLength = binaryAttachment ? binaryAttachment.length : 0;
                        if (msgType === MessageType.BINARY) {
                            msgType;
                            return null;
                        }
                        if ("undefined" !== typeof this._structuredContainer) return this._structuredContainer;
                        if (0 === binaryAttachmentLength) {
                            binaryAttachmentLength;
                            this._structuredContainer = null;
                        } else this._structuredContainer = SDTCodec.parseSingleElement(binaryAttachment, 0);
                        return this._structuredContainer;
                    }
                    _getCompressedBinaryAttachment() {
                        return this._compressedBinaryAttachment;
                    }
                    _setCompressedBinaryAttachment(value) {
                        this._compressedBinaryAttachment = value;
                    }
                    _getPayloadCompressed() {
                        return this._payloadCompressed;
                    }
                    _setPayloadCompressed(value) {
                        this._payloadCompressed = value;
                    }
                    getSequenceNumber() {
                        if (this._sequenceNumberError) throw this._sequenceNumberError;
                        return this._sequenceNumber;
                    }
                    getTraceContextSetter() {
                        return super.getTraceContextSetter();
                    }
                    getCreationContext() {
                        return super.getCreationContext();
                    }
                    getTransportContext() {
                        return super.getTransportContext();
                    }
                    setTransportContext(contextSetter) {
                        super._setTransportContext(contextSetter);
                    }
                    getBaggage() {
                        return super.getBaggage();
                    }
                    dump(flags = MessageDumpFlag.MSGDUMP_FULL) {
                        const validFlags = isEnumMember("flags", flags, MessageDumpFlag);
                        return MessageDumpUtil.dump(this, validFlags);
                    }
                    clone() {
                        return clone(this, MESSAGE_CLONE_OPTIONS);
                    }
                    reset() {
                        clearMessage(this);
                        initMessage(this);
                    }
                    clearExtendedVarLenParams() {
                        clearExtendedVarLenParameters(this);
                    }
                }
                Message.SOLCLIENT_USER_PROP_QUEUE_PARTITION_KEY = "JMSXGroupID";
                module.exports.Message = Message;
            },
            "./modules/solclient-message/lib/replication-group-message-id.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const Long = __webpack_require__("./modules/solclient-convert/api.js").Long;
                const Parameter = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                const {
                    ReplayStartLocation,
                    ReplayStartType
                } = __webpack_require__("./modules/solclient-replaystart/api.js");
                const BufferImpl = __webpack_require__("./node_modules/buffer/index.js").Buffer;
                const RMID_VERSION_1_PREFIX = "rmid1:";
                const RMID_LEN = RMID_VERSION_1_PREFIX.length + 3 + 16 * 2;
                const validRmidHexRegex = /^[0-9a-fA-F]{32}$/g;
                const INVALID_SUID = Long.UZERO;
                const {
                    isString,
                    isValue,
                    isInstanceOf
                } = Parameter;
                class ReplicationGroupMessageId extends ReplayStartLocation {
                    constructor(spoolerUniqueId, effectiveMessageId) {
                        super({
                            _replayStartValue: {
                                suid: spoolerUniqueId,
                                messageId: effectiveMessageId
                            },
                            _type: ReplayStartType.RGMID
                        });
                        this._suid = spoolerUniqueId;
                        this._messageId = effectiveMessageId;
                    }
                    compare(otherReplicationGroupMessageId) {
                        isInstanceOf("otherReplicationGroupMessageId", otherReplicationGroupMessageId, ReplicationGroupMessageId);
                        const oId = otherReplicationGroupMessageId;
                        if (!this._suid.equals(oId._suid)) {
                            const message = "Unable to compare Replication Group Message ID from different origins";
                            throw new OperationError(`Parameter otherReplicationGroupMessageId[${oId.toString()}] failed validation`, ErrorSubcode.MESSAGE_ID_NOT_COMPARABLE, message);
                        }
                        if (this._messageId.gt(oId._messageId)) return 1; else if (this._messageId.lt(oId._messageId)) return -1;
                        return 0;
                    }
                    ["inspect"]() {
                        return `[Replication Group Message Id: ${this.toString()}]`;
                    }
                    toString() {
                        const idBuffer = BufferImpl.from(this._suid.toBytesBE().concat(this._messageId.toBytesBE()));
                        const hexString = idBuffer.toString("hex");
                        const sep = "-";
                        return `` + RMID_VERSION_1_PREFIX + hexString.substring(0, 5) + sep + hexString.substring(5, 16) + sep + hexString.substring(16, 24) + sep + hexString.substring(24, 32);
                    }
                }
                function createReplicationGroupMessageId(spec) {
                    return new ReplicationGroupMessageId(spec.suid, spec.msgid);
                }
                function fromString(rgmidStr) {
                    isString("id", rgmidStr);
                    isValue("id", rgmidStr.length, RMID_LEN, ErrorSubcode.PARAMETER_OUT_OF_RANGE, `length expected: ${RMID_LEN} but is ` + rgmidStr.length);
                    if (!rgmidStr.startsWith(RMID_VERSION_1_PREFIX)) throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, does not start with ` + RMID_VERSION_1_PREFIX);
                    const rmidBufs = rgmidStr.substring(RMID_VERSION_1_PREFIX.length).split("-");
                    if (4 !== rmidBufs.length || 5 !== rmidBufs[0].length || 11 !== rmidBufs[1].length || 8 !== rmidBufs[2].length || 8 !== rmidBufs[3].length) throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, does not have valid separation of components`);
                    const rmidHex = rmidBufs.join("").trim();
                    validRmidHexRegex.test("");
                    if (!validRmidHexRegex.test(rmidHex)) throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, invalid data string value`);
                    let rmidBuffer;
                    try {
                        rmidBuffer = BufferImpl.from(rmidHex, "hex");
                    } catch (ex) {
                        throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, failed to read data, cause: ` + ex.message);
                    }
                    const buflen = rmidBuffer ? rmidBuffer.length : 0;
                    if (16 !== buflen) throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, failed to read data from id expected length of 16 got ` + buflen);
                    const suid = Long.fromBits(rmidBuffer.readUInt32BE(4), rmidBuffer.readUInt32BE(0), true);
                    if (suid.eq(INVALID_SUID)) throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, has invalid origin`);
                    const msgid = Long.fromBits(rmidBuffer.readUInt32BE(12), rmidBuffer.readUInt32BE(8), true);
                    return createReplicationGroupMessageId({
                        suid: suid,
                        msgid: msgid
                    });
                }
                const RgmidFactory = {};
                RgmidFactory.fromString = fromString;
                RgmidFactory.from = createReplicationGroupMessageId;
                RgmidFactory.INVALID_SUID = INVALID_SUID;
                module.exports.ReplicationGroupMessageId = ReplicationGroupMessageId;
                module.exports.RgmidFactory = RgmidFactory;
            },
            "./modules/solclient-queue/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const AbstractQueueDescriptor = __webpack_require__("./modules/solclient-queue/lib/abstract-queue-descriptor.js").AbstractQueueDescriptor;
                const QueueAccessType = __webpack_require__("./modules/solclient-queue/lib/queue-access-types.js").QueueAccessType;
                const QueueDescriptor = __webpack_require__("./modules/solclient-queue/lib/queue-descriptor.js").QueueDescriptor;
                const QueueDescriptorValidator = __webpack_require__("./modules/solclient-queue/lib/queue-descriptor-validator.js").QueueDescriptorValidator;
                const QueueDiscardBehavior = __webpack_require__("./modules/solclient-queue/lib/queue-discard-behaviors.js").QueueDiscardBehavior;
                const QueuePermissions = __webpack_require__("./modules/solclient-queue/lib/queue-permissions.js").QueuePermissions;
                const QueueProperties = __webpack_require__("./modules/solclient-queue/lib/queue-properties.js").QueueProperties;
                const QueuePropertiesValidator = __webpack_require__("./modules/solclient-queue/lib/queue-properties-validator.js").QueuePropertiesValidator;
                const QueueType = __webpack_require__("./modules/solclient-queue/lib/queue-types.js").QueueType;
                const {
                    EndpointNameComplaint,
                    explainInvalidEndpointName
                } = __webpack_require__("./modules/solclient-queue/lib/endpoint-name-complaint.js");
                module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;
                module.exports.QueueAccessType = QueueAccessType;
                module.exports.QueueDescriptor = QueueDescriptor;
                module.exports.QueueDescriptorValidator = QueueDescriptorValidator;
                module.exports.QueueDiscardBehavior = QueueDiscardBehavior;
                module.exports.QueuePermissions = QueuePermissions;
                module.exports.QueueProperties = QueueProperties;
                module.exports.QueuePropertiesValidator = QueuePropertiesValidator;
                module.exports.QueueType = QueueType;
                module.exports.EndpointNameComplaint = EndpointNameComplaint;
                module.exports.explainInvalidEndpointName = explainInvalidEndpointName;
            },
            "./modules/solclient-queue/lib/abstract-queue-descriptor.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const APIProperties = __webpack_require__("./modules/solclient-util/api.js").APIProperties;
                const DestinationType = __webpack_require__("./modules/solclient-destination/api.js").DestinationType;
                const {
                    OperationError,
                    ErrorSubcode
                } = __webpack_require__("./modules/solclient-error/api.js");
                const QueueType = __webpack_require__("./modules/solclient-queue/lib/queue-types.js").QueueType;
                const DEFAULTS = {
                    durable: true,
                    type: void 0
                };
                const TYPE_DESCRIPTION = {
                    [QueueType.QUEUE]: "queue",
                    [QueueType.TOPIC_ENDPOINT]: "topic endpoint"
                };
                const DESINATION_TYPE_TO_DESCRIPTOR_TYPE = {
                    [DestinationType.TOPIC]: null,
                    [DestinationType.QUEUE]: QueueType.QUEUE,
                    [DestinationType.TEMPORARY_QUEUE]: QueueType.QUEUE
                };
                function maybeAdaptFromDestination(spec) {
                    if (spec && spec.name && spec.type && DestinationType.values.includes(spec.type)) {
                        const targetType = DESINATION_TYPE_TO_DESCRIPTOR_TYPE[spec.type];
                        if (!targetType) throw new OperationError(`Cannot create a descriptor from a ${DestinationType.describe(spec.type)} destination`, ErrorSubcode.PARAMETER_CONFLICT);
                        return {
                            name: spec.name,
                            type: QueueType.QUEUE,
                            durable: spec.type !== DestinationType.TEMPORARY_QUEUE
                        };
                    }
                    return spec;
                }
                class AbstractQueueDescriptor extends APIProperties {
                    constructor(queueSpec) {
                        super(DEFAULTS, maybeAdaptFromDestination(queueSpec));
                    }
                    getType() {
                        return this._type;
                    }
                    get type() {
                        return this.getType();
                    }
                    set type(value) {
                        this._type = value;
                    }
                    isDurable() {
                        return this._durable;
                    }
                    get durable() {
                        return this.isDurable();
                    }
                    set durable(value) {
                        this._durable = value;
                    }
                    ["inspect"]() {
                        return {
                            type: this.type,
                            durable: this.durable
                        };
                    }
                    toString() {
                        return `${!this.isDurable() ? "non" : ""}-durable ` + `` + TYPE_DESCRIPTION[this.getType()];
                    }
                }
                module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;
            },
            "./modules/solclient-queue/lib/endpoint-name-complaint.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const nameChecks = [ [ "EMPTY_STRING", /^$/, "Zero length", true ], [ "LT", /</, "Less than sign (<)", true ], [ "GT", />/, "Greater than sign (>)", true ], [ "ASTERISK", /\*/, "Asterisk (*)", true ], [ "QUESTION_MARK", /\?/, "Question mark (?)", true ], [ "AMPERSAND", /&/, "Ampersand (&)", true ], [ "SEMICOLON", /;/, "Semicolon (;)", true ], [ "LEADING_SLASH", /^\//, "Starts with a slash (/).", false ], [ "TRAILING_SLASH", /\/$/, "Ends with a slash (/).", false ], [ "DOUBLE_SLASH", /\/\//, "Empty level (//)", false ], [ "TOO_LONG", /.{200,}/, "Longer than 200 characters", true ] ];
                const EndpointNameComplaint = {
                    EMPTY_STRING: "Zero length",
                    LT: "Less than sign (<)",
                    GT: "Greater than sign (>)",
                    ASTERISK: "Asterisk (*)",
                    QUESTION_MARK: "Question mark (?)",
                    AMPERSAND: "Ampersand (&)",
                    SEMICOLON: "Semicolon (;)",
                    LEADING_SLASH: "Starts with a slash (/).",
                    TRAILING_SLASH: "Ends with a slash (/).",
                    DOUBLE_SLASH: "Empty level (//)",
                    TOO_LONG: "Longer than 200 characters",
                    NO_ISSUE: ""
                };
                function explainInvalidEndpointName(name, isTE) {
                    for (i in nameChecks) {
                        const triplet = nameChecks[i];
                        if (isTE && !triplet[3]) continue;
                        if (name.match(triplet[1])) return triplet[2];
                    }
                    return EndpointNameComplaint.NO_ISSUE;
                }
                module.exports.EndpointNameComplaint = Enum.new(EndpointNameComplaint);
                module.exports.explainInvalidEndpointName = explainInvalidEndpointName;
            },
            "./modules/solclient-queue/lib/queue-access-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const QueueAccessType = {
                    EXCLUSIVE: "EXCLUSIVE",
                    NONEXCLUSIVE: "NONEXCLUSIVE"
                };
                module.exports.QueueAccessType = Enum.new(QueueAccessType);
            },
            "./modules/solclient-queue/lib/queue-descriptor-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const APIPropertiesValidators = __webpack_require__("./modules/solclient-util/api.js").APIPropertiesValidators;
                const QueueDescriptor = __webpack_require__("./modules/solclient-queue/lib/queue-descriptor.js").QueueDescriptor;
                const QueueType = __webpack_require__("./modules/solclient-queue/lib/queue-types.js").QueueType;
                const {
                    validateInstance,
                    valBoolean,
                    valIsMember,
                    valTopicString
                } = APIPropertiesValidators;
                const QueueDescriptorValidator = {
                    validate(instance) {
                        const v = validateInstance.bind(null, "QueueDescriptor", instance);
                        if (instance instanceof QueueDescriptor) v("name", [ valTopicString ]);
                        v("type", [ valIsMember, QueueType, "QueueType" ]);
                        v("durable", [ valBoolean ]);
                    }
                };
                module.exports.QueueDescriptorValidator = QueueDescriptorValidator;
            },
            "./modules/solclient-queue/lib/queue-descriptor.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const AbstractQueueDescriptor = __webpack_require__("./modules/solclient-queue/lib/abstract-queue-descriptor.js").AbstractQueueDescriptor;
                const Destination = __webpack_require__("./modules/solclient-destination/api.js").Destination;
                const DEFAULTS = {
                    name: void 0,
                    durable: true
                };
                class QueueDescriptor extends AbstractQueueDescriptor {
                    constructor(queueSpec) {
                        super(queueSpec instanceof Destination ? {
                            name: queueSpec.name,
                            type: queueSpec.type
                        } : Object.assign({}, DEFAULTS, queueSpec));
                    }
                    getName() {
                        return this._name;
                    }
                    get name() {
                        return this.getName();
                    }
                    set name(value) {
                        this._name = value;
                    }
                    ["inspect"]() {
                        return {
                            name: this.name,
                            type: this.type,
                            durable: this.durable
                        };
                    }
                    toString() {
                        return `${super.toString()} '${this.getName() || ""}'`;
                    }
                    static createFromSpec(spec) {
                        if (spec.name) return new QueueDescriptor(spec);
                        return AbstractQueueDescriptor(spec);
                    }
                }
                module.exports.QueueDescriptor = QueueDescriptor;
            },
            "./modules/solclient-queue/lib/queue-discard-behaviors.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const QueueDiscardBehavior = {
                    NOTIFY_SENDER_ON: "NOTIFY_SENDER_ON",
                    NOTIFY_SENDER_OFF: "NOTIFY_SENDER_OFF"
                };
                module.exports.QueueDiscardBehavior = Enum.new(QueueDiscardBehavior);
            },
            "./modules/solclient-queue/lib/queue-permissions.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const QueuePermissions = {
                    NONE: "NONE",
                    READ_ONLY: "READ_ONLY",
                    CONSUME: "CONSUME",
                    MODIFY_TOPIC: "MODIFY_TOPIC",
                    DELETE: "DELETE"
                };
                module.exports.QueuePermissions = Enum.new(QueuePermissions);
            },
            "./modules/solclient-queue/lib/queue-properties-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const APIPropertiesValidators = __webpack_require__("./modules/solclient-util/api.js").APIPropertiesValidators;
                const QueueAccessType = __webpack_require__("./modules/solclient-queue/lib/queue-access-types.js").QueueAccessType;
                const QueueDiscardBehavior = __webpack_require__("./modules/solclient-queue/lib/queue-discard-behaviors.js").QueueDiscardBehavior;
                const QueuePermissions = __webpack_require__("./modules/solclient-queue/lib/queue-permissions.js").QueuePermissions;
                const {
                    validateInstance,
                    valBoolean,
                    valIsMember,
                    valNumber,
                    valRange
                } = APIPropertiesValidators;
                const QueuePropertiesValidator = {
                    validate(instance) {
                        const v = validateInstance.bind(null, "QueueProperties", instance);
                        if (void 0 !== instance.permissions && null !== instance.permissions) v("permissions", [ valIsMember, QueuePermissions, "QueuePermissions" ]);
                        if (void 0 !== instance.accessType && null !== instance.accessType) v("accessType", [ valIsMember, QueueAccessType, "QueueAccessType" ]);
                        if (void 0 !== instance.quotaMB && null !== instance.quotaMB) v("quotaMB", [ valNumber ], [ valRange, 0, 2 ** 32 - 1 ]);
                        if (void 0 !== instance.maxMessageSize && null !== instance.maxMessageSize) v("maxMessageSize", [ valNumber ], [ valRange, 0, 2 ** 32 - 1 ]);
                        if (void 0 !== instance.respectsTTL && null !== instance.respectsTTL) v("respectsTTL", [ valBoolean ]);
                        if (void 0 !== instance.discardBehavior && null !== instance.discardBehavior) v("discardBehavior", [ valIsMember, QueueDiscardBehavior, "QueueDiscardBehavior" ]);
                        if (void 0 !== instance.maxMessageRedelivery && null !== instance.maxMessageRedelivery) v("maxMessageRedelivery", [ valNumber ], [ valRange, 0, 255 ]);
                    }
                };
                module.exports.QueuePropertiesValidator = QueuePropertiesValidator;
            },
            "./modules/solclient-queue/lib/queue-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const APIProperties = __webpack_require__("./modules/solclient-util/api.js").APIProperties;
                const QueueAccessType = __webpack_require__("./modules/solclient-queue/lib/queue-access-types.js").QueueAccessType;
                const QueueDiscardBehavior = __webpack_require__("./modules/solclient-queue/lib/queue-discard-behaviors.js").QueueDiscardBehavior;
                const QueuePermissions = __webpack_require__("./modules/solclient-queue/lib/queue-permissions.js").QueuePermissions;
                const DEFAULTS = {
                    permissions: void 0,
                    accessType: void 0,
                    quotaMB: void 0,
                    maxMessageSize: void 0,
                    respectsTTL: void 0,
                    discardBehavior: void 0,
                    maxMessageRedelivery: void 0
                };
                class QueueProperties extends APIProperties {
                    constructor(options) {
                        super(DEFAULTS, options);
                    }
                    get permissions() {
                        return this._permissions;
                    }
                    set permissions(newValue) {
                        this._permissions = newValue;
                    }
                    get accessType() {
                        return this._accessType || DEFAULTS.accessType;
                    }
                    set accessType(newValue) {
                        this._accessType = newValue;
                    }
                    get quotaMB() {
                        return this._quotaMB;
                    }
                    set quotaMB(newValue) {
                        this._quotaMB = newValue;
                    }
                    get maxMessageSize() {
                        return this._maxMessageSize;
                    }
                    set maxMessageSize(newValue) {
                        this._maxMessageSize = newValue;
                    }
                    get respectsTTL() {
                        return this._respectsTTL;
                    }
                    set respectsTTL(newValue) {
                        this._respectsTTL = newValue;
                    }
                    get discardBehavior() {
                        return this._discardBehavior;
                    }
                    set discardBehavior(newValue) {
                        this._discardBehavior = newValue;
                    }
                    get maxMessageRedelivery() {
                        return this._maxMessageRedelivery;
                    }
                    set maxMessageRedelivery(newValue) {
                        this._maxMessageRedelivery = newValue;
                    }
                    ["inspect"]() {
                        return {
                            permissions: QueuePermissions.describe(this.permissions),
                            accessType: QueueAccessType.describe(this.accessType),
                            quotaMB: this.quotaMB,
                            maxMessageSize: this.maxMessageSize,
                            respectsTTL: this.respectsTTL,
                            discardBehavior: this.discardBehavior ? QueueDiscardBehavior.describe(this.discardBehavior) : void 0,
                            maxMessageRedelivery: this.maxMessageRedelivery
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.QueueProperties = QueueProperties;
            },
            "./modules/solclient-queue/lib/queue-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const QueueType = {
                    QUEUE: "QUEUE",
                    TOPIC_ENDPOINT: "TOPIC_ENDPOINT"
                };
                module.exports.QueueType = Enum.new(QueueType);
            },
            "./modules/solclient-replaystart/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Parameter = __webpack_require__("./modules/solclient-validate/api.js").Parameter;
                const {
                    ReplayStartLocation,
                    ReplayStartType
                } = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocation.js");
                const ReplayStartLocationBeginning = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocationBeginning.js").ReplayStartLocationBeginning;
                const ReplayStartLocationDate = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocationDate.js").ReplayStartLocationDate;
                const SolclientFactory = __webpack_require__("./modules/solclient-factory/api.js").SolclientFactory;
                module.exports.ReplayStartLocation = ReplayStartLocation;
                module.exports.ReplayStartLocationBeginning = ReplayStartLocationBeginning;
                module.exports.ReplayStartLocationDate = ReplayStartLocationDate;
                module.exports.ReplayStartType = ReplayStartType;
                SolclientFactory.createReplayStartLocationBeginning = SolclientFactory.createFactory(() => new ReplayStartLocationBeginning());
                SolclientFactory.createReplayStartLocationDate = SolclientFactory.createFactory(dateTime => ReplayStartLocationDate.createReplayStartLocationDate(Parameter.isInstanceOf("date", dateTime, Date)));
            },
            "./modules/solclient-replaystart/lib/replayStartLocation.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const ReplayStartType = Enum.new({
                    BEGINNING: 0,
                    DATE: 1,
                    RGMID: 2
                });
                class ReplayStartLocation {
                    constructor(spec) {
                        Object.assign(this, spec);
                        if (void 0 === this._type) this._type = ReplayStartType.BEGINNING;
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.ReplayStartLocation = ReplayStartLocation;
                module.exports.ReplayStartType = ReplayStartType;
            },
            "./modules/solclient-replaystart/lib/replayStartLocationBeginning.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ReplayStartLocation,
                    ReplayStartType
                } = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocation.js");
                class ReplayStartLocationBeginning extends ReplayStartLocation {
                    constructor() {
                        super({
                            _type: ReplayStartType.BEGINNING
                        });
                    }
                    static ["inspect"]() {
                        return "BEGINNING";
                    }
                }
                module.exports.ReplayStartLocationBeginning = ReplayStartLocationBeginning;
            },
            "./modules/solclient-replaystart/lib/replayStartLocationDate.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ReplayStartLocation,
                    ReplayStartType
                } = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocation.js");
                class ReplayStartLocationDate extends ReplayStartLocation {
                    constructor(spec) {
                        super({
                            _replayStartValue: spec.getTime(),
                            _type: ReplayStartType.DATE
                        });
                    }
                    ["inspect"]() {
                        return `[Epoch Time: ${this._replayStartValue}]`;
                    }
                    static createReplayStartLocationDate(dateTime) {
                        return new ReplayStartLocationDate(dateTime);
                    }
                }
                module.exports.ReplayStartLocationDate = ReplayStartLocationDate;
            },
            "./modules/solclient-sdt/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Codec = __webpack_require__("./modules/solclient-sdt/lib/codec/api.js").Codec;
                const SDTDestType = __webpack_require__("./modules/solclient-sdt/lib/sdt-destination-types.js").SDTDestType;
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const SDTMapContainer = __webpack_require__("./modules/solclient-sdt/lib/sdt-map-container.js").SDTMapContainer;
                const SDTStreamContainer = __webpack_require__("./modules/solclient-sdt/lib/sdt-stream-container.js").SDTStreamContainer;
                const SDTUnsupportedValueError = __webpack_require__("./modules/solclient-sdt/lib/sdt-unsupported-value-error.js").SDTUnsupportedValueError;
                const SDTValueErrorSubcode = __webpack_require__("./modules/solclient-sdt/lib/sdt-value-error-subcodes.js").SDTValueErrorSubcode;
                module.exports.Codec = Codec;
                module.exports.SDTDestType = SDTDestType;
                module.exports.SDTField = SDTField;
                module.exports.SDTFieldType = SDTFieldType;
                module.exports.SDTMapContainer = SDTMapContainer;
                module.exports.SDTStreamContainer = SDTStreamContainer;
                module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;
                module.exports.SDTValueErrorSubcode = SDTValueErrorSubcode;
            },
            "./modules/solclient-sdt/lib/codec/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const EncodeSingleElement = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-single-element.js").EncodeSingleElement;
                const IEEE754LIB = __webpack_require__("./modules/solclient-sdt/lib/codec/ieee754lib.js").IEEE754LIB;
                const {
                    ParseSingleElement,
                    StringToBuffer
                } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-single-element.js");
                const encodeSingleElement = EncodeSingleElement.encodeSingleElement;
                const parseSingleElement = ParseSingleElement.parseSingleElement;
                const stringToBuffer = StringToBuffer.stringToBuffer;
                const Codec = {
                    encodeSingleElement: encodeSingleElement,
                    parseSingleElement: parseSingleElement,
                    stringToBuffer: stringToBuffer,
                    IEEE754LIB: IEEE754LIB
                };
                module.exports.Codec = Codec;
            },
            "./modules/solclient-sdt/lib/codec/encode-header.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const SDTDataTypes = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js").SDTDataTypes;
                const EncodeHeader = {};
                EncodeHeader.encodeHeader = function(tag, valueLen) {
                    let byte0 = tag << 2 & 255;
                    let strSdtLen = null;
                    if (tag === SDTDataTypes.Map || tag === SDTDataTypes.Stream) {
                        strSdtLen = Convert.int32ToStr(valueLen + 5);
                        byte0 |= 3;
                    } else if (valueLen + 2 <= 255) {
                        strSdtLen = Convert.int8ToStr(valueLen + 2);
                        byte0 |= 0;
                    } else if (valueLen + 3 <= 65535) {
                        strSdtLen = Convert.int16ToStr(valueLen + 3);
                        byte0 |= 1;
                    } else {
                        strSdtLen = Convert.int32ToStr(valueLen + 5);
                        byte0 |= 3;
                    }
                    const ret = Convert.int8ToStr(byte0) + strSdtLen;
                    return ret;
                };
                module.exports.EncodeHeader = EncodeHeader;
            },
            "./modules/solclient-sdt/lib/codec/encode-integer.js": module => {
                const EncodeInteger = {};
                EncodeInteger.int48ToStr = function(vIn) {
                    let v = vIn;
                    const bytes = [];
                    for (let i = 0; i < 6; i++) {
                        const byteI = v % 256;
                        v = Math.floor(v / 256);
                        bytes.push(String.fromCharCode(byteI));
                    }
                    bytes.reverse();
                    return bytes.join("");
                };
                module.exports.EncodeInteger = EncodeInteger;
            },
            "./modules/solclient-sdt/lib/codec/encode-map.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const EncodeSingleElementLib = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-single-element.js");
                const UtilLib = __webpack_require__("./modules/solclient-util/api.js");
                const EncodeHeader = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-header.js").EncodeHeader;
                const SDTDataTypes = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js").SDTDataTypes;
                const SDTMapContainer = __webpack_require__("./modules/solclient-sdt/lib/sdt-map-container.js").SDTMapContainer;
                const encodeHeader = EncodeHeader.encodeHeader;
                const EncodeMap = {
                    encodeMap(sdtmap) {
                        const buf = [];
                        if (!(sdtmap instanceof SDTMapContainer)) return null;
                        const keys = sdtmap.getKeys();
                        let sdtfield = null;
                        let strKeyField = null;
                        let strKeyName = null;
                        let i;
                        for (i = 0; i < keys.length; i++) {
                            sdtfield = sdtmap.getField(keys[i]);
                            if (sdtfield) {
                                strKeyName = UtilLib.StringUtils.nullTerminate(keys[i]);
                                strKeyField = encodeHeader(SDTDataTypes.String, strKeyName.length);
                                strKeyField += strKeyName;
                                buf.push(strKeyField);
                                EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
                            }
                        }
                        return buf.join("");
                    }
                };
                module.exports.EncodeMap = EncodeMap;
            },
            "./modules/solclient-sdt/lib/codec/encode-single-element.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationLib = __webpack_require__("./modules/solclient-destination/api.js");
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const EncodeHeader = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-header.js").EncodeHeader;
                const EncodeInteger = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-integer.js").EncodeInteger;
                const EncodeMap = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-map.js").EncodeMap;
                const EncodeStream = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-stream.js").EncodeStream;
                const IEEE754LIB = __webpack_require__("./modules/solclient-sdt/lib/codec/ieee754lib.js").IEEE754LIB;
                const SDTDataTypes = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js").SDTDataTypes;
                const SDTDestType = __webpack_require__("./modules/solclient-sdt/lib/sdt-destination-types.js").SDTDestType;
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const StringUtils = __webpack_require__("./modules/solclient-util/api.js").StringUtils;
                const encodeHeader = EncodeHeader.encodeHeader;
                const int48ToStr = EncodeInteger.int48ToStr;
                const encodeMap = EncodeMap.encodeMap;
                const encodeStream = EncodeStream.encodeStream;
                const nullTerminate = StringUtils.nullTerminate;
                const C_2_48 = Math.pow(2, 48);
                function strencode(data) {
                    return unescape(encodeURIComponent(data));
                }
                function encodeSingleElementToBuf(sdtfield, buf) {
                    if (!(sdtfield instanceof SDTField)) return false;
                    const value = sdtfield.getValue();
                    let fieldVal = null;
                    let tag = 0;
                    switch (sdtfield.getType()) {
                      case SDTFieldType.BOOL:
                        tag = SDTDataTypes.Boolean;
                        fieldVal = Convert.int8ToStr(value ? 1 : 0);
                        break;

                      case SDTFieldType.UINT8:
                        tag = SDTDataTypes.UnsignedInteger;
                        fieldVal = Convert.int8ToStr(value);
                        break;

                      case SDTFieldType.INT8:
                        tag = SDTDataTypes.Integer;
                        fieldVal = Convert.int8ToStr(value);
                        break;

                      case SDTFieldType.UINT16:
                        tag = SDTDataTypes.UnsignedInteger;
                        fieldVal = Convert.int16ToStr(value);
                        break;

                      case SDTFieldType.INT16:
                        tag = SDTDataTypes.Integer;
                        fieldVal = Convert.int16ToStr(value);
                        break;

                      case SDTFieldType.UINT32:
                        tag = SDTDataTypes.UnsignedInteger;
                        fieldVal = Convert.int32ToStr(value);
                        break;

                      case SDTFieldType.INT32:
                        tag = SDTDataTypes.Integer;
                        fieldVal = Convert.int32ToStr(value);
                        break;

                      case SDTFieldType.UINT64:
                        tag = SDTDataTypes.UnsignedInteger;
                        fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
                        break;

                      case SDTFieldType.INT64:
                        tag = SDTDataTypes.Integer;
                        if (value >= 0) fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value); else fieldVal = String.fromCharCode(255) + String.fromCharCode(255) + int48ToStr(C_2_48 + value);
                        break;

                      case SDTFieldType.WCHAR:
                        tag = SDTDataTypes.Char;
                        fieldVal = Convert.int16ToStr(value.charCodeAt(0));
                        break;

                      case SDTFieldType.STRING:
                        tag = SDTDataTypes.String;
                        fieldVal = nullTerminate(strencode(value));
                        break;

                      case SDTFieldType.BYTEARRAY:
                        tag = SDTDataTypes.ByteArray;
                        fieldVal = value.toString("latin1");
                        break;

                      case SDTFieldType.FLOATTYPE:
                        tag = SDTDataTypes.Float;
                        fieldVal = IEEE754LIB.toIEEE754Single(value);
                        break;

                      case SDTFieldType.DOUBLETYPE:
                        tag = SDTDataTypes.Float;
                        fieldVal = IEEE754LIB.toIEEE754Double(value);
                        break;

                      case SDTFieldType.MAP:
                        tag = SDTDataTypes.Map;
                        fieldVal = encodeMap(value);
                        break;

                      case SDTFieldType.STREAM:
                        tag = SDTDataTypes.Stream;
                        fieldVal = encodeStream(value);
                        break;

                      case SDTFieldType.DESTINATION:
                        tag = SDTDataTypes.Destination;
                        if (value instanceof DestinationLib.Destination) fieldVal = Convert.int8ToStr(SDTDestType[value.getType()]) + value.getBytes();
                        break;

                      case SDTFieldType.NULLTYPE:
                        tag = SDTDataTypes.Null;
                        fieldVal = "";
                        break;

                      case SDTFieldType.UNKNOWN:
                        fieldVal = null;
                        break;

                      default:
                    }
                    if (null !== fieldVal) {
                        const hdr = encodeHeader(tag, fieldVal.length);
                        buf.push(hdr);
                        buf.push(fieldVal);
                        return true;
                    }
                    return false;
                }
                function encodeSingleElement(sdtfield) {
                    const buf = [];
                    encodeSingleElementToBuf(sdtfield, buf);
                    return buf.join("");
                }
                const EncodeSingleElement = {
                    encodeSingleElement: encodeSingleElement,
                    encodeSingleElementToBuf: encodeSingleElementToBuf
                };
                module.exports.EncodeSingleElement = EncodeSingleElement;
            },
            "./modules/solclient-sdt/lib/codec/encode-stream.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const EncodeSingleElementLib = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-single-element.js");
                const SDTStreamContainer = __webpack_require__("./modules/solclient-sdt/lib/sdt-stream-container.js").SDTStreamContainer;
                const EncodeStream = {};
                EncodeStream.encodeStream = function(sdtstream) {
                    const buf = [];
                    if (!(sdtstream instanceof SDTStreamContainer)) return null;
                    let sdtfield = null;
                    sdtstream.rewind();
                    while (sdtstream.hasNext()) {
                        sdtfield = sdtstream.getNext();
                        if (sdtfield) EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
                    }
                    sdtstream.rewind();
                    return buf.join("");
                };
                module.exports.EncodeStream = EncodeStream;
            },
            "./modules/solclient-sdt/lib/codec/ieee754lib.js": module => {
                const IEEE754LIB = {
                    toIEEE754(vIn, ebits, fbits) {
                        let v = vIn;
                        const bias = (1 << ebits - 1) - 1;
                        let s;
                        let e;
                        let f;
                        if (isNaN(v)) {
                            e = (1 << bias) - 1;
                            f = 1;
                            s = 0;
                        } else if (v === 1 / 0 || v === -(1 / 0)) {
                            e = (1 << bias) - 1;
                            f = 0;
                            s = v < 0 ? 1 : 0;
                        } else if (0 === v) {
                            e = 0;
                            f = 0;
                            s = 1 / v === -(1 / 0) ? 1 : 0;
                        } else {
                            s = v < 0;
                            v = Math.abs(v);
                            if (v >= Math.pow(2, 1 - bias)) {
                                const ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
                                e = ln + bias;
                                f = v * Math.pow(2, fbits - ln) - Math.pow(2, fbits);
                            } else {
                                e = 0;
                                f = v / Math.pow(2, 1 - bias - fbits);
                            }
                        }
                        const bits = [];
                        for (let i = fbits; i; --i) {
                            bits.push(f % 2 ? 1 : 0);
                            f = Math.floor(f / 2);
                        }
                        for (let i = ebits; i; --i) {
                            bits.push(e % 2 ? 1 : 0);
                            e = Math.floor(e / 2);
                        }
                        bits.push(s ? 1 : 0);
                        bits.reverse();
                        let str = bits.join("");
                        const bytes = [];
                        while (str.length) {
                            bytes.push(parseInt(str.substring(0, 8), 2));
                            str = str.substring(8);
                        }
                        return bytes;
                    },
                    fromIEEE754(bytes, ebits, fbits) {
                        const bits = [];
                        for (let i = bytes.length; i; --i) {
                            let byteI = bytes[i - 1];
                            for (let j = 8; j; --j) {
                                bits.push(byteI % 2 ? 1 : 0);
                                byteI >>= 1;
                            }
                        }
                        bits.reverse();
                        const str = bits.join("");
                        const bias = (1 << ebits - 1) - 1;
                        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
                        const e = parseInt(str.substring(1, 1 + ebits), 2);
                        const f = parseInt(str.substring(1 + ebits), 2);
                        if (e === (1 << ebits) - 1) return 0 !== f ? NaN : s * (1 / 0);
                        if (e > 0) return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
                        if (0 !== f) return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));
                        return 0;
                    },
                    strToByteArr(str) {
                        const bytes = [];
                        for (let i = 0; i < str.length; i++) bytes.push(255 & str.charCodeAt(i));
                        return bytes;
                    },
                    byteArrToStr(bytes) {
                        const str = [];
                        for (let i = 0; i < bytes.length; i++) str.push(String.fromCharCode(255 & bytes[i]));
                        return str.join("");
                    },
                    fromIEEE754Double(b) {
                        return this.fromIEEE754(this.strToByteArr(b), 11, 52);
                    },
                    toIEEE754Double(v) {
                        return this.byteArrToStr(this.toIEEE754(v, 11, 52));
                    },
                    fromIEEE754Single(b) {
                        return this.fromIEEE754(this.strToByteArr(b), 8, 23);
                    },
                    toIEEE754Single(v) {
                        return this.byteArrToStr(this.toIEEE754(v, 8, 23));
                    }
                };
                module.exports.IEEE754LIB = IEEE754LIB;
            },
            "./modules/solclient-sdt/lib/codec/parse-destination.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    DestinationFromNetwork,
                    DestinationType,
                    Queue
                } = __webpack_require__("./modules/solclient-destination/api.js");
                const LOG_INFO = __webpack_require__("./modules/solclient-log/api.js").LOG_INFO;
                const SDTDestType = __webpack_require__("./modules/solclient-sdt/lib/sdt-destination-types.js").SDTDestType;
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const Topic = __webpack_require__("./modules/solclient-destination/api.js").Topic;
                const ParseDestination = {};
                ParseDestination.parseDestination = function(dataBuf, pos, len) {
                    const destType = dataBuf.readUInt8(pos);
                    const destBytes = dataBuf.toString("latin1", pos + 1, pos + len);
                    let destination = DestinationFromNetwork.createDestinationFromBytes(destBytes);
                    if (SDTDestType[destination.type] !== destType) if (SDTDestType[DestinationType.QUEUE] === destType) destination = Queue.createFromLocalName(destBytes); else if (SDTDestType[DestinationType.TOPIC] === destType) {
                        destType, destBytes, destination.type;
                        destination = new Topic(destBytes);
                    } else {
                        LOG_INFO(`Drop SDT field with invalid destination type ${destType} when decoding ${destBytes} to ` + destination.type);
                        return null;
                    }
                    return SDTField.create(SDTFieldType.DESTINATION, destination);
                };
                module.exports.ParseDestination = ParseDestination;
            },
            "./modules/solclient-sdt/lib/codec/parse-field-header.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ParseInteger = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-integer.js").ParseInteger;
                const autoDecodeVarLengthNumber = ParseInteger.autoDecodeVarLengthNumber;
                const ParseFieldHeader = {};
                ParseFieldHeader.parseFieldHeader = function(dataBuf, offset) {
                    let pos = offset;
                    const onebyte = dataBuf.readUInt8(pos);
                    const elemType = (252 & onebyte) >> 2;
                    const lenBytes = (3 & onebyte) + 1;
                    pos++;
                    const elemLen = autoDecodeVarLengthNumber(dataBuf, pos, lenBytes);
                    pos += lenBytes;
                    const elemValLen = elemLen - (1 + lenBytes);
                    return [ elemType, elemLen, elemValLen, pos - offset ];
                };
                module.exports.ParseFieldHeader = ParseFieldHeader;
            },
            "./modules/solclient-sdt/lib/codec/parse-float.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const ParseFloat = {};
                ParseFloat.parseFloatField = function(buf, pos, len) {
                    switch (len) {
                      case 4:
                        return SDTField.create(SDTFieldType.FLOATTYPE, buf.readFloatBE(pos));

                      case 8:
                        return SDTField.create(SDTFieldType.DOUBLETYPE, buf.readDoubleBE(pos));

                      default:
                        return SDTField.create(SDTFieldType.UNKNOWN, buf.toString("latin1", pos, pos + len));
                    }
                };
                module.exports.ParseFloat = ParseFloat;
            },
            "./modules/solclient-sdt/lib/codec/parse-integer.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Long = __webpack_require__("./node_modules/long/umd/index.js");
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const SDTUnsupportedValueError = __webpack_require__("./modules/solclient-sdt/lib/sdt-unsupported-value-error.js").SDTUnsupportedValueError;
                const SDTValueErrorSubcode = __webpack_require__("./modules/solclient-sdt/lib/sdt-value-error-subcodes.js").SDTValueErrorSubcode;
                const createField = SDTField.create;
                const ParseInteger = {};
                ParseInteger.autoDecodeVarLengthNumber = function(dataBuf, pos, len) {
                    if ([ 1, 2, 3, 4 ].includes(len)) return dataBuf.readUIntBE(pos, len);
                    return false;
                };
                ParseInteger.parseIntegerField = function(isSigned, dataBuf, pos, len) {
                    let val = 0;
                    switch (len) {
                      case 1:
                        if (isSigned) {
                            val = dataBuf.readInt8(pos);
                            return createField(SDTFieldType.INT8, val);
                        }
                        val = dataBuf.readUInt8(pos);
                        return createField(SDTFieldType.UINT8, val);

                      case 2:
                        if (isSigned) {
                            val = dataBuf.readInt16BE(pos);
                            return createField(SDTFieldType.INT16, val);
                        }
                        val = dataBuf.readUInt16BE(pos);
                        return createField(SDTFieldType.UINT16, val);

                      case 4:
                        if (isSigned) {
                            val = dataBuf.readInt32BE(pos);
                            return createField(SDTFieldType.INT32, val);
                        }
                        val = dataBuf.readUInt32BE(pos);
                        return createField(SDTFieldType.UINT32, val);

                      case 8:
                        {
                            let error = null;
                            const longValue = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), !isSigned);
                            if (longValue.getNumBitsAbs() > 48) error = new SDTUnsupportedValueError("Value is not supported", SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE, dataBuf.toString("latin1", pos, len));
                            val = longValue.toNumber();
                            const field = createField(isSigned ? SDTFieldType.INT64 : SDTFieldType.UINT64, val);
                            if (error) field.setError(error);
                            return field;
                        }

                      default:
                        return null;
                    }
                };
                module.exports.ParseInteger = ParseInteger;
            },
            "./modules/solclient-sdt/lib/codec/parse-map.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ParseSingleElementLib = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-single-element.js");
                const LOG_ERROR = __webpack_require__("./modules/solclient-log/api.js").LOG_ERROR;
                const ParseFieldHeader = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-field-header.js").ParseFieldHeader;
                const SDTDataTypes = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js").SDTDataTypes;
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const SDTMapContainer = __webpack_require__("./modules/solclient-sdt/lib/sdt-map-container.js").SDTMapContainer;
                const ParseMap = {};
                ParseMap.parseMapAt = function(dataBuf, offset, datalen) {
                    const mapObj = new SDTMapContainer();
                    let pos = offset;
                    while (pos < offset + datalen) {
                        const keyFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                        pos += keyFieldHeader[3];
                        if (keyFieldHeader[0] !== SDTDataTypes.String) {
                            LOG_ERROR("Error parsing SDTMAP, expected to find a string field as map key, and didn't");
                            LOG_ERROR(`Type of key: ` + keyFieldHeader[0]);
                            return SDTField.create(SDTFieldType.MAP, null);
                        }
                        const keyString = dataBuf.toString("latin1", pos, pos + keyFieldHeader[2] - 1);
                        pos += keyFieldHeader[2];
                        const valueFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                        const valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(dataBuf, pos);
                        pos += valueFieldHeader[1];
                        if (valueField) mapObj.addField(keyString, valueField);
                    }
                    return SDTField.create(SDTFieldType.MAP, mapObj);
                };
                module.exports.ParseMap = ParseMap;
            },
            "./modules/solclient-sdt/lib/codec/parse-single-element.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const ParseDestination = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-destination.js").ParseDestination;
                const ParseFieldHeader = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-field-header.js").ParseFieldHeader;
                const ParseFloat = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-float.js").ParseFloat;
                const ParseInteger = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-integer.js").ParseInteger;
                const ParseMap = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-map.js").ParseMap;
                const ParseStream = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-stream.js").ParseStream;
                const SDTDataTypes = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js").SDTDataTypes;
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const utf8ToUcs2 = Convert.utf8ToUcs2;
                const parseFieldHeader = ParseFieldHeader.parseFieldHeader;
                const parseFloatField = ParseFloat.parseFloatField;
                const parseIntegerField = ParseInteger.parseIntegerField;
                const parseMapAt = ParseMap.parseMapAt;
                const parseStreamAt = ParseStream.parseStreamAt;
                const parseDestination = ParseDestination.parseDestination;
                const ParseSingleElement = {
                    parseSingleElement(dataBuf, offset) {
                        const fieldHeader = parseFieldHeader(dataBuf, offset);
                        if (!fieldHeader) {
                            fieldHeader;
                            return null;
                        }
                        const pos = offset + fieldHeader[3];
                        const elemValLen = fieldHeader[2];
                        switch (fieldHeader[0]) {
                          case SDTDataTypes.Null:
                            return SDTField.create(SDTFieldType.NULLTYPE, null);

                          case SDTDataTypes.Boolean:
                            return SDTField.create(SDTFieldType.BOOL, 0 !== dataBuf.readUInt8(pos));

                          case SDTDataTypes.Integer:
                            return parseIntegerField(true, dataBuf, pos, elemValLen);

                          case SDTDataTypes.UnsignedInteger:
                            return parseIntegerField(false, dataBuf, pos, elemValLen);

                          case SDTDataTypes.Float:
                            return parseFloatField(dataBuf, pos, elemValLen);

                          case SDTDataTypes.Char:
                            return SDTField.create(SDTFieldType.WCHAR, String.fromCharCode(dataBuf.readUInt16BE(pos)));

                          case SDTDataTypes.ByteArray:
                            return SDTField.create(SDTFieldType.BYTEARRAY, dataBuf.slice(pos, pos + elemValLen));

                          case SDTDataTypes.String:
                            return SDTField.create(SDTFieldType.STRING, utf8ToUcs2(dataBuf.toString("latin1", pos, pos + elemValLen - 1)));

                          case SDTDataTypes.Destination:
                            return parseDestination(dataBuf, pos, elemValLen);

                          case SDTDataTypes.SMFMessage:
                            return SDTField.create(SDTFieldType.SMF_MESSAGE, dataBuf.slice(pos, pos + elemValLen));

                          case SDTDataTypes.Map:
                            return parseMapAt(dataBuf, pos, elemValLen);

                          case SDTDataTypes.Stream:
                            return parseStreamAt(dataBuf, pos, elemValLen);

                          default:
                            return SDTField.create(SDTFieldType.UNKNOWN, dataBuf.toString("latin1", pos, pos + elemValLen));
                        }
                    }
                };
                const StringToBuffer = {
                    stringToBuffer(str) {
                        const BufferImpl = __webpack_require__("./node_modules/buffer/index.js").Buffer;
                        return BufferImpl.from(str, "latin1");
                    }
                };
                module.exports.ParseSingleElement = ParseSingleElement;
                module.exports.StringToBuffer = StringToBuffer;
            },
            "./modules/solclient-sdt/lib/codec/parse-stream.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ParseSingleElementLib = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-single-element.js");
                const ParseFieldHeader = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-field-header.js").ParseFieldHeader;
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const SDTStreamContainer = __webpack_require__("./modules/solclient-sdt/lib/sdt-stream-container.js").SDTStreamContainer;
                const ParseStream = {};
                ParseStream.parseStreamAt = function(dataBuf, offset, datalen) {
                    const streamObj = new SDTStreamContainer();
                    let pos = offset;
                    while (pos < offset + datalen) {
                        const valueFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                        const valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(dataBuf, pos);
                        pos += valueFieldHeader[1];
                        if (valueField) streamObj.addField(valueField);
                    }
                    return SDTField.create(SDTFieldType.STREAM, streamObj);
                };
                module.exports.ParseStream = ParseStream;
            },
            "./modules/solclient-sdt/lib/sdt-data-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SDTDataTypes = {
                    Null: 0,
                    Boolean: 1,
                    Integer: 2,
                    UnsignedInteger: 3,
                    Float: 4,
                    Char: 5,
                    ByteArray: 6,
                    String: 7,
                    Destination: 8,
                    SMFMessage: 9,
                    Map: 10,
                    Stream: 11
                };
                module.exports.SDTDataTypes = Enum.new(SDTDataTypes);
            },
            "./modules/solclient-sdt/lib/sdt-destination-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationType = __webpack_require__("./modules/solclient-destination/api.js").DestinationType;
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SDTDestType = {
                    [DestinationType.TOPIC]: 0,
                    [DestinationType.QUEUE]: 1,
                    [DestinationType.TEMPORARY_QUEUE]: 1
                };
                module.exports.SDTDestType = Enum.new(SDTDestType);
            },
            "./modules/solclient-sdt/lib/sdt-field-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SDTFieldType = {
                    BOOL: 0,
                    UINT8: 1,
                    INT8: 2,
                    UINT16: 3,
                    INT16: 4,
                    UINT32: 5,
                    INT32: 6,
                    UINT64: 7,
                    INT64: 8,
                    WCHAR: 9,
                    STRING: 10,
                    BYTEARRAY: 11,
                    FLOATTYPE: 12,
                    DOUBLETYPE: 13,
                    MAP: 14,
                    STREAM: 15,
                    DESTINATION: 16,
                    NULLTYPE: 17,
                    UNKNOWN: 18,
                    SMF_MESSAGE: 19
                };
                module.exports.SDTFieldType = Enum.new(SDTFieldType);
            },
            "./modules/solclient-sdt/lib/sdt-field.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const validateSdtField = __webpack_require__("./modules/solclient-sdt/lib/validate-sdt-field.js").validateSdtField;
                const anythingToBuffer = Convert.anythingToBuffer;
                const ProfileBinding = SolclientFactoryLib.ProfileBinding;
                class SDTField {
                    constructor(type = SDTFieldType.NULLTYPE, value = null) {
                        const err = validateSdtField(type, value);
                        if (null !== err) throw err;
                        this._type = type;
                        if (type === SDTFieldType.BYTEARRAY) this._value = anythingToBuffer(value); else this._value = value;
                        this._error = void 0;
                    }
                    getType() {
                        return this._type;
                    }
                    getValue() {
                        if (void 0 !== this._error) throw this._error;
                        return this.getValueNoThrow();
                    }
                    getValueNoThrow() {
                        if (void 0 !== this._error) return this._error;
                        if (this._type === SDTFieldType.BYTEARRAY && ProfileBinding.value.byteArrayAsString) return this._value.toString("latin1");
                        return this._value;
                    }
                    setError(err) {
                        this._error = err;
                    }
                    toString() {
                        return `[SDTField type:${this._type} value:${this._value}]`;
                    }
                    static create(type, value) {
                        return new SDTField(type, value);
                    }
                }
                module.exports.SDTField = SDTField;
            },
            "./modules/solclient-sdt/lib/sdt-map-container.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const SDTField = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js").SDTField;
                class SDTMapContainer {
                    constructor() {
                        this._map = [];
                    }
                    getKeys() {
                        return Object.keys(this._map);
                    }
                    getField(key) {
                        return this._map[key];
                    }
                    deleteField(key) {
                        delete this._map[key];
                    }
                    addField(key, typeOrField, value = void 0) {
                        if (typeOrField instanceof SDTField) {
                            this._map[key] = typeOrField;
                            return;
                        } else if ("undefined" !== typeof value) {
                            this._map[key] = SDTField.create(typeOrField, value);
                            return;
                        }
                        throw new OperationError("Invalid parameters to addField: expected SDTField, or type and value", ErrorSubcode.PARAMETER_CONFLICT);
                    }
                }
                module.exports.SDTMapContainer = SDTMapContainer;
            },
            "./modules/solclient-sdt/lib/sdt-stream-container.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SDTFieldLib = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                class SDTStreamContainer {
                    constructor() {
                        this._stream = [];
                        this._writable = true;
                        this._readPt = 0;
                    }
                    hasNext() {
                        return this._stream.length > this._readPt;
                    }
                    getNext() {
                        return this._readPt < this._stream.length ? this._stream[this._readPt++] : void 0;
                    }
                    rewind() {
                        this._readPt = 0;
                    }
                    addField(typeOrField, value = void 0) {
                        if (!this._writable) return;
                        if (typeOrField instanceof SDTFieldLib.SDTField) {
                            this._stream.push(typeOrField);
                            return;
                        }
                        if ("undefined" !== typeof value) {
                            this._stream.push(SDTFieldLib.SDTField.create(typeOrField, value));
                            return;
                        }
                        throw new OperationError("Invalid parameters to addField: expected SDTField, or type and value", ErrorSubcode.PARAMETER_CONFLICT);
                    }
                }
                module.exports.SDTStreamContainer = SDTStreamContainer;
            },
            "./modules/solclient-sdt/lib/sdt-unsupported-value-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
                const SolaceError = __webpack_require__("./modules/solclient-error/api.js").SolaceError;
                class SDTUnsupportedValueError extends SolaceError {
                    constructor(message, subcode, sourceData) {
                        super("SDTUnsupportedValue", message);
                        this.subcode = subcode;
                        this.sourceData = sourceData || "";
                    }
                    inspect() {
                        return super.inspect({
                            subcode: null,
                            sourceData: v => DebugLib.Debug.formatDumpBytes(v, false, 0)
                        });
                    }
                    getSubcode() {
                        return this.subcode;
                    }
                    getSourceData() {
                        return this.sourceData;
                    }
                }
                module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;
            },
            "./modules/solclient-sdt/lib/sdt-value-error-subcodes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SDTValueErrorSubcode = {
                    VALUE_OUTSIDE_SUPPORTED_RANGE: 1
                };
                module.exports.SDTValueErrorSubcode = Enum.new(SDTValueErrorSubcode);
            },
            "./modules/solclient-sdt/lib/validate-sdt-field.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationLib = __webpack_require__("./modules/solclient-destination/api.js");
                const SDTMapContainerLib = __webpack_require__("./modules/solclient-sdt/lib/sdt-map-container.js");
                const SDTStreamContainerLib = __webpack_require__("./modules/solclient-sdt/lib/sdt-stream-container.js");
                const ValidateLib = __webpack_require__("./modules/solclient-validate/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const SDTFieldType = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js").SDTFieldType;
                const baseTypes = (() => {
                    const result = [];
                    result[SDTFieldType.BOOL] = "boolean";
                    result[SDTFieldType.UINT8] = "number";
                    result[SDTFieldType.INT8] = "number";
                    result[SDTFieldType.UINT16] = "number";
                    result[SDTFieldType.INT16] = "number";
                    result[SDTFieldType.UINT32] = "number";
                    result[SDTFieldType.INT32] = "number";
                    result[SDTFieldType.UINT64] = "number";
                    result[SDTFieldType.INT64] = "number";
                    result[SDTFieldType.WCHAR] = "string";
                    result[SDTFieldType.STRING] = "string";
                    result[SDTFieldType.BYTEARRAY] = "object";
                    result[SDTFieldType.FLOATTYPE] = "number";
                    result[SDTFieldType.DOUBLETYPE] = "number";
                    return result;
                })();
                function failInvalidParameter(valueType) {
                    return new OperationError(`Invalid SDT type:value combination, expected value type ` + valueType, ErrorSubcode.PARAMETER_INVALID_TYPE);
                }
                function validateSdtField(type, value) {
                    if (baseTypes[type]) if ("boolean" === baseTypes[type] && "boolean" !== typeof value || "number" === baseTypes[type] && "number" !== typeof value || "string" === baseTypes[type] && "string" !== typeof value) return failInvalidParameter(baseTypes[type]);
                    if (type === SDTFieldType.MAP && !ValidateLib.Check.instanceOf(value, SDTMapContainerLib.SDTMapContainer)) return failInvalidParameter("SDTMapContainer");
                    if (type === SDTFieldType.STREAM && !ValidateLib.Check.instanceOf(value, SDTStreamContainerLib.SDTStreamContainer)) return failInvalidParameter("SDTStreamContainer");
                    if (type === SDTFieldType.DESTINATION && !ValidateLib.Check.instanceOf(value, DestinationLib.Destination)) return failInvalidParameter("Destination");
                    return null;
                }
                module.exports.validateSdtField = validateSdtField;
            },
            "./modules/solclient-session/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const AuthenticationScheme = __webpack_require__("./modules/solclient-session/lib/authentication-schemes.js").AuthenticationScheme;
                const {
                    CapabilityType,
                    ClientCapabilityType
                } = __webpack_require__("./modules/solclient-session/lib/capability-types.js");
                const MessageRxCBInfo = __webpack_require__("./modules/solclient-session/lib/message-rx-cb-info.js").MessageRxCBInfo;
                const MutableSessionProperty = __webpack_require__("./modules/solclient-session/lib/mutable-session-properties.js").MutableSessionProperty;
                const Session = __webpack_require__("./modules/solclient-session/lib/session.js").Session;
                const SessionEvent = __webpack_require__("./modules/solclient-session/lib/session-event.js").SessionEvent;
                const ProvisionEvent = __webpack_require__("./modules/solclient-session/lib/provision-event.js").ProvisionEvent;
                const SessionEventCBInfo = __webpack_require__("./modules/solclient-session/lib/session-event-cb-info.js").SessionEventCBInfo;
                const SessionEventCode = __webpack_require__("./modules/solclient-session/lib/session-event-codes.js").SessionEventCode;
                const SessionEventName = __webpack_require__("./modules/solclient-session/lib/session-event-names.js").SessionEventName;
                const SessionProperties = __webpack_require__("./modules/solclient-session/lib/session-properties.js").SessionProperties;
                const SessionState = __webpack_require__("./modules/solclient-session/lib/session-states.js").SessionState;
                const SolclientFactory = __webpack_require__("./modules/solclient-factory/api.js").SolclientFactory;
                const SslDowngrade = __webpack_require__("./modules/solclient-session/lib/ssl-downgrades.js").SslDowngrade;
                SolclientFactory.createSession = SolclientFactory.createFactory((sessionProperties, messageCallbackInfo, eventCallbackInfo) => new Session(sessionProperties, messageCallbackInfo, eventCallbackInfo));
                module.exports.AuthenticationScheme = AuthenticationScheme;
                module.exports.CapabilityType = CapabilityType;
                module.exports.ClientCapabilityType = ClientCapabilityType;
                module.exports.MessageRxCBInfo = MessageRxCBInfo;
                module.exports.MutableSessionProperty = MutableSessionProperty;
                module.exports.Session = Session;
                module.exports.SessionEventCBInfo = SessionEventCBInfo;
                module.exports.SessionEventCode = SessionEventCode;
                module.exports.SessionEvent = SessionEvent;
                module.exports.ProvisionEvent = ProvisionEvent;
                module.exports.SessionEventName = SessionEventName;
                module.exports.SessionProperties = SessionProperties;
                module.exports.SessionState = SessionState;
                module.exports.SslDowngrade = SslDowngrade;
            },
            "./modules/solclient-session/lib/authentication-schemes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const AuthenticationScheme = {
                    BASIC: "AuthenticationScheme_basic",
                    CLIENT_CERTIFICATE: "AuthenticationScheme_clientCertificate",
                    AUTHENTICATION_SCHEME_BASIC: "AuthenticationScheme_basic",
                    AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE: "AuthenticationScheme_clientCertificate",
                    OAUTH2: "AuthenticationScheme_oauth2"
                };
                module.exports.AuthenticationScheme = Enum.new(AuthenticationScheme);
            },
            "./modules/solclient-session/lib/capability-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const CapabilityType = {
                    PEER_SOFTWARE_VERSION: 0,
                    PEER_SOFTWARE_DATE: 1,
                    PEER_PLATFORM: 2,
                    PEER_PORT_SPEED: 3,
                    PEER_PORT_TYPE: 4,
                    MAX_DIRECT_MSG_SIZE: 5,
                    PEER_ROUTER_NAME: 6,
                    MESSAGE_ELIDING: 7,
                    NO_LOCAL: 8,
                    GUARANTEED_MESSAGE_CONSUME: 9,
                    TEMPORARY_ENDPOINT: 10,
                    GUARANTEED_MESSAGE_PUBLISH: 11,
                    GUARANTEED_MESSAGE_BROWSE: 12,
                    ENDPOINT_MGMT: 13,
                    SELECTOR: 14,
                    MAX_GUARANTEED_MSG_SIZE: 15,
                    ACTIVE_CONSUMER_INDICATION: 16,
                    COMPRESSION: 17,
                    CUT_THROUGH: 18,
                    ENDPOINT_DISCARD_BEHAVIOR: 19,
                    ENDPOINT_MESSAGE_TTL: 20,
                    JNDI: 21,
                    PER_TOPIC_SEQUENCE_NUMBERING: 22,
                    QUEUE_SUBSCRIPTIONS: 23,
                    SUBSCRIPTION_MANAGER: 24,
                    TRANSACTED_SESSION: 25,
                    MESSAGE_REPLAY: 26,
                    COMPRESSED_SSL: 27,
                    SHARED_SUBSCRIPTIONS: 28,
                    BR_REPLAY_ERRORID: 29,
                    AD_APP_ACK_FAILED: 30,
                    VAR_LEN_EXT_PARAM: 31
                };
                const ClientCapabilityType = {
                    UNBIND_ACK: 0,
                    BR_ERRORID: 1,
                    PQ: 2
                };
                module.exports.CapabilityType = Enum.new(CapabilityType);
                module.exports.ClientCapabilityType = Enum.new(ClientCapabilityType);
            },
            "./modules/solclient-session/lib/correlated-request.js": module => {
                class CorrelatedRequest {
                    constructor(correlationTag, timer, correlationKey, respRecvdCallback) {
                        this.correlationTag = correlationTag;
                        this.timer = timer;
                        this.correlationKey = correlationKey;
                        this.respRecvdCallback = respRecvdCallback;
                    }
                }
                module.exports.CorrelatedRequest = CorrelatedRequest;
            },
            "./modules/solclient-session/lib/default-capabilities.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const CapabilityType = __webpack_require__("./modules/solclient-session/lib/capability-types.js").CapabilityType;
                module.exports.DefaultCapabilities = {
                    createDefaultCapabilities(sessionProperties) {
                        const defaultCapabilities = {
                            [CapabilityType.GUARANTEED_MESSAGE_CONSUME]: true,
                            [CapabilityType.GUARANTEED_MESSAGE_PUBLISH]: true,
                            [CapabilityType.SHARED_SUBSCRIPTIONS]: true,
                            [CapabilityType.MAX_GUARANTEED_MSG_SIZE]: sessionProperties.assumedMaxAdSize,
                            [CapabilityType.AD_APP_ACK_FAILED]: true
                        };
                        return defaultCapabilities;
                    }
                };
            },
            "./modules/solclient-session/lib/global-context.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Process = __webpack_require__("./modules/solclient-util/api.js").Process;
                const C_2_32 = Math.pow(2, 32);
                function leftPad(str, len) {
                    if (len > str.length) return "0".repeat(len - str.length) + str;
                    return str;
                }
                function generateRandomId() {
                    const rand = (Math.random() * C_2_32).toFixed(0);
                    return leftPad(rand.toString(), 10);
                }
                const GlobalContext = {
                    sessionCounter: 0,
                    idCounter: 0,
                    RandId: generateRandomId(),
                    NextSessionCounter() {
                        const count = ++this.sessionCounter;
                        return leftPad(count.toString(), 4);
                    },
                    NextId() {
                        return ++this.idCounter;
                    },
                    GenerateClientName() {
                        const {
                            product,
                            platform
                        } = Process;
                        const result = `${product}/${platform}/${this.RandId}/` + this.NextSessionCounter();
                        return result;
                    },
                    GenerateUserIdentification() {
                        const {
                            product,
                            platform
                        } = Process;
                        return `${product}/${platform}/` + this.RandId;
                    },
                    GenerateClientDescription() {
                        return (`solclientjs/` + Process.description).substring(0, 254);
                    }
                };
                module.exports.GlobalContext = GlobalContext;
            },
            "./modules/solclient-session/lib/host-list-dns-filter.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const parseURL = __webpack_require__("./modules/solclient-util/api.js").parseURL;
                let hostListDNSFilter;
                if (false); else hostListDNSFilter = (urls, cb) => setTimeout(() => {
                    try {
                        const result = urls.map(url => {
                            const host = parseURL(url).host;
                            return {
                                url: url,
                                host: host,
                                address: host,
                                resolved: false
                            };
                        });
                        return cb(null, result);
                    } catch (e) {
                        return cb(e);
                    }
                }, 0);
                module.exports.hostListDNSFilter = hostListDNSFilter;
            },
            "./modules/solclient-session/lib/host-list.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const assert = __webpack_require__("./modules/solclient-eskit/api.js").assert;
                const hostListDNSFilter = __webpack_require__("./modules/solclient-session/lib/host-list-dns-filter.js").hostListDNSFilter;
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const parseURL = __webpack_require__("./modules/solclient-util/api.js").parseURL;
                function parseURLs(rawURLs) {
                    if (Array.isArray(rawURLs)) return rawURLs.map(rawURL => parseURL(rawURL));
                    return parseURLs(rawURLs.split(/[,;]/));
                }
                class HostInfo {
                    constructor(props = {
                        url: null,
                        waitTime: 0
                    }) {
                        Object.assign(this, props);
                    }
                }
                class HostList {
                    constructor({
                        url,
                        connectRetries,
                        reconnectRetries,
                        connectRetriesPerHost,
                        reconnectRetryWaitInMsecs
                    } = {}) {
                        Object.assign(this, {
                            hosts: parseURLs(url).map(e => e.href),
                            connectTryCount: -1 === connectRetries ? Number.POSITIVE_INFINITY : connectRetries + 1,
                            reconnectTryCount: -1 === reconnectRetries ? Number.POSITIVE_INFINITY : reconnectRetries,
                            connectTryCountPerHost: -1 === connectRetriesPerHost ? Number.POSITIVE_INFINITY : connectRetriesPerHost + 1,
                            reconnectRetryWaitInMsecs: reconnectRetryWaitInMsecs,
                            _mutableState: {},
                            logger: new LogFormatter("[host-list]")
                        });
                        this.reset();
                        assert(this.hosts.length >= 1);
                        assert(this.connectTryCount >= 1);
                        assert(this.reconnectTryCount >= 0);
                        assert(this.connectTryCountPerHost >= 1);
                    }
                    resolveHosts(callback) {
                        const LOG_WARN = this.logger.LOG_WARN;
                        hostListDNSFilter(this.hosts, (err, resolved) => {
                            if (err) return callback(err);
                            assert(resolved.length === this.hosts.length, "Resolve did not return a result for all hosts");
                            let succeeded = 0;
                            resolved.forEach(result => {
                                if (result.address) ++succeeded;
                                if (!result.resolved) return;
                                if (result.address) result.address, result.url; else LOG_WARN("DNS resolve FAILED:", result.error.code, `${result.error.syscall}('${result.error.hostname}')`, "for", result.url);
                            });
                            return callback(0 === succeeded ? "All hosts failed DNS resolution" : null);
                        });
                    }
                    reset(state = {
                        wasConnected: false,
                        disconnected: false
                    }) {
                        Object.assign(this._mutableState, {
                            wasConnected: state.wasConnected,
                            disconnected: state.disconnected,
                            hostPointer: 0,
                            hostTries: 0,
                            listTries: 1,
                            exhausted: false,
                            lastHostInfo: new HostInfo()
                        });
                    }
                    getNextHost() {
                        const {} = this.logger;
                        const state = this._mutableState;
                        const wasConnected = state.wasConnected;
                        const lastHostInfo = state.lastHostInfo;
                        assert(lastHostInfo, "Next host request with no prior host info -- did you call reset()?");
                        try {
                            if (state.disconnected) return null;
                            assert(!state.exhausted, "Next host request after host list exhausted");
                            const properties = Object.assign({
                                hosts: this.hosts,
                                hostTriesMax: this.connectTryCountPerHost,
                                listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount
                            });
                            properties, state;
                            lastHostInfo;
                            ++state.hostTries;
                            if (state.hostTries > properties.hostTriesMax) {
                                state.hostTries, lastHostInfo.url;
                                ++state.hostPointer;
                                if (state.hostPointer >= properties.hosts.length) {
                                    ++state.listTries;
                                    if (state.listTries > properties.listTriesMax) {
                                        properties.listTriesMax;
                                        state.exhausted = true;
                                    } else {
                                        state.listTries, properties.listTriesMax;
                                        state.hostPointer = 0;
                                        state.hostTries = 1;
                                    }
                                } else state.hostTries = 1;
                            } else state.hostTries, properties.hostTriesMax;
                            if (state.exhausted) return null;
                            const url = properties.hosts[state.hostPointer];
                            assert(url, `No host at the host pointer! ${properties.hosts}[${state.hostPointer}]`);
                            const isNewList = null === lastHostInfo.url;
                            const isNewHost = lastHostInfo.url !== url;
                            const didJustFinishList = lastHostInfo.url !== url && 0 === state.hostPointer;
                            const waitTime = isNewList || isNewHost && !didJustFinishList ? 0 : this.reconnectRetryWaitInMsecs;
                            const hostInfo = new HostInfo({
                                url: url,
                                waitTime: waitTime
                            });
                            hostInfo;
                            state.lastHostInfo = hostInfo;
                            return hostInfo.url;
                        } finally {
                            state;
                        }
                    }
                    get connectWaitTimeInMsecs() {
                        assert(this._mutableState.lastHostInfo.url, "Getting connectWaitTimeInMsecs having never called getNextHostInfo");
                        return this._mutableState.lastHostInfo.waitTime;
                    }
                    currentHostToString() {
                        const state = this._mutableState;
                        const wasConnected = state.wasConnected;
                        const properties = Object.assign({
                            hosts: this.hosts,
                            hostTriesMax: this.connectTryCountPerHost,
                            listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount
                        });
                        const hostNumber = state.hostPointer + 1;
                        return `host '${state.lastHostInfo.url}' (host ${hostNumber} of ${properties.hosts.length})(host connection attempt ${state.hostTries} of ${properties.hostTriesMax})(total ${wasConnected ? "reconnection" : "connection"} attempt ${state.listTries} of ${properties.listTriesMax})`;
                    }
                }
                module.exports.HostList = HostList;
            },
            "./modules/solclient-session/lib/message-rx-cb-info.js": module => {
                class MessageRxCBInfo {
                    constructor(messageRxCBFunction, userObject) {
                        this.messageRxCBFunction = messageRxCBFunction;
                        this.userObject = userObject;
                    }
                }
                module.exports.MessageRxCBInfo = MessageRxCBInfo;
            },
            "./modules/solclient-session/lib/mutable-session-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const MutableSessionProperty = {
                    CLIENT_NAME: 1,
                    CLIENT_DESCRIPTION: 2
                };
                module.exports.MutableSessionProperty = Enum.new(MutableSessionProperty);
            },
            "./modules/solclient-session/lib/outstanding-data-request.js": module => {
                class OutstandingDataRequest {
                    constructor(correlationId, timer, replyReceivedCBFunction, reqFailedCBFunction, userObject) {
                        this.correlationId = correlationId;
                        this.timer = timer;
                        this.replyReceivedCBFunction = replyReceivedCBFunction;
                        this.reqFailedCBFunction = reqFailedCBFunction;
                        this.userObject = userObject;
                    }
                }
                module.exports.OutstandingDataRequest = OutstandingDataRequest;
            },
            "./modules/solclient-session/lib/p2p-util.js": module => {
                const P2PUtil = {
                    getP2PInboxTopic(base) {
                        return base + `/_`;
                    },
                    getP2PTopicSubscription(base) {
                        return base + `/>`;
                    }
                };
                module.exports.P2PUtil = P2PUtil;
            },
            "./modules/solclient-session/lib/provision-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SessionEvent = __webpack_require__("./modules/solclient-session/lib/session-event.js").SessionEvent;
                class ProvisionEvent extends SessionEvent {
                    constructor(sessionEventCode, infoStr, responseCode = void 0, errorSubcode = 0, correlationKey = void 0, reason = void 0, queueDescriptor = null, queueProperties = null) {
                        super([], sessionEventCode, infoStr, responseCode, errorSubcode, correlationKey, reason);
                        this._queueDescriptor = queueDescriptor;
                        this._queueProperties = queueProperties;
                    }
                    get queueDescriptor() {
                        return this._queueDescriptor;
                    }
                    set queueDescriptor(value) {
                        this._queueDescriptor = value;
                    }
                    get queueProperties() {
                        return this._queueProperties;
                    }
                    set queueProperties(value) {
                        this._queueProperties = value;
                    }
                    ["inspect"]() {
                        const result = super["inspect"]();
                        result.queueDescriptor = this._queueDescriptor;
                        result.queueProperties = this._queueProperties;
                        return result;
                    }
                }
                module.exports.ProvisionEvent = ProvisionEvent;
            },
            "./modules/solclient-session/lib/session-event-cb-info.js": module => {
                class SessionEventCBInfo {
                    constructor(sessionEventCBFunction, userObject) {
                        this.userObject = userObject;
                        this.sessionEventCBFunction = sessionEventCBFunction;
                    }
                }
                module.exports.SessionEventCBInfo = SessionEventCBInfo;
            },
            "./modules/solclient-session/lib/session-event-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SessionEventCode = {
                    UP_NOTICE: 0,
                    DOWN_ERROR: 1,
                    CONNECT_FAILED_ERROR: 2,
                    REJECTED_MESSAGE_ERROR: 4,
                    SUBSCRIPTION_ERROR: 5,
                    SUBSCRIPTION_OK: 6,
                    VIRTUALROUTER_NAME_CHANGED: 7,
                    REQUEST_ABORTED: 8,
                    REQUEST_TIMEOUT: 9,
                    PROPERTY_UPDATE_OK: 10,
                    PROPERTY_UPDATE_ERROR: 11,
                    CAN_ACCEPT_DATA: 13,
                    DISCONNECTED: 14,
                    RECONNECTING_NOTICE: 22,
                    RECONNECTED_NOTICE: 23,
                    REPUBLISHING_UNACKED_MESSAGES: 24,
                    ACKNOWLEDGED_MESSAGE: 25,
                    UNSUBSCRIBE_TE_TOPIC_OK: 26,
                    UNSUBSCRIBE_TE_TOPIC_ERROR: 27,
                    MESSAGE: 28,
                    GUARANTEED_MESSAGE_PUBLISHER_DOWN: 29,
                    PROVISION_ERROR: 30,
                    PROVISION_OK: 31
                };
                module.exports.SessionEventCode = Enum.new(SessionEventCode);
            },
            "./modules/solclient-session/lib/session-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SessionEventName = {
                    CONNECT: "SessionConnect",
                    DISCONNECT: "SessionDisconnect",
                    DISPOSE: "SessionDispose",
                    CONNECT_TIMEOUT: "SessionConnectTimeout",
                    CONNECT_WAIT_TIMEOUT: "SessionConnectWaitTimeout",
                    DOWNGRADE_TIMEOUT: "SessionDowngradeTimeout",
                    TRANSPORT_UP: "SessionTransportUp",
                    TRANSPORT_DESTROYED: "SessionTransportDestroyed",
                    TRANSPORT_CAN_ACCEPT_DATA: "SessionTransportCanAcceptData",
                    TRANSPORT_PARSE_ERROR: "SessionTransportParseError",
                    TRANSPORT_PROTOCOL_SMP: "SessionSMPMessage",
                    TRANSPORT_PROTOCOL_CLIENTCTRL: "SessionClientCtrlMessage",
                    EXCEPTION: "SessionException",
                    SUBSCRIBE_TIMEOUT: "SessionSubscribeTimeout",
                    CREATE_SUBSCRIBER: "SessionCreateSubscriber",
                    FLOW_UP: "SessionFlowUp",
                    FLOW_FAILED: "SessionFlowFailed",
                    SEND_ERROR: "SessionSendError",
                    FLOWS_DISCONNECTED: "SessionFlowsDisconnected",
                    TRANSPORT_FLUSHED: "SessionTransportFlushed",
                    DNS_RESOLUTION_COMPLETE: "SessionDNSResolutionComplete",
                    TRANSPORT_CHANGE_DONE: "SessionTransportChangeDone"
                };
                module.exports.SessionEventName = Enum.new(SessionEventName);
            },
            "./modules/solclient-session/lib/session-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const {
                    ErrorSubcode,
                    OperationError,
                    RequestError,
                    RequestEventCode
                } = __webpack_require__("./modules/solclient-error/api.js");
                const SessionEventCode = __webpack_require__("./modules/solclient-session/lib/session-event-codes.js").SessionEventCode;
                function buildType(Superclass) {
                    class SessionEvent extends Superclass {
                        constructor(superclassArgs, sessionEventCode, infoStr, responseCode = void 0, errorSubcode = 0, correlationKey = void 0, reason = void 0) {
                            super(...superclassArgs);
                            this._sessionEventCode = sessionEventCode;
                            this._infoStr = infoStr;
                            this._responseCode = responseCode;
                            this._errorSubcode = errorSubcode;
                            this._correlationKey = correlationKey;
                            this._reason = reason;
                        }
                        get sessionEventCode() {
                            return this._sessionEventCode;
                        }
                        get infoStr() {
                            return this._infoStr;
                        }
                        get responseCode() {
                            return this._responseCode;
                        }
                        get errorSubcode() {
                            return this.subcode || this._errorSubcode;
                        }
                        get errorSubCode() {
                            return this.errorSubcode;
                        }
                        get correlationKey() {
                            return this._correlationKey;
                        }
                        get reason() {
                            return this._reason;
                        }
                        set reason(value) {
                            this._reason = value;
                        }
                        ["inspect"]() {
                            return Object.assign(super["inspect"] || {}, {
                                sessionEventCode: SessionEventCode.describe(this.sessionEventCode),
                                infoStr: this.infoStr,
                                responseCode: this.responseCode,
                                errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                                correlationKey: this.correlationKey ? this.correlationKey.toString() : null,
                                reason: this.reason ? this.reason : null
                            });
                        }
                        toString() {
                            return util_inspect(this);
                        }
                    }
                    return SessionEvent;
                }
                const SUPERCLASS_FOR_SESSION_EVENT = {
                    [SessionEventCode.CONNECT_FAILED_ERROR]: OperationError,
                    [SessionEventCode.DOWN_ERROR]: OperationError,
                    [SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN]: OperationError,
                    [SessionEventCode.PROPERTY_UPDATE_ERROR]: RequestError,
                    [SessionEventCode.REJECTED_MESSAGE_ERROR]: RequestError,
                    [SessionEventCode.SUBSCRIPTION_ERROR]: RequestError,
                    [SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR]: OperationError,
                    [RequestEventCode.REQUEST_ABORTED]: RequestError,
                    [RequestEventCode.REQUEST_TIMEOUT]: RequestError
                };
                const SUPERCLASS_ARGS = new Map().set(Object, () => []).set(OperationError, (sec, infoStr, rc, subcode, ck, reason) => [ infoStr, subcode, reason ]).set(RequestError, (sec, infoStr, rc, subcode, ck, reason) => [ infoStr, sec, ck, reason ]);
                const TYPE_CACHE = new Map();
                function build(sessionEventCode, infoStr, responseCode = void 0, errorSubcode = 0, correlationKey = void 0, reason = void 0) {
                    const Superclass = SUPERCLASS_FOR_SESSION_EVENT[sessionEventCode] || Object;
                    const SessionEvent = (() => {
                        let result = TYPE_CACHE.get(Superclass);
                        if (result) return result;
                        result = buildType(Superclass);
                        TYPE_CACHE.set(Superclass, result);
                        return result;
                    })();
                    const superclassArgsBuilder = SUPERCLASS_ARGS.get(Superclass) || (() => []);
                    const superclassArgs = superclassArgsBuilder(sessionEventCode, infoStr, responseCode, errorSubcode, correlationKey, reason);
                    return new SessionEvent(superclassArgs, sessionEventCode, infoStr, responseCode, errorSubcode, correlationKey, reason);
                }
                const SessionEvent = buildType(Object);
                SessionEvent.build = build;
                module.exports.SessionEvent = SessionEvent;
            },
            "./modules/solclient-session/lib/session-fsm-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/api.js").ErrorSubcode;
                const FsmEvent = __webpack_require__("./modules/solclient-fsm/api.js").FsmEvent;
                const Hex = __webpack_require__("./modules/solclient-convert/api.js").Hex;
                const formatHexString = Hex.formatHexString;
                class SessionFSMEvent extends FsmEvent {
                    constructor(spec, fields) {
                        super(spec);
                        this.eventText = null;
                        this.errorSubcode = null;
                        this.eventReason = null;
                        this.smfMsg = null;
                        this.sessionId = null;
                        this.guaranteedFlowObject = null;
                        Object.assign(this, fields);
                    }
                    ["inspect"]() {
                        return {
                            eventText: this.eventText,
                            eventReason: this.eventReason,
                            errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                            sessionId: this.sessionId && formatHexString(this.sessionId) || "N/A"
                        };
                    }
                    getExtraStringInfo() {
                        return util_inspect(this);
                    }
                }
                module.exports.SessionFSMEvent = SessionFSMEvent;
            },
            "./modules/solclient-session/lib/session-fsm.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ConsumerLib = __webpack_require__("./modules/solclient-message-consumer/api.js");
                const PublisherLib = __webpack_require__("./modules/solclient-message-publisher/api.js");
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
                const TransportLib = __webpack_require__("./modules/solclient-transport/api.js");
                const assert = __webpack_require__("./modules/solclient-eskit/api.js").assert;
                const CapabilityType = __webpack_require__("./modules/solclient-session/lib/capability-types.js").CapabilityType;
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const CorrelatedRequest = __webpack_require__("./modules/solclient-session/lib/correlated-request.js").CorrelatedRequest;
                const Destination = __webpack_require__("./modules/solclient-destination/api.js").Destination;
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const {
                    FsmEvent,
                    State,
                    StateMachine
                } = __webpack_require__("./modules/solclient-fsm/api.js");
                const Hex = __webpack_require__("./modules/solclient-convert/api.js").Hex;
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const {
                    Message,
                    MessageOutcome,
                    MessageDeliveryModeType
                } = __webpack_require__("./modules/solclient-message/api.js");
                const P2PUtil = __webpack_require__("./modules/solclient-session/lib/p2p-util.js").P2PUtil;
                const SessionEvent = __webpack_require__("./modules/solclient-session/lib/session-event.js").SessionEvent;
                const SessionEventCode = __webpack_require__("./modules/solclient-session/lib/session-event-codes.js").SessionEventCode;
                const SessionEventName = __webpack_require__("./modules/solclient-session/lib/session-event-names.js").SessionEventName;
                const SessionFSMEvent = __webpack_require__("./modules/solclient-session/lib/session-fsm-event.js").SessionFSMEvent;
                const SessionRequestType = __webpack_require__("./modules/solclient-session/lib/session-request-types.js").SessionRequestType;
                const SessionStateName = __webpack_require__("./modules/solclient-session/lib/session-state-names.js").SessionStateName;
                const SslDowngrade = __webpack_require__("./modules/solclient-session/lib/ssl-downgrades.js").SslDowngrade;
                const {
                    StatType,
                    StatsByMode
                } = __webpack_require__("./modules/solclient-stats/api.js");
                const StringUtils = __webpack_require__("./modules/solclient-util/api.js").StringUtils;
                const SubscriptionUpdateTimeoutMessages = __webpack_require__("./modules/solclient-session/lib/subscription-update-timeout-messages.js").SubscriptionUpdateTimeoutMessages;
                const SDTCodec = __webpack_require__("./modules/solclient-sdt/api.js").Codec;
                const Convert = __webpack_require__("./modules/solclient-convert/api.js").Convert;
                const anythingToBuffer = Convert.anythingToBuffer;
                const formatHexString = Hex.formatHexString;
                const stripNullTerminate = StringUtils.stripNullTerminate;
                const {
                    STAT_TX_BYMODE_BYTES,
                    STAT_TX_BYMODE_MSGS,
                    STAT_RX_BYMODE_BYTES,
                    STAT_RX_BYMODE_MSGS,
                    STAT_TX_BYMODE_REDELIVERED,
                    STAT_TX_BYMODE_BYTES_REDELIVERED
                } = StatsByMode;
                __webpack_require__("?84d9");
                const fflate = __webpack_require__("./node_modules/fflate/lib/browser.cjs");
                class SessionFSM extends StateMachine {
                    constructor(sessionProperties, session, stats, hosts) {
                        super({
                            name: "SessionFSM"
                        });
                        const fsm = this;
                        const logFormatter = function(...args) {
                            return [ `[session-fsm=${fsm.sessionIdHex || "(N/A)"}]`, `[${fsm.getCurrentStateName()}]`, ...args ];
                        };
                        const logger = this.logger = new LogFormatter(logFormatter);
                        const LOG_INFO = logger.LOG_INFO;
                        this.log = logger.wrap(this.log, this);
                        this._sessionProperties = sessionProperties;
                        this._session = session;
                        this._sessionStatistics = stats;
                        this._hosts = hosts;
                        this._consumers = new ConsumerLib.ConsumerFlows();
                        this._flowInterfaceFactory = flow => ({
                            getCorrelationTag: this.getCorrelationTag.bind(this),
                            incStat: this.incStat.bind(this),
                            sendData: message => this.send(message, flow, false),
                            sendToTransport: message => this.sendToTransport(message, flow, false),
                            sendControl: message => this.send(message, flow, true),
                            enqueueRequest: this.enqueueOutstandingCorrelatedReq.bind(this),
                            createDestinationFromDescriptor: session.createDestinationFromDescriptor.bind(session),
                            createTemporaryDestination: session.createTemporaryDestination.bind(session),
                            isCapable: session.isCapable.bind(session),
                            getCapability: session.getCapability.bind(session),
                            getCurrentStateName: this.getCurrentStateName.bind(this),
                            updateQueueSubscription: session.updateQueueSubscription.bind(session),
                            get sessionIdHex() {
                                return fsm.sessionIdHex;
                            },
                            get canAck() {
                                return session.canAck;
                            }
                        });
                        this._userBackpressured = false;
                        this.clearCurrentError();
                        this.initial(function() {
                            return this.transitionTo(fsm.SessionDisconnected, context => context.getStateMachine().reset());
                        });
                        this.unhandledEventReaction(function(sEvent) {
                            const curState = fsm.getCurrentState();
                            switch (sEvent.getName()) {
                              case SessionEventName.CREATE_SUBSCRIBER:
                                assert(fsm._consumers, "collection has lifetime of FSM instance");
                                fsm._consumers.add(sEvent.guaranteedFlowObject);
                                return this;

                              case SessionEventName.DISPOSE:
                                return curState.terminate(() => fsm.disposeInternal());

                              case SessionEventName.FLOW_UP:
                                sEvent.guaranteedFlowObject;
                                return this;

                              default:
                                sEvent.getName(), fsm.getCurrentStateName();
                                return this;
                            }
                        });
                        this.SessionConnecting = new State({
                            name: SessionStateName.CONNECTING,
                            parentContext: fsm
                        }, {
                            handleTransportDestroyed() {
                                fsm.clearConnectTimer();
                                fsm._currentHost = fsm._hosts.getNextHost();
                                if (null === fsm._currentHost) return this.transitionToExitPoint(fsm.SessionConnecting, "ErrorExit");
                                const connectWaitTimeInMsecs = fsm._hosts.connectWaitTimeInMsecs;
                                connectWaitTimeInMsecs;
                                if (connectWaitTimeInMsecs > 0 && !fsm._connectWaitTimer) {
                                    fsm._connectWaitTimer = setTimeout(() => {
                                        fsm._connectWaitTimer = null;
                                        fsm.processEvent(new SessionFSMEvent({
                                            name: SessionEventName.CONNECT_WAIT_TIMEOUT
                                        }));
                                    }, connectWaitTimeInMsecs);
                                    return this.transitionTo(fsm.WaitingForInterConnectTimeout);
                                }
                                return this.transitionTo(fsm.WaitingForTransport);
                            }
                        }).entry(() => {
                            fsm.setConnectTimer();
                        }).entryPoint("DisconnectTransport", function() {
                            fsm._hosts.reset({
                                wasConnected: void 0,
                                disconnected: true
                            });
                            fsm._connectFailEvent = SessionEventCode.DISCONNECTED;
                            fsm._connectSuccessEvent = SessionEventCode.DISCONNECTED;
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).entryPoint("ReconnectTransport", function() {
                            fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
                            fsm._connectSuccessEvent = SessionEventCode.RECONNECTED_NOTICE;
                            const disconnected = 0 === fsm._sessionProperties._reconnectRetries;
                            fsm._hosts.reset({
                                wasConnected: true,
                                disconnected: disconnected
                            });
                            if (!disconnected) {
                                const err = fsm._currentError || {};
                                const args = [ err.eventText, err.responseCode, err.errorSubcode, void 0, err.eventReason ];
                                fsm.setPostEventAction(() => {
                                    fsm.setConnectTimer();
                                    fsm.emitSessionEvent(SessionEvent.build(SessionEventCode.RECONNECTING_NOTICE, ...args));
                                });
                            }
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).initial(() => {
                            fsm.clearCurrentError();
                            fsm._connectFailEvent = SessionEventCode.CONNECT_FAILED_ERROR;
                            fsm._connectSuccessEvent = SessionEventCode.UP_NOTICE;
                            fsm._hosts.resolveHosts(err => {
                                if (!fsm._hosts) return null;
                                if (err) {
                                    fsm.setCurrentError({
                                        errorSubcode: ErrorSubcode.UNRESOLVED_HOSTS,
                                        eventText: err
                                    });
                                    fsm._hosts.reset({
                                        disconnected: true
                                    });
                                    return this.processEvent(new SessionFSMEvent({
                                        name: SessionEventName.EXCEPTION
                                    }));
                                }
                                fsm._hosts.reset({
                                    wasConnected: false
                                });
                                fsm._currentHost = fsm._hosts.getNextHost();
                                return this.processEvent(new SessionFSMEvent({
                                    name: SessionEventName.DNS_RESOLUTION_COMPLETE
                                }));
                            });
                            return this.transitionTo(fsm.WaitingForDNS);
                        }).reaction(SessionEventName.DNS_RESOLUTION_COMPLETE, function() {
                            return this.transitionTo(fsm.WaitingForTransport);
                        }).reaction(SessionEventName.DISCONNECT, function() {
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                        }).reaction(SessionEventName.CONNECT_TIMEOUT, function() {
                            fsm.setCurrentError({
                                errorSubcode: ErrorSubcode.TIMEOUT,
                                eventText: "Connect timeout"
                            });
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).reaction(SessionEventName.SEND_ERROR, function(sessionEvent) {
                            LOG_INFO(`SEND_ERROR reached SessionConnecting. ` + sessionEvent);
                            fsm.setCurrentError(sessionEvent);
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).reaction(SessionEventName.EXCEPTION, function(errEvent) {
                            fsm.setCurrentError(errEvent);
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).reaction(SessionEventName.TRANSPORT_DESTROYED, function(sessionEvent) {
                            fsm.setCurrentError(sessionEvent);
                            LOG_INFO("TRANSPORT_DESTROYED event");
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).exit(() => {
                            fsm.clearConnectTimer();
                            if (fsm._connectWaitTimer) {
                                clearTimeout(fsm._connectWaitTimer);
                                fsm._connectWaitTimer = null;
                            }
                        }).exitPoint("ConnectedExit", () => {
                            fsm.setPostEventAction(() => {
                                fsm.emitSessionEvent(SessionEvent.build(fsm._connectSuccessEvent, `'${fsm._hosts.currentHostToString()}'`, 200, 0, null, null));
                                if (fsm._userBackpressured) {
                                    const sessionEvent = SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, "", null, 0, null, "");
                                    fsm.emitSessionEvent(sessionEvent);
                                    fsm._userBackpressured = false;
                                }
                            });
                            fsm.clearCurrentError();
                            return this.transitionTo(fsm.SessionTransportUp);
                        }).exitPoint("ErrorExit", function() {
                            fsm.setPostEventAction(() => {
                                const err = fsm._currentError || {};
                                const args = [ err.eventText, err.responseCode, err.errorSubcode, void 0, err.eventReason ];
                                fsm.emitSessionEvent(SessionEvent.build(fsm._connectFailEvent, ...args));
                            });
                            return this.transitionTo(fsm.SessionDisconnected);
                        });
                        this.WaitingForDNS = new State({
                            name: SessionStateName.WAITING_FOR_DNS,
                            parentContext: fsm.SessionConnecting
                        });
                        this.DestroyingTransport = new State({
                            name: SessionStateName.DESTROYING_TRANSPORT,
                            parentContext: fsm.SessionConnecting
                        }).entry(() => {
                            LOG_INFO("Connecting, disposing transport");
                            fsm.clearConnectTimer();
                            fsm.destroyTransportSession("Disconnecting session", 0);
                        }).reaction(SessionEventName.TRANSPORT_DESTROYED, function(sessionEvent) {
                            fsm.setCurrentError(sessionEvent);
                            return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                        });
                        this.WaitingForInterConnectTimeout = new State({
                            name: SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT,
                            parentContext: fsm.SessionConnecting
                        }).reaction(SessionEventName.CONNECT_WAIT_TIMEOUT, function() {
                            return this.transitionTo(fsm.WaitingForTransport);
                        });
                        this.WaitingForTransport = new State({
                            name: SessionStateName.WAITING_FOR_TRANSPORT,
                            parentContext: fsm.SessionConnecting
                        }).initial(() => {
                            const errorMessage = "Cannot establish transport session: creation failed";
                            fsm.setConnectTimer();
                            fsm.clearCurrentError();
                            try {
                                fsm.initTransport();
                            } catch (e) {
                                this.setCurrentError({
                                    eventText: e.message === errorMessage ? errorMessage : errorMessage + `: ` + e.message,
                                    errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
                                    eventReason: e
                                });
                                return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                            }
                            return this.transitionTo(fsm.WaitingForTransportUp);
                        });
                        this.WaitingForTransportUp = new State({
                            name: SessionStateName.WAITING_FOR_TRANSPORT_UP,
                            parentContext: this.WaitingForTransport
                        }).entry(() => {
                            this._justEntered = true;
                        }).initial(() => {
                            if (!this._justEntered) return this;
                            this._justEntered = false;
                            const errorMessage = "Cannot establish transport session: connection failed";
                            try {
                                const returnCode = fsm._transport.connect();
                                if (returnCode !== TransportLib.TransportReturnCode.OK) throw new OperationError(errorMessage, ErrorSubcode.CONNECTION_ERROR, TransportLib.TransportReturnCode.describe(returnCode));
                                LOG_INFO(`Attempting to connect session '${fsm.sessionId}' to ` + fsm._hosts.currentHostToString());
                            } catch (e) {
                                this.setCurrentError({
                                    eventText: e.message === errorMessage ? errorMessage : errorMessage + `: ` + e.message,
                                    errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
                                    eventReason: e
                                });
                                return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                            }
                            return this;
                        }).reaction(SessionEventName.SEND_ERROR, function(sEvent) {
                            LOG_INFO(`SEND_ERROR while waiting for transport up, doing nothing. ` + sEvent);
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.TRANSPORT_UP, function(sEvent) {
                            fsm.sessionId = sEvent.sessionId || "";
                            const returnCode = fsm.sendClientCtrlLogin();
                            if (returnCode === TransportLib.TransportReturnCode.OK) return this.transitionTo(fsm.WaitingForLogin);
                            const err = {
                                eventText: "Failed to send Client Control Login",
                                errorSubcode: ErrorSubcode.LOGIN_FAILURE,
                                responseCode: 400
                            };
                            fsm.setCurrentError(err);
                            return this.transitionTo(fsm.DestroyingTransport);
                        });
                        this.WaitingForLogin = new State({
                            name: SessionStateName.WAITING_FOR_LOGIN,
                            parentContext: fsm.SessionConnecting
                        }).entry(() => {
                            fsm.setClientCtrlTimer();
                        }).reaction(SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL, function(sEvent) {
                            const clientCtrlMsg = sEvent.smfMsg;
                            const response = clientCtrlMsg.getResponse();
                            const respCode = response.responseCode;
                            const err = {
                                responseCode: respCode
                            };
                            fsm._responseCode = respCode;
                            if (200 === respCode) if (!fsm.checkNoLocal(clientCtrlMsg)) Object.assign(err, {
                                eventText: "No Local is not supported by the Solace Message Router",
                                errorSubcode: ErrorSubcode.NO_LOCAL_NOT_SUPPORTED
                            }); else if (!fsm.checkCompressedSsl(clientCtrlMsg)) Object.assign(err, {
                                eventText: "Compressed TLS is not supported by the Solace Message Router",
                                errorSubcode: ErrorSubcode.COMPRESSED_TLS_NOT_SUPPORTED
                            }); else {
                                fsm.updateReadonlySessionProps(clientCtrlMsg);
                                return this.transitionTo(fsm.WaitForTransportChange);
                            } else {
                                const rawSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, response.responseString);
                                const subcode = rawSubcode === ErrorSubcode.UNKNOWN_ERROR ? ErrorSubcode.LOGIN_FAILURE : rawSubcode;
                                LOG_INFO(`Login failed. Subcode: ${subcode} respCode: ${respCode} ` + `respString: ` + response.responseString);
                                Object.assign(err, {
                                    eventText: response.responseString,
                                    errorSubcode: subcode
                                });
                            }
                            err;
                            fsm.setCurrentError(err);
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).reaction(SessionEventName.DOWNGRADE_TIMEOUT, function() {
                            if (!fsm._transport.requestDowngrade || false === fsm._transport.requestDowngrade("ClientCtrl timeout", ErrorSubcode.TIMEOUT)) {
                                fsm.setCurrentError({
                                    eventText: "ClientCtrl timeout",
                                    errorSubcode: ErrorSubcode.TIMEOUT
                                });
                                return this.transitionTo(fsm.DestroyingTransport);
                            }
                            return this.transitionTo(fsm.WaitingForTransportUp);
                        }).exit(() => {
                            fsm.clearClientCtrlTimer();
                        });
                        this.WaitForTransportChange = new State({
                            name: SessionStateName.WAITING_FOR_TRANSPORT_CHANGE,
                            parentContext: fsm.SessionConnecting
                        }).initial(function() {
                            const callback = function(newTransport) {
                                this._transport = newTransport;
                                this.processEvent(new SessionFSMEvent({
                                    name: SessionEventName.TRANSPORT_CHANGE_DONE
                                }));
                            };
                            const rc = fsm.updateTransportCompression(callback.bind(fsm));
                            if (null === rc) return this;
                            fsm._transport = rc;
                            return this.transitionTo(fsm.ReapplyingSubscriptions);
                        }).reaction(SessionEventName.TRANSPORT_CHANGE_DONE, function() {
                            return this.transitionTo(fsm.ReapplyingSubscriptions);
                        });
                        this.ReapplyingSubscriptions = new State({
                            name: SessionStateName.REAPPLYING_SUBSCRIPTIONS,
                            parentContext: fsm.SessionConnecting
                        }).entry(() => {
                            LOG_INFO("ReapplyingSubscriptions: entry");
                            fsm.copySubscriptionCacheKeys();
                        }).initial(function() {
                            if (true === fsm.reapplySubscriptions()) return this.transitionTo(fsm.WaitForSubConfirm);
                            return this.transitionTo(fsm.WaitForCanAcceptData);
                        }).reaction(SessionEventName.SUBSCRIBE_TIMEOUT, function() {
                            const respText = "Subscription timeout while reapplying";
                            const subcode = ErrorSubcode.TIMEOUT;
                            fsm.setCurrentError({
                                eventText: respText,
                                errorSubcode: subcode
                            });
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).exit(function() {
                            fsm.clearSubscriptionCacheKeys();
                            return this;
                        });
                        this.WaitForSubConfirm = new State({
                            name: SessionStateName.WAITING_FOR_SUBCONFIRM,
                            parentContext: fsm.ReapplyingSubscriptions
                        }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function(sEvent) {
                            const smfRespHeader = sEvent.smfMsg.smfHeader;
                            const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                            const respCode = smfRespHeader.pm_respcode;
                            const respText = smfRespHeader.pm_respstr;
                            if (200 !== respCode) {
                                const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                                LOG_INFO(`Waiting for subscription confirmation, got ${respCode} (${errorSubcode}) ` + `'${respText}' on subscription ` + subscriptionStr);
                                fsm.setCurrentError({
                                    eventText: respText,
                                    responseCode: respCode,
                                    errorSubcode: errorSubcode
                                });
                                return this.transitionTo(fsm.DestroyTransport);
                            }
                            if (fsm._session.canConnectPublisher && fsm._defaultPublisher && fsm._defaultPublisher.isBindWaiting()) return this.transitionTo(fsm.WaitingForMessagePublisher);
                            return this.transitionToExitPoint(fsm.SessionConnecting, "ConnectedExit");
                        });
                        this.WaitForCanAcceptData = new State({
                            name: SessionStateName.WAITING_FOR_CAN_ACCEPT_DATA,
                            parentContext: fsm.ReapplyingSubscriptions
                        }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function(sEvent) {
                            const smfRespHeader = sEvent.smfMsg.smfHeader;
                            const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                            const respCode = smfRespHeader.pm_respcode;
                            const respText = smfRespHeader.pm_respstr;
                            if (200 !== respCode) {
                                const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                                respCode, errorSubcode, respText, subscriptionStr;
                                fsm.setCurrentError({
                                    eventText: respText,
                                    responseCode: respCode,
                                    errorSubcode: errorSubcode
                                });
                                return this.transitionTo(fsm.DestroyingTransport);
                            }
                            LOG_INFO(`Unexpected 200 OK response to subscription add for ` + subscriptionStr);
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function() {
                            if (true === fsm.reapplySubscriptions()) return this.transitionTo(fsm.WaitForSubConfirm);
                            return this.internalTransition(null);
                        });
                        this.WaitingForMessagePublisher = new State({
                            name: SessionStateName.WAITING_FOR_PUBFLOW,
                            parentContext: fsm.SessionConnecting
                        }).entry(() => {
                            fsm._defaultPublisher.connect();
                            fsm.sendPublisherSessionUpEvent(fsm._defaultPublisher);
                        }).reaction(SessionEventName.FLOW_UP, function() {
                            if (!fsm._defaultPublisher.isBindWaiting()) return this.transitionToExitPoint(fsm.SessionConnecting, "ConnectedExit");
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.FLOW_FAILED, function(sEvent) {
                            fsm.setCurrentError({
                                eventText: `Guaranteed Message Publisher Failed: ` + sEvent.eventText,
                                errorSubcode: ErrorSubcode.LOGIN_FAILURE
                            });
                            return this.transitionTo(fsm.DestroyingTransport);
                        });
                        this.SessionTransportUp = new State({
                            name: SessionStateName.TRANSPORT_UP,
                            parentContext: fsm
                        }).entry(function() {
                            fsm.clearConnectTimer();
                            return this;
                        }).initial(function() {
                            if (fsm._session.canConnectConsumer) {
                                fsm._consumers.flows.forEach(consumer => fsm.sendConsumerSessionUpEvent(consumer));
                                fsm._consumers.reconnectingFlows.forEach(consumer => fsm.sendConsumerSessionUpEvent(consumer));
                            }
                            return this.transitionTo(fsm.FullyConnected);
                        }).reaction(SessionEventName.DISCONNECT, function() {
                            return this.transitionTo(fsm.SessionDisconnecting);
                        }).reaction(SessionEventName.EXCEPTION, function(sEvent) {
                            fsm.setCurrentError(sEvent);
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                        }).reaction(SessionEventName.SEND_ERROR, function(sEvent) {
                            fsm.setCurrentError(sEvent);
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                        }).reaction(SessionEventName.TRANSPORT_DESTROYED, function(sEvent) {
                            fsm.setCurrentError(sEvent);
                            LOG_INFO("Received unsolicited TRANSPORT_DESTROYED event while transport is up");
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                        }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function(sEvent) {
                            const smfRespHeader = sEvent.smfMsg.smfHeader;
                            const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                            const respCode = smfRespHeader.pm_respcode;
                            const respText = smfRespHeader.pm_respstr;
                            fsm.handleSubscriptionUpdateError(respCode, respText, subscriptionStr, void 0, false);
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function(sEvent) {
                            const sessionEvent = SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, "", null, 0, null, sEvent.toString());
                            fsm.emitSessionEvent(sessionEvent);
                            fsm._userBackpressured = false;
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.CREATE_SUBSCRIBER, function(sEvent) {
                            const consumer = fsm._consumers.add(sEvent.guaranteedFlowObject);
                            fsm.sendConsumerSessionUpEvent(consumer);
                            return this;
                        }).exit(function() {
                            fsm.clearKeepAlive();
                            return this;
                        });
                        this.FullyConnected = new State({
                            name: SessionStateName.FULLY_CONNECTED,
                            parentContext: fsm.SessionTransportUp
                        }).entry(() => {
                            fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
                            fsm.scheduleKeepAlive();
                        });
                        this.SessionDisconnected = new State({
                            name: SessionStateName.DISCONNECTED,
                            parentContext: fsm
                        }).reaction(SessionEventName.DISCONNECT, function() {
                            fsm.setPostEventAction(() => {
                                fsm.emitSessionEvent(SessionEvent.build(SessionEventCode.DISCONNECTED));
                            });
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.CONNECT, function() {
                            return this.transitionTo(fsm.SessionConnecting);
                        }).reaction(SessionEventName.EXCEPTION, function() {
                            return this.internalTransition(null);
                        });
                        this.SessionDisconnecting = new State({
                            name: SessionStateName.DISCONNECTING,
                            parentContext: fsm
                        }).initial(() => {
                            LOG_INFO(`Disconnecting session ` + fsm);
                            return this.transitionTo(fsm.DisconnectingFlows);
                        }).reaction(SessionEventName.DISCONNECT, function() {
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.EXCEPTION, function(errEvent) {
                            fsm.setCurrentError({
                                errEvent: errEvent
                            });
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                        }).reaction(SessionEventName.TRANSPORT_DESTROYED, function() {
                            LOG_INFO("Received unsolicited TRANSPORT_DESTROYED while disconnecting transport");
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                        });
                        this.DisconnectingFlows = new State({
                            name: SessionStateName.DISCONNECTING_FLOWS,
                            parentContext: fsm.SessionDisconnecting
                        }, {
                            gatherPendingFlows() {
                                const MessageConsumerEventName = ConsumerLib.MessageConsumerEventName;
                                assert(!this.isGathering);
                                this.isGathering = true;
                                const adaptedListenForDestroy = (flow, installfn, downEvents) => {
                                    assert(flow, "Trying to listen to undefined flow");
                                    if (this.known.has(flow)) return;
                                    this.known.add(flow);
                                    this.pending.add(flow);
                                    const onFlowDown = () => {
                                        downEvents.forEach(event => flow._removeListener(event, onFlowDown));
                                        this.pending.delete(flow);
                                        if (!this.isGathering) this.checkPendingFlows();
                                    };
                                    downEvents.forEach(event => installfn.call(flow, event, onFlowDown));
                                    try {
                                        flow._disconnectSession();
                                    } catch (ex) {
                                        onFlowDown();
                                    }
                                };
                                if (fsm._consumers) fsm._consumers.flows.forEach(flow => {
                                    adaptedListenForDestroy(flow, flow._once, [ MessageConsumerEventName.DOWN, MessageConsumerEventName.DOWN_ERROR ]);
                                });
                                this.isGathering = false;
                            },
                            checkPendingFlows() {
                                this.pending;
                                if (0 === this.pending.size) {
                                    this.gatherPendingFlows();
                                    if (0 === this.pending.size) this.proceed();
                                }
                            },
                            proceed() {
                                this.known = null;
                                this.pending = null;
                                LOG_INFO("All flows disconnected");
                                fsm.processEvent(new FsmEvent({
                                    name: SessionEventName.FLOWS_DISCONNECTED
                                }));
                            }
                        }).entry(function() {
                            this.known = new Set();
                            this.pending = new Set();
                            this.checkPendingFlows();
                        }).reaction(SessionEventName.FLOWS_DISCONNECTED, function() {
                            return this.transitionTo(fsm.FlushingTransport);
                        });
                        this.FlushingTransport = new State({
                            name: SessionStateName.FLUSHING_TRANSPORT,
                            parentContext: fsm.SessionDisconnecting
                        }, {
                            flushTransport() {
                                fsm.cleanupSession();
                                fsm.flushTransportSession(() => this.onTransportFlushed());
                                this.sessionId = null;
                            },
                            onTransportFlushed() {
                                fsm.processEvent(new FsmEvent({
                                    name: SessionEventName.TRANSPORT_FLUSHED
                                }));
                            }
                        }).entry(function() {
                            LOG_INFO("Flushing transport");
                            this.flushTransport();
                        }).reaction(SessionEventName.TRANSPORT_FLUSHED, function() {
                            LOG_INFO("Handle Transport Flushed");
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                        });
                    }
                    addToSubscriptionCache(destination) {
                        if (Check.nothing(destination) || !this._subscriptionCache) return;
                        const {} = this.logger;
                        const key = destination.name;
                        if (null === this._subscriptionCache[key] || void 0 === this._subscriptionCache[key]) {
                            key;
                            this._subscriptionCache[key] = destination;
                            this._subscriptionCacheCount++;
                        } else {
                            key;
                            this._subscriptionCache[key] = destination;
                        }
                    }
                    cancelOutstandingCorrelatedReq(correlationTag) {
                        if (Check.nothing(correlationTag) || !this._correlatedReqs) return null;
                        const req = this._correlatedReqs[correlationTag];
                        if (null === req || void 0 === req) return null;
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        if (req.timer) {
                            clearTimeout(req.timer);
                            req.timer = null;
                        }
                        try {
                            const result = delete this._correlatedReqs[correlationTag];
                            if (!result) LOG_ERROR(`Cannot delete ctrl request ` + correlationTag);
                        } catch (e) {
                            LOG_ERROR(`Cannot delete ctrl request ` + correlationTag, e);
                        }
                        return req;
                    }
                    cleanupSession() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        LOG_INFO("Clean up session");
                        const {
                            ConsumerFSMEvent,
                            ConsumerFSMEventNames
                        } = ConsumerLib;
                        if (this._correlatedReqs) Object.keys(this._correlatedReqs).forEach(key => this.cancelOutstandingCorrelatedReq(key));
                        this.clearConnectTimer();
                        this.clearClientCtrlTimer();
                        this.clearKeepAlive();
                        this._consumers.flows.forEach(consumer => {
                            consumer.processFSMEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.SESSION_DOWN
                            }));
                        });
                        this._consumers.reconnectingFlows.forEach(consumer => {
                            consumer.processFSMEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.SESSION_DOWN
                            }));
                        });
                        if (this._defaultPublisher) this._defaultPublisher.processFSMEvent(new PublisherLib.PublisherFSMEvent({
                            name: PublisherLib.PublisherFSMEventNames.SESSION_DOWN
                        }));
                        this._session.cleanupSession();
                    }
                    clearClientCtrlTimer() {
                        if (!this._clientCtrlTimer) return;
                        clearTimeout(this._clientCtrlTimer);
                        this._clientCtrlTimer = null;
                    }
                    clearConnectTimer() {
                        if (!this._connectTimer) return;
                        clearTimeout(this._connectTimer);
                        this._connectTimer = void 0;
                    }
                    clearKeepAlive() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        if (this._keepAliveTimer) {
                            LOG_INFO("Cancel keepalive timer");
                            clearInterval(this._keepAliveTimer);
                            this._keepAliveTimer = null;
                        }
                        this.resetKeepAliveCounter();
                    }
                    checkNoLocal(clientCtrlMsg) {
                        let noLocalSupported = true;
                        if (true === this._sessionProperties.noLocal) {
                            const caps = clientCtrlMsg.getRouterCapabilities();
                            if (!caps) noLocalSupported = false; else noLocalSupported = "boolean" === typeof caps[CapabilityType.NO_LOCAL] ? caps[CapabilityType.NO_LOCAL] : false;
                        }
                        return noLocalSupported;
                    }
                    checkCompressedSsl(clientCtrlMsg) {
                        const {} = this.logger;
                        if (this._compressedTLS) {
                            const caps = clientCtrlMsg.getRouterCapabilities();
                            if (!caps || "boolean" !== typeof caps[CapabilityType.COMPRESSED_SSL]) return false;
                            return true === caps[CapabilityType.COMPRESSED_SSL];
                        }
                        return true;
                    }
                    checkSessionDestinationCapability(destination) {
                        let error = null;
                        if (destination && destination.getType()) if (destination.getSubscriptionInfo() && (destination.getSubscriptionInfo().isShare || destination.getSubscriptionInfo().isNoExport) && !this._session.isCapable(CapabilityType.SHARED_SUBSCRIPTIONS)) error = new OperationError("Shared subscriptions are not allowed by router for this client", ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED, null);
                        return error;
                    }
                    clearCurrentError() {
                        this._currentError = null;
                    }
                    clearSubscriptionCacheKeys() {
                        this._subscriptionCacheKeys = null;
                    }
                    copySubscriptionCacheKeys() {
                        this.clearSubscriptionCacheKeys();
                        this._subscriptionCacheKeys = Object.keys(this._subscriptionCache || {});
                        const p2pTopic = P2PUtil.getP2PTopicSubscription(this._sessionProperties.p2pInboxBase);
                        this._subscriptionCacheKeys.push(p2pTopic);
                    }
                    createMessagePublisher() {
                        const {} = this.logger;
                        if (!this._sessionProperties.publisherProperties.enabled) return;
                        const {
                            MessagePublisher,
                            MessagePublisherEventName
                        } = PublisherLib;
                        const publisher = new MessagePublisher({
                            properties: this._sessionProperties.publisherProperties,
                            sessionInterfaceFactory: this._flowInterfaceFactory
                        });
                        publisher.on(MessagePublisherEventName.UP, () => this.processEvent(new SessionFSMEvent({
                            name: SessionEventName.FLOW_UP
                        }, {
                            guaranteedFlowObject: publisher
                        })));
                        publisher.on(MessagePublisherEventName.CONNECT_FAILED_ERROR, event => this.processEvent(new SessionFSMEvent({
                            name: SessionEventName.FLOW_FAILED
                        }, {
                            guaranteedFlowObject: publisher,
                            event: event,
                            eventText: event.description
                        })));
                        publisher.on(MessagePublisherEventName.REJECTED_MESSAGE, (message, ctrlMessage) => {
                            const header = ctrlMessage.smfHeader;
                            const respCode = header.pm_respcode;
                            const respText = header.pm_respstr;
                            const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respText);
                            const event = SessionEvent.build(SessionEventCode.REJECTED_MESSAGE_ERROR, respText, respCode, errorSubcode, message.getCorrelationKey());
                            event["message"] = message;
                            this.emitSessionEvent(event);
                        });
                        publisher.on(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, message => {
                            const event = SessionEvent.build(SessionEventCode.ACKNOWLEDGED_MESSAGE, "Message(s) acknowledged", void 0, 0, message.getCorrelationKey());
                            event["message"] = message;
                            this.emitSessionEvent(event);
                        });
                        publisher.on(MessagePublisherEventName.FLOW_NAME_CHANGED, data => {
                            const {
                                messages,
                                count
                            } = data;
                            if (count > 0) {
                                const event = SessionEvent.build(SessionEventCode.REPUBLISHING_UNACKED_MESSAGES, `Republishing ${count} messages due to ` + "Guaranteed Message Publisher failed to reconnect");
                                event["messages"] = messages;
                                event["count"] = count;
                                this.emitSessionEvent(event);
                            }
                        });
                        publisher.on(MessagePublisherEventName.CAN_SEND, () => {
                            this.emitSessionEvent(SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, publisher + ` window is now open and can send`));
                        });
                        publisher.on(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN, () => {
                            this.emitSessionEvent(SessionEvent.build(SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN, "Guaranteed Message Publishing shut down"));
                        });
                        this._defaultPublisher = publisher;
                    }
                    sendConsumerSessionUpEvent(consumer) {
                        const {
                            ConsumerFSMEvent,
                            ConsumerFSMEventNames
                        } = ConsumerLib;
                        const isAD = this._session.canConnectConsumer;
                        const event = new ConsumerFSMEvent({
                            name: isAD ? ConsumerFSMEventNames.SESSION_UP : ConsumerFSMEventNames.SESSION_UP_NO_AD
                        });
                        event.guaranteedFlowObject = consumer;
                        consumer.processFSMEvent(event);
                    }
                    sendPublisherSessionUpEvent(publisher) {
                        const isAD = this._session.canConnectPublisher;
                        const event = new PublisherLib.PublisherFSMEvent({
                            name: isAD ? PublisherLib.PublisherFSMEventNames.SESSION_UP : PublisherLib.PublisherFSMEventNames.SESSION_UP_NO_AD
                        });
                        event.guaranteedFlowObject = publisher;
                        publisher.processFSMEvent(event);
                    }
                    createMessageConsumer(properties) {
                        const MessageConsumer = ConsumerLib.MessageConsumer;
                        const consumer = new MessageConsumer({
                            properties: properties,
                            sessionInterfaceFactory: this._flowInterfaceFactory
                        });
                        const consumerProperties = consumer.getProperties();
                        if (consumerProperties.topicEndpointSubscription) {
                            const error = this.checkSessionDestinationCapability(consumerProperties.topicEndpointSubscription);
                            if (error) throw error;
                        }
                        const LOG_WARN = this.logger.LOG_WARN;
                        const settlementOutcomes = consumerProperties.requiredSettlementOutcomes;
                        if (settlementOutcomes && settlementOutcomes.length > 0) {
                            const isNackRequired = settlementOutcomes.some(v => v === MessageOutcome.FAILED || MessageOutcome.REJECTED);
                            if (isNackRequired && !this._session.isCapable(CapabilityType.AD_APP_ACK_FAILED)) {
                                const outcomeNotSupportedError = `Session.capabilitySettlementOutcomeNotSupported: [ ${settlementOutcomes.map(v => `solace.MessageOutcome.` + MessageOutcome.nameOf(v)).join(", ")} ]`;
                                LOG_WARN(outcomeNotSupportedError);
                                throw new OperationError(outcomeNotSupportedError, ErrorSubcode.INVALID_OPERATION, null);
                            }
                        }
                        const info = {
                            guaranteedFlowObject: consumer
                        };
                        this.processEvent(new SessionFSMEvent({
                            name: SessionEventName.CREATE_SUBSCRIBER
                        }, info));
                        return consumer;
                    }
                    createQueueBrowser(properties) {
                        const {
                            MessageConsumerAcknowledgeMode,
                            QueueBrowser
                        } = ConsumerLib;
                        const {} = this.logger;
                        const consumerProperties = {};
                        consumerProperties.queueDescriptor = properties.queueDescriptor;
                        consumerProperties.acknowledgeMode = MessageConsumerAcknowledgeMode.CLIENT;
                        consumerProperties.browser = true;
                        if (Object.prototype.hasOwnProperty.call(properties, "connectTimeoutInMsecs")) consumerProperties.connectTimeoutInMsecs = properties.connectTimeoutInMsecs;
                        if (Object.prototype.hasOwnProperty.call(properties, "connectAttempts")) consumerProperties.connectAttempts = properties.connectAttempts;
                        if (Object.prototype.hasOwnProperty.call(properties, "windowSize")) consumerProperties.windowSize = properties.windowSize;
                        if (Object.prototype.hasOwnProperty.call(properties, "transportAcknowledgeTimeoutInMsecs")) consumerProperties.transportAcknowledgeTimeoutInMsecs = properties.transportAcknowledgeTimeoutInMsecs;
                        if (Object.prototype.hasOwnProperty.call(properties, "transportAcknowledgeThresholdPercentage")) consumerProperties.transportAcknowledgeThresholdPercentage = properties.transportAcknowledgeThresholdPercentage;
                        const consumer = this.createMessageConsumer(consumerProperties);
                        const browser = new QueueBrowser(consumer);
                        return browser;
                    }
                    destroyTransportSession(msg, subcode) {
                        if (Check.nothing(this._transport)) {
                            this.processEvent(new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_DESTROYED
                            }));
                            return;
                        }
                        const {
                            LOG_INFO,
                            LOG_ERROR
                        } = this.logger;
                        LOG_INFO("Destroy transport session");
                        const returnCode = this._transport.destroy(msg, subcode);
                        this._smfClient = null;
                        if (returnCode !== TransportLib.TransportReturnCode.OK) LOG_ERROR(`Failed to destroy transport session, return code: ` + TransportLib.TransportReturnCode.describe(returnCode));
                    }
                    disposeInternal() {
                        if (this._disposed) return;
                        const operations = {
                            transport: () => {
                                this.destroyTransportSession("Disposing", 0);
                                this._transport = null;
                                this._smfClient = null;
                            },
                            session: () => {
                                this.cleanupSession();
                                this._session = null;
                                this._sessionProperties = null;
                                this._correlatedReqs = null;
                                this._flowInterfaceFactory = null;
                            },
                            statistics: () => {
                                if (this._sessionStatistics) {
                                    this._sessionStatistics.resetStats();
                                    this._sessionStatistics = null;
                                }
                                this._kaStats = null;
                            },
                            "subscription cache": () => {
                                if (this._subscriptionCache) {
                                    Object.keys(this._subscriptionCache).forEach(key => this.removeFromSubscriptionCache(key));
                                    this._subscriptionCache = null;
                                }
                                this.clearSubscriptionCacheKeys();
                                this._subscriptionCacheCount = 0;
                            },
                            MessagePublishers: () => {
                                if (this._defaultPublisher) {
                                    this._defaultPublisher.dispose();
                                    this._defaultPublisher = null;
                                }
                            },
                            MessageConsumers: () => {
                                this._consumers.disposeAll();
                                this._consumers = null;
                            },
                            "host list": () => {
                                this._currentHost = null;
                                this._hosts = null;
                            }
                        };
                        Object.keys(operations).forEach(operationKey => {
                            const LOG_INFO = this.logger.LOG_INFO;
                            const operation = operations[operationKey];
                            try {
                                operation();
                            } catch (ex) {
                                LOG_INFO(`Dispose: ${operationKey} failed:`, ex, "...continuing");
                            }
                        });
                        this._disposed = true;
                    }
                    emitSessionEvent(event) {
                        this._session.sendEvent(event);
                    }
                    enqueueOutstandingCorrelatedReq(correlationTag, reqTimeoutCb, reqTimeout, correlationKey, respRecvCallback) {
                        if (Check.nothing(correlationTag)) return;
                        const LOG_INFO = this.logger.LOG_INFO;
                        LOG_INFO(`Enqueue outstanding ctrl request correlationTag=` + correlationTag);
                        let timer = null;
                        if (reqTimeoutCb) timer = setTimeout(reqTimeoutCb, reqTimeout || this._sessionProperties.readTimeoutInMsecs);
                        const outstandingReq = new CorrelatedRequest(correlationTag, timer, correlationKey, respRecvCallback);
                        this._correlatedReqs[correlationTag] = outstandingReq;
                    }
                    errorInFsm(errorEventText, errorSubcode, eventReason = null) {
                        const LOG_INFO = this.logger.LOG_INFO;
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.EXCEPTION
                        });
                        LOG_INFO(`Handling error in FSM: ${errorEventText} ` + (eventReason && eventReason.stack));
                        this.setCurrentError({
                            eventText: errorEventText,
                            errorSubcode: errorSubcode,
                            eventReason: eventReason
                        });
                        return this.processEvent(sEvent);
                    }
                    flushTransportSession(callback) {
                        if (this._transport) this._transport.flush(callback); else callback();
                    }
                    getCorrelationTag() {
                        return this._smfClient.nextCorrelationTag();
                    }
                    getCurrentStateName() {
                        const currentState = this.getCurrentState();
                        if (!currentState) return null;
                        if (currentState === this.getFinalState()) return SessionStateName.DISPOSED;
                        return this.getCurrentState().getName();
                    }
                    getStat(statType) {
                        if (void 0 === this._sessionStatistics) return;
                        if (statType === StatType.TX_TOTAL_DATA_MSGS) return this._sessionStatistics.getStat(StatType.TX_DIRECT_MSGS) + this._sessionStatistics.getStat(StatType.TX_PERSISTENT_MSGS) + this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_MSGS); else if (statType === StatType.TX_TOTAL_DATA_BYTES) return this._sessionStatistics.getStat(StatType.TX_DIRECT_BYTES) + this._sessionStatistics.getStat(StatType.TX_PERSISTENT_BYTES) + this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_BYTES);
                        return this._sessionStatistics.getStat(statType);
                    }
                    getTransportInfo() {
                        if (Check.nothing(this._transport)) return "Not connected.";
                        return this._transport.getInfoStr();
                    }
                    handleADCtrlMessage(message, header) {
                        const flowId = message.getFlowId();
                        const respText = header.pm_respstr;
                        const correlationTag = header.pm_corrtag;
                        const {
                            LOG_INFO,
                            LOG_WARN
                        } = this.logger;
                        if (correlationTag) {
                            this.updateRxStats(message);
                            LOG_INFO(`Handle SMF response for correlationTag ` + correlationTag);
                            const cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
                            if (Check.nothing(cancelledRequest)) return this.errorInFsm(`Cannot find matching request for response: ` + respText, ErrorSubcode.INTERNAL_ERROR);
                            if (cancelledRequest.respRecvdCallback) {
                                cancelledRequest.respRecvdCallback(message, cancelledRequest);
                                return this;
                            }
                            correlationTag;
                            this.incStat(StatType.RX_REPLY_MSG_DISCARD);
                            return this;
                        }
                        let flow;
                        const msgType = message.msgType;
                        const SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
                        switch (msgType) {
                          case SMFAdProtocolMessageType.CLIENTACK:
                          case SMFAdProtocolMessageType.CLIENTNACK:
                          case SMFAdProtocolMessageType.CLOSEPUBFLOW:
                            if (this._defaultPublisher.flowId === flowId) flow = this._defaultPublisher;
                            break;

                          default:
                            flow = this._consumers.getFlowById(flowId);
                        }
                        if (flow && !flow.disposed) {
                            this.updateRxStats(message, flow);
                            flow.handleUncorrelatedControlMessage(message);
                            return this;
                        }
                        const response = message.getResponse();
                        const rc = response ? `"${response.responseCode} ${response.responseString}" ` : "";
                        LOG_WARN(`Dropping ADCTRL.${SMFLib.SMFAdProtocolMessageType.describe(message.msgType)} ${rc}for unknown flow ` + flowId);
                        this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                        return this;
                    }
                    handleADTrMessage(message, header) {
                        const {} = this.logger;
                        const flowId = header.pm_ad_flowid;
                        const flow = this._consumers.getFlowById(flowId);
                        if (!flow || flow.disposed) {
                            flow, flowId;
                            this.updateRxStats(message, this._sessionStatistics);
                            this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                            return null;
                        }
                        this.updateRxStats(message, flow);
                        flow.handleDataMessage(message);
                        return flow;
                    }
                    handleApiSubscriptionTimeout(correlationTag, timeoutMsg) {
                        if (void 0 === this._correlatedReqs[correlationTag] || null === this._correlatedReqs[correlationTag]) return;
                        const {
                            LOG_INFO,
                            LOG_ERROR
                        } = this.logger;
                        LOG_INFO(`${timeoutMsg || "Subscription timeout"} for correlationTag=` + correlationTag);
                        try {
                            const result = delete this._correlatedReqs[correlationTag];
                            if (!result) LOG_ERROR(`Cannot delete ctrl request ` + correlationTag);
                        } catch (e) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}, exception: ` + e.message);
                        }
                    }
                    handleClientCtrlMessage(message, header) {
                        let correlationTag;
                        const LOG_INFO = this.logger.LOG_INFO;
                        this.updateRxStats(message);
                        if (message.msgType === SMFLib.SMFClientCtrlMessageType.LOGIN) {
                            correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
                            LOG_INFO("Handle SMF response for ClientCTRL Login");
                        } else {
                            correlationTag = header.pm_corrtag;
                            LOG_INFO(`Handle SMF response for correlationTag ` + correlationTag);
                        }
                        const cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
                        if (Check.nothing(cancelledRequest)) {
                            const respText = header.pm_respstr;
                            return this.errorInFsm(`Cannot find matching request for response: ` + respText, ErrorSubcode.INTERNAL_ERROR);
                        } else if (cancelledRequest.respRecvdCallback) return cancelledRequest.respRecvdCallback(message);
                        LOG_INFO(`Dropping ClientCtrl message due to mismatched correlation tag ` + correlationTag);
                        return this.incStat(StatType.RX_REPLY_MSG_DISCARD);
                    }
                    handleClientCtrlResponse(clientCtrlMsg) {
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL
                        });
                        sEvent.smfMsg = clientCtrlMsg;
                        this.processEvent(sEvent);
                    }
                    handleClientCtrlTimeout() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        LOG_INFO("ClientCtrl timeout for session");
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.DOWNGRADE_TIMEOUT
                        });
                        this.processEvent(sEvent);
                    }
                    handleConnectTimeout() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        LOG_INFO("Connection timeout. Disconnecting");
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.CONNECT_TIMEOUT
                        });
                        this.processEvent(sEvent);
                    }
                    handleUpdatePropertyTimeout(correlationTag, timeoutMsg) {
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        try {
                            const result = delete this._correlatedReqs[correlationTag];
                            if (!result) LOG_ERROR(`Cannot delete ctrl request ` + correlationTag);
                        } catch (e) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}, exception: ` + e.message);
                        }
                        const sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, timeoutMsg, null, ErrorSubcode.TIMEOUT, null, null);
                        this.sendEvent(sessionEvent);
                    }
                    handleRejectedTrMessage(header) {
                        const respCode = header.pm_respcode;
                        const topicNameRaw = header.pm_tr_topicname_bytes;
                        const topicName = topicNameRaw ? topicNameRaw.replace(/\0/g, "") : "";
                        const respText = header.pm_respstr;
                        const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                        this.emitSessionEvent(SessionEvent.build(SessionEventCode.REJECTED_MESSAGE_ERROR, respText, respCode, errorSubcode, null, `Topic: ` + topicName));
                    }
                    handleSMFMessage(message) {
                        try {
                            const header = message.smfHeader;
                            if (header.discardMessage) {
                                if (this._sessionStatistics) this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                return null;
                            }
                            switch (header.smf_protocol) {
                              case SMFLib.SMFProtocol.TRMSG:
                                if (header.smf_adf) return this.handleADTrMessage(message, header);
                                this.updateRxStats(message, this._sessionStatistics);
                                return 0 === header.pm_respcode ? this._session.handleDataMessage(message) : this.handleRejectedTrMessage(header);

                              case SMFLib.SMFProtocol.ADCTRL:
                                return this.handleADCtrlMessage(message, header);

                              case SMFLib.SMFProtocol.CLIENTCTRL:
                                return this.handleClientCtrlMessage(message, header);

                              case SMFLib.SMFProtocol.SMP:
                                return this.handleSMPMessage(message, header);

                              case SMFLib.SMFProtocol.KEEPALIVE:
                              case SMFLib.SMFProtocol.KEEPALIVEV2:
                                return null;

                              default:
                                return this.handleUnknownProtocolMessage(message, header);
                            }
                        } catch (e) {
                            const LOG_ERROR = this.logger.LOG_ERROR;
                            LOG_ERROR(`Exception in handleSMFMessage, exception: ` + e.stack);
                            return this.errorInFsm(`Exception in handleSMFMessage: ` + e.message, e.subcode || ErrorSubcode.INTERNAL_ERROR, e);
                        }
                    }
                    handleSMFParseError(transportError) {
                        return this.errorInFsm(transportError, ErrorSubcode.PROTOCOL_ERROR);
                    }
                    handleSMPMessage(message, header) {
                        this.updateRxStats(message);
                        const cancelledRequest = this.cancelOutstandingCorrelatedReq(header.pm_corrtag || "");
                        if (Check.nothing(cancelledRequest) || Check.nothing(cancelledRequest.respRecvdCallback)) {
                            const sEvent = new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_PROTOCOL_SMP
                            });
                            sEvent.smfMsg = message;
                            return this.processEvent(sEvent);
                        }
                        return cancelledRequest.respRecvdCallback(message, cancelledRequest);
                    }
                    handleSubscriptionUpdateError(respCode, respText, subscriptionStr, request, confirm) {
                        const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                        if (!(errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND)) this.removeFromSubscriptionCache(subscriptionStr);
                        this._session.handleSubscriptionUpdateError(respCode, respText, subscriptionStr, request, confirm);
                    }
                    handleSubscriptionTimeout(correlationTag) {
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        try {
                            let result = false;
                            if (this._correlatedReqs) result = delete this._correlatedReqs[correlationTag];
                            if (!result) LOG_ERROR(`Cannot delete ctrl request ` + correlationTag);
                        } catch (e) {
                            LOG_ERROR(`Cannot delete ctrl request ` + correlationTag, e);
                        }
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.SUBSCRIBE_TIMEOUT
                        });
                        this.processEvent(sEvent);
                    }
                    handleTransportEvent(transportEvent) {
                        const {
                            LOG_INFO,
                            LOG_WARN
                        } = this.logger;
                        const infoStr = transportEvent.getInfoStr() || "";
                        LOG_INFO(`Receive transport event: ` + transportEvent);
                        let sEvent;
                        switch (transportEvent.getTransportEventCode()) {
                          case TransportLib.TransportSessionEventCode.UP_NOTICE:
                            sEvent = new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_UP
                            });
                            sEvent.sessionId = transportEvent.getSessionId();
                            this.processEvent(sEvent);
                            break;

                          case TransportLib.TransportSessionEventCode.DESTROYED_NOTICE:
                            sEvent = new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_DESTROYED
                            });
                            sEvent.sessionId = transportEvent.getSessionId();
                            sEvent.eventText = infoStr;
                            sEvent.errorSubcode = transportEvent.getSubcode();
                            sEvent.eventReason = transportEvent;
                            this._smfClient = null;
                            this._transport = null;
                            this.processEvent(sEvent);
                            break;

                          case TransportLib.TransportSessionEventCode.CAN_ACCEPT_DATA:
                            this.GuaranteedFlowControlledRelief();
                            sEvent = new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_CAN_ACCEPT_DATA
                            });
                            sEvent.sessionId = transportEvent.getSessionId();
                            this.processEvent(sEvent);
                            break;

                          case TransportLib.TransportSessionEventCode.SEND_ERROR:
                            sEvent = new SessionFSMEvent({
                                name: SessionEventName.SEND_ERROR
                            });
                            sEvent.sessionId = transportEvent.getSessionId();
                            sEvent.eventText = transportEvent.getInfoStr();
                            sEvent.errorSubcode = transportEvent.getSubcode();
                            sEvent.eventReason = transportEvent;
                            this.processEvent(sEvent);
                            break;

                          case TransportLib.TransportSessionEventCode.DATA_DECODE_ERROR:
                          case TransportLib.TransportSessionEventCode.PARSE_FAILURE:
                            return this.errorInFsm(transportEvent.getInfoStr(), transportEvent.getSubcode());

                          default:
                            LOG_WARN("Received unknown transport session event", transportEvent);
                        }
                        return true;
                    }
                    handleUnknownProtocolMessage(message, header) {
                        const {
                            LOG_INFO,
                            LOG_ERROR
                        } = this.logger;
                        this.updateRxStats(message);
                        if (header && header.smf_protocol === SMFLib.SMFProtocol.TSESSION) {
                            LOG_ERROR(`Received transport session message instead of SMF message, protocol 0x` + formatHexString(header.smf_protocol));
                            LOG_ERROR(`Transport MessageType=${message.messageType}, target sessionId=` + formatHexString(message.sessionId));
                            return this.errorInFsm("Received message with unknown protocol", ErrorSubcode.PARSE_FAILURE);
                        }
                        if (this._sessionStatistics) this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                        LOG_INFO(`Drop message with unknown protocol 0x` + formatHexString(header.smf_protocol));
                        return null;
                    }
                    incStat(statType, value) {
                        return this._sessionStatistics ? this._sessionStatistics.incStat(statType, value) : void 0;
                    }
                    initTransport() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        const host = this._currentHost;
                        LOG_INFO(`Creating transport session ` + host);
                        this._kaStats = {
                            lastMsgWritten: 0,
                            lastBytesWritten: 0
                        };
                        this._smfClient = new TransportLib.SMFClient(rxData => this.handleSMFMessage(rxData), rxError => this.handleSMFParseError(rxError), this);
                        this._transport = TransportLib.TransportFactory.createTransport(host, transportEvent => this.handleTransportEvent(transportEvent), this._smfClient, this._sessionProperties.clone(), () => this.sessionIdHex);
                        this.injectTransportInterceptor(this._transportInterceptor);
                    }
                    injectTransportInterceptor(interceptor) {
                        this._transportInterceptor = interceptor;
                        if (this._transport) this._transport.setInterceptor(interceptor);
                    }
                    keepAliveTimeout() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        if (this._keepAliveCounter >= this._sessionProperties.keepAliveIntervalsLimit) {
                            LOG_INFO(`Exceed maximum keep alive intervals limit ` + this._sessionProperties.keepAliveIntervalsLimit);
                            if (this._keepAliveTimer) clearInterval(this._keepAliveTimer);
                            return this.errorInFsm("Exceed maximum keep alive intervals limit", ErrorSubcode.KEEP_ALIVE_FAILURE);
                        }
                        const clientStats = this._transport.getClientStats();
                        const prestatMsgWritten = clientStats.msgWritten;
                        const prestatBytesWritten = clientStats.bytesWritten;
                        const kaMsg = new SMFLib.KeepAliveMessage();
                        const returnCode = this.send(kaMsg, null, true);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) return this.errorInFsm("Cannot send keep alive message", ErrorSubcode.KEEP_ALIVE_FAILURE);
                        if (this._kaStats.lastMsgWritten === prestatMsgWritten && this._kaStats.lastBytesWritten < prestatBytesWritten) this._keepAliveCounter; else {
                            this._keepAliveCounter++;
                            this._kaStats.lastMsgWritten;
                            this._kaStats.lastBytesWritten;
                            this._keepAliveCounter;
                        }
                        this._kaStats.lastBytesWritten = clientStats.bytesWritten;
                        this._kaStats.lastMsgWritten = clientStats.msgWritten;
                        return true;
                    }
                    prepareAndSendMessage(message) {
                        const LOG_WARN = this.logger.LOG_WARN;
                        if (message instanceof Message) {
                            let returnCode;
                            if (this._sessionProperties.payloadCompressionLevel > 0 && (Check.anything(message._binaryAttachment) && message._binaryAttachment.length > 0 || Check.anything(message._structuredContainer))) {
                                let compressedAttachment;
                                let origSize = 0;
                                try {
                                    if (false); else {
                                        const options = {
                                            level: this._sessionProperties.payloadCompressionLevel,
                                            flush: fflate.Z_FINISH
                                        };
                                        if (Check.anything(message.getSdtContainer())) {
                                            const encodedContainer = SDTCodec.encodeSingleElement(message.getSdtContainer());
                                            const textEncoded = anythingToBuffer(encodedContainer);
                                            origSize = textEncoded.length;
                                            compressedAttachment = fflate.zlibSync(textEncoded, options);
                                        } else {
                                            origSize = message._binaryAttachment.length;
                                            compressedAttachment = fflate.zlibSync(message._binaryAttachment, options);
                                        }
                                        compressedAttachment = anythingToBuffer(compressedAttachment);
                                    }
                                    if (compressedAttachment.length + 9 < origSize) {
                                        message._setCompressedBinaryAttachment(compressedAttachment);
                                        Check.nothing(message.getHttpContentEncoding()) ? message._compressedCE = "deflate" : message._compressedCE = message.getHttpContentEncoding() + ", deflate";
                                    } else origSize, compressedAttachment.length;
                                } catch (err) {
                                    LOG_WARN("Error occurred while compressing, message attachment was not compressed. Original attachment will be sent. ", err);
                                }
                            }
                            const deliveryMode = message.getDeliveryMode();
                            switch (deliveryMode) {
                              case MessageDeliveryModeType.DIRECT:
                                if (!this._transport) return;
                                message._payload_is_memoized = false;
                                message._memoized_csumm = null;
                                message._memoized_payload = null;
                                returnCode = this.sendToTransport(message);
                                break;

                              case MessageDeliveryModeType.PERSISTENT:
                              case MessageDeliveryModeType.NON_PERSISTENT:
                                if (!this._defaultPublisher) {
                                    const reason = this._session.adLocallyDisabled ? "locally disabled" : "remotely unsupported";
                                    throw new OperationError("Session does not provide Guaranteed Message Publish capability", ErrorSubcode.GM_UNAVAILABLE, reason);
                                } else {
                                    if (this._gmSendDisallowed) this._gmSendDisallowed();
                                    returnCode = this._defaultPublisher.prepareAdMessageAndSend(message);
                                }
                                break;

                              default:
                                {
                                    const LOG_ERROR = this.logger.LOG_ERROR;
                                    LOG_ERROR("Unhandled message delivery mode", MessageDeliveryModeType.describe(deliveryMode));
                                }
                            }
                            if (Check.anything(message._getCompressedBinaryAttachment())) message._setCompressedBinaryAttachment();
                            delete message._compressedCE;
                            if (returnCode !== TransportLib.TransportReturnCode.OK) {
                                if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
                                    this._userBackpressured = true;
                                    throw new OperationError("Cannot send message - no space in transport", ErrorSubcode.INSUFFICIENT_SPACE, TransportLib.TransportReturnCode.describe(returnCode));
                                }
                                this.setCurrentError(new OperationError("Cannot send message", ErrorSubcode.INVALID_OPERATION, TransportLib.TransportReturnCode.describe(returnCode)));
                                this.processEvent(new SessionFSMEvent({
                                    name: SessionEventName.EXCEPTION
                                }));
                            }
                        }
                    }
                    GuaranteedFlowControlledRelief() {
                        if (this._defaultPublisher) this._defaultPublisher.processFSMEvent(new PublisherLib.PublisherFSMEvent({
                            name: PublisherLib.PublisherFSMEventNames.CAN_SEND
                        }));
                    }
                    reapplySubscriptions() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        const {
                            createTopicDestination
                        } = SolclientFactoryLib.SolclientFactory;
                        LOG_INFO(`Reapplying subscriptions, count=` + this._subscriptionCacheKeys.length);
                        if (!this._subscriptionCacheKeys) return true;
                        try {
                            while (this._subscriptionCacheKeys.length) {
                                const key = this._subscriptionCacheKeys.shift();
                                const requestConfirmation = 0 === this._subscriptionCacheKeys.length;
                                const topicDestination = createTopicDestination(key);
                                const rc = this.sendSubscribe(topicDestination, requestConfirmation, null, this._sessionProperties.readTimeoutInMsecs, null);
                                if (rc !== TransportLib.TransportReturnCode.OK) this.errorInFsm(`Error occurred sending subscription: ` + TransportLib.TransportReturnCode.describe(rc), ErrorSubcode.INTERNAL_ERROR);
                            }
                        } catch (e) {
                            if (e instanceof OperationError && e.subcode === ErrorSubcode.INSUFFICIENT_SPACE) return false;
                            this.errorInFsm(`Unexpected expection occurred while reapplying subscriptions: ` + e, e.subcode || ErrorSubcode.INTERNAL_ERROR, e);
                        }
                        return true;
                    }
                    removeFromSubscriptionCache(topic) {
                        if (Check.nothing(topic) || !this._subscriptionCache) return null;
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        const key = topic instanceof Destination ? topic.name : topic;
                        key;
                        const sub = this._subscriptionCache[key];
                        if (void 0 === sub || null === sub) return null;
                        try {
                            const result = delete this._subscriptionCache[key];
                            if (!result) LOG_ERROR(`Cannot remove subscription ` + key); else this._subscriptionCacheCount--;
                        } catch (e) {
                            LOG_ERROR(`Cannot remove subscription ` + key, e);
                        }
                        return sub;
                    }
                    reset() {
                        this.resetStats();
                        this.sessionId = null;
                        this._keepAliveTimer = null;
                        this.resetKeepAliveCounter();
                        this._correlatedReqs = {};
                        this._disposed = false;
                        this._smfClient = null;
                        this._kaStats = {
                            lastMsgWritten: 0,
                            lastBytesWritten: 0
                        };
                        this._subscriptionCache = null;
                        this._subscriptionCacheKeys = null;
                        this._subscriptionCacheCount = 0;
                        if (this._sessionProperties.reapplySubscriptions) this._subscriptionCache = {};
                        this._eventCode = null;
                        this._responseCode = null;
                        this.eventText = null;
                        this.errorSubcode = null;
                        this.eventReason = null;
                    }
                    resetKeepAliveCounter() {
                        this._keepAliveCounter = 0;
                    }
                    resetStats() {
                        return this._sessionStatistics ? this._sessionStatistics.resetStats() : void 0;
                    }
                    scheduleKeepAlive() {
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        const keepAliveIntervalInMsecs = this._sessionProperties.keepAliveIntervalInMsecs;
                        if (0 === keepAliveIntervalInMsecs) return;
                        if (this._keepAliveTimer) clearInterval(this._keepAliveTimer);
                        this._keepAliveTimer = setInterval(() => {
                            try {
                                this.keepAliveTimeout();
                            } catch (e) {
                                LOG_ERROR("Error occurred in keepAliveTimeout", e);
                            }
                        }, keepAliveIntervalInMsecs);
                        keepAliveIntervalInMsecs;
                    }
                    send(message, statTarget = this._sessionStatistics, forceAllowEnqueue = false) {
                        try {
                            return this.sendToTransport(message, statTarget, forceAllowEnqueue);
                        } catch (ex) {
                            const {} = this.logger;
                            ex.message, ex.stack;
                            this.errorInFsm(`Send operation failed: ` + ex.message, ex.subcode || ErrorSubcode.CONNECTION_ERROR);
                        }
                        return TransportLib.TransportReturnCode.CONNECTION_ERROR;
                    }
                    sendToTransport(message, statTarget = this._sessionStatistics, forceAllowEnqueue = false) {
                        let returnCode = TransportLib.TransportReturnCode.CONNECTION_ERROR;
                        if (!this._transport) throw new OperationError("Transport has been destroyed", ErrorSubcode.INTERNAL_ERROR);
                        const content = SMFLib.Codec.Encode.encodeCompoundMessage(message);
                        returnCode = this._transport.send(content, forceAllowEnqueue);
                        switch (returnCode) {
                          case TransportLib.TransportReturnCode.OK:
                            this.updateTxStats(message, statTarget);
                            break;

                          case TransportLib.TransportReturnCode.NO_SPACE:
                            if (!forceAllowEnqueue) break;

                          default:
                            throw new OperationError(`Transport returned ` + TransportLib.TransportReturnCode.describe(returnCode), ErrorSubcode.INTERNAL_ERROR);
                        }
                        return returnCode;
                    }
                    sendClientCtrlLogin() {
                        const LOG_INFO = this.logger.LOG_INFO;
                        this._compressedTLS = this._sessionProperties.compressionLevel > 0 && null !== this._currentHost.match(/tcps:/i);
                        this._plaintextTLS = null !== this._currentHost.match(/tcps:/i) && this._sessionProperties.sslConnectionDowngradeTo === SslDowngrade.PLAINTEXT;
                        this._plaintextTLS, this._compressedTLS;
                        const clientCtrlMsg = SMFLib.ClientCtrlMessage.getLogin(this._sessionProperties, this._compressedTLS, this._plaintextTLS);
                        const returnCode = this.send(clientCtrlMsg);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            this._responseCode = null;
                            this.eventReason = null;
                            if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
                                this.eventText = "Cannot send client control - no space in transport";
                                this.errorSubcode = ErrorSubcode.INSUFFICIENT_SPACE;
                            } else {
                                LOG_INFO(`Cannot send client ctrl, return code
          ` + TransportLib.TransportReturnCode.describe(returnCode));
                                this.eventText = "Cannot send client ctrl";
                                this.errorSubcode = ErrorSubcode.INVALID_OPERATION;
                            }
                        } else {
                            const correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
                            LOG_INFO(`Using internally correlationTag=${correlationTag} for tracking ClientCTRL Login`);
                            this.enqueueOutstandingCorrelatedReq(correlationTag, null, null, null, rxMsgObj => this.handleClientCtrlResponse(rxMsgObj));
                        }
                        return returnCode;
                    }
                    sendSubscribe(topic, requestConfirmation, correlationKey, requestTimeout, respRecvdCallback) {
                        const LOG_INFO = this.logger.LOG_INFO;
                        assert(topic instanceof Destination, "sendSubscribe requires a Destination, not a string");
                        const correlationTag = this.getCorrelationTag();
                        const smpMsg = SMFLib.SMPMessage.getSubscriptionMessage(correlationTag, topic, true, requestConfirmation);
                        assert(smpMsg.encodedUtf8Subscription, "Encoded SMP message was invalid");
                        const returnCode = this.send(smpMsg);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            LOG_INFO("Subscribe failed", TransportLib.TransportReturnCode.describe(returnCode));
                            return returnCode;
                        }
                        if (requestConfirmation) this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleSubscriptionTimeout(correlationTag), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                        return returnCode;
                    }
                    sendUpdateProperty(mutableSessionProperty, newValue, correlationKey, requestTimeout, respRecvdCallback) {
                        const correlationTag = this._smfClient.nextCorrelationTag();
                        const smpMsg = SMFLib.ClientCtrlMessage.getUpdate(mutableSessionProperty, newValue, correlationTag);
                        const returnCode = this.send(smpMsg);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) return returnCode;
                        this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleUpdatePropertyTimeout(correlationTag), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                        return returnCode;
                    }
                    provisionEndpoint(queueDescriptior, queueProperties, correlationKey, callback) {
                        const {} = this.logger;
                        const correlationTag = this._smfClient.nextCorrelationTag();
                        const message = SMFLib.AdProtocolMessage.getCreate(queueDescriptior, queueProperties, correlationTag);
                        const rc = this.send(message);
                        if (rc !== TransportLib.TransportReturnCode.OK) {
                            LOG_INFO("Provision failed", TransportLib.TransportReturnCode.describe(rc));
                            return rc;
                        }
                        correlationTag;
                        this.enqueueOutstandingCorrelatedReq(correlationTag, null, 0, correlationKey, callback);
                    }
                    deprovisionEndpoint(queueDescriptior, correlationKey, callback) {
                        const {} = this.logger;
                        const correlationTag = this._smfClient.nextCorrelationTag();
                        const message = SMFLib.AdProtocolMessage.getDelete(queueDescriptior, correlationTag);
                        const rc = this.send(message);
                        if (rc !== TransportLib.TransportReturnCode.OK) {
                            LOG_INFO("Deprovision failed", TransportLib.TransportReturnCode.describe(rc));
                            return rc;
                        }
                        correlationTag;
                        this.enqueueOutstandingCorrelatedReq(correlationTag, null, 0, correlationKey, callback);
                    }
                    setClientCtrlTimer() {
                        this.clearClientCtrlTimer();
                        this._clientCtrlTimer = setTimeout(() => this.handleClientCtrlTimeout(), this._sessionProperties.transportDowngradeTimeoutInMsecs);
                    }
                    setConnectTimer() {
                        this.clearConnectTimer();
                        this._connectTimer = setTimeout(() => this.handleConnectTimeout(), this._sessionProperties.connectTimeoutInMsecs);
                    }
                    setCurrentError(source) {
                        const target = this._currentError || {};
                        const {} = this.logger;
                        Object.keys(source).forEach(key => {
                            if (null === source[key] || void 0 === source[key]) return false;
                            if (null !== target[key] && void 0 !== target[key]) {
                                target[key], source[key];
                                return false;
                            }
                            target[key] = source[key];
                            return true;
                        });
                        this._currentError = target;
                    }
                    subscriptionUpdate(subject, requestConfirmation, correlationKey, requestTimeout, requestType, force, respRecvdCallback) {
                        const error = this.checkSessionDestinationCapability(subject);
                        if (error) throw error;
                        const timeoutMsg = SubscriptionUpdateTimeoutMessages[requestType] || SubscriptionUpdateTimeoutMessages.default;
                        const isSMP = requestType !== SessionRequestType.REMOVE_DTE_SUBSCRIPTION;
                        const add = requestType === SessionRequestType.ADD_SUBSCRIPTION || requestType === SessionRequestType.ADD_P2PINBOX;
                        const correlationTag = this.getCorrelationTag();
                        const generateMessage = isSMP ? SMFLib.SMPMessage.getSubscriptionMessage : SMFLib.AdProtocolMessage.getDTEUnsubscribeMessage;
                        const msg = generateMessage(correlationTag, subject, add, requestConfirmation);
                        const returnCode = this.send(msg, void 0, force);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) return returnCode;
                        if (requestConfirmation) this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleApiSubscriptionTimeout(correlationTag, timeoutMsg), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                        if (requestType === SessionRequestType.ADD_SUBSCRIPTION && this._sessionProperties.reapplySubscriptions) this.addToSubscriptionCache(subject); else if (requestType === SessionRequestType.REMOVE_SUBSCRIPTION && this._sessionProperties.reapplySubscriptions) this.removeFromSubscriptionCache(subject);
                        return returnCode;
                    }
                    queueSubscriptionUpdate(subject, queue, requestTimeout, add, force, respRecvdCallback) {
                        const timeoutMsg = add ? SubscriptionUpdateTimeoutMessages[SessionRequestType.ADD_SUBSCRIPTION] : SubscriptionUpdateTimeoutMessages[SessionRequestType.REMOVE_SUBSCRIPTION];
                        const correlationTag = this.getCorrelationTag();
                        const msg = SMFLib.SMPMessage.getQueueSubscriptionMessage(correlationTag, subject, queue, add);
                        const returnCode = this.send(msg, void 0, force);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) return returnCode;
                        this.enqueueOutstandingCorrelatedReq(correlationTag, () => {
                            const origReq = this._correlatedReqs[correlationTag];
                            this.handleApiSubscriptionTimeout(correlationTag, timeoutMsg);
                            respRecvdCallback(null, origReq);
                        }, requestTimeout || this._sessionProperties.readTimeoutInMsecs, null, respRecvdCallback);
                        return returnCode;
                    }
                    updateRxStats(smfMessage, target = this._sessionStatistics) {
                        if (!target) return;
                        const smfHeader = smfMessage.smfHeader;
                        if (!smfHeader) return;
                        const deliveryMode = smfHeader.pm_deliverymode || 0;
                        const msgStatKey = STAT_RX_BYMODE_MSGS[deliveryMode];
                        const bytesStatKey = STAT_RX_BYMODE_BYTES[deliveryMode];
                        const msgLength = smfHeader.messageLength;
                        switch (smfHeader.smf_protocol) {
                          case SMFLib.SMFProtocol.TRMSG:
                            if (0 === smfHeader.pm_respcode) {
                                target.incStat(StatType.RX_TOTAL_DATA_MSGS);
                                target.incStat(msgStatKey);
                                target.incStat(StatType.RX_TOTAL_DATA_BYTES, msgLength);
                                target.incStat(bytesStatKey, msgLength);
                                if (smfHeader.smf_di) target.incStat(StatType.RX_DISCARD_MSG_INDICATION);
                            }
                            break;

                          case SMFLib.SMFProtocol.CLIENTCTRL:
                          case SMFLib.SMFProtocol.SMP:
                          case SMFLib.SMFProtocol.KEEPALIVE:
                          case SMFLib.SMFProtocol.KEEPALIVEV2:
                          case SMFLib.SMFProtocol.ADCTRL:
                            target.incStat(StatType.RX_CONTROL_MSGS);
                            target.incStat(StatType.RX_CONTROL_BYTES, msgLength);
                            break;

                          default:
                        }
                    }
                    updateTxStats(smfMessage, target = this._sessionStatistics) {
                        if (!target) return;
                        if (void 0 !== smfMessage.getReplyTo && smfMessage.getReplyTo()) target.incStat(StatType.TX_REQUEST_SENT);
                        const smfHeader = smfMessage.smfHeader;
                        if (!smfHeader) return;
                        const deliveryMode = smfHeader.pm_deliverymode || 0;
                        let msgStatKey = STAT_TX_BYMODE_MSGS[deliveryMode];
                        let bytesStatKey = STAT_TX_BYMODE_BYTES[deliveryMode];
                        if (deliveryMode !== MessageDeliveryModeType.DIRECT) if (smfMessage.isRedelivered()) {
                            msgStatKey = STAT_TX_BYMODE_REDELIVERED[deliveryMode];
                            bytesStatKey = STAT_TX_BYMODE_BYTES_REDELIVERED[deliveryMode];
                        }
                        const msgLength = smfHeader.messageLength;
                        switch (smfHeader.smf_protocol) {
                          case SMFLib.SMFProtocol.TRMSG:
                            target.incStat(msgStatKey);
                            target.incStat(bytesStatKey, msgLength);
                            break;

                          case SMFLib.SMFProtocol.CLIENTCTRL:
                          case SMFLib.SMFProtocol.SMP:
                          case SMFLib.SMFProtocol.KEEPALIVE:
                          case SMFLib.SMFProtocol.KEEPALIVEV2:
                          case SMFLib.SMFProtocol.ADCTRL:
                            target.incStat(StatType.TX_CONTROL_MSGS);
                            target.incStat(StatType.TX_CONTROL_BYTES, msgLength);
                            break;

                          default:
                        }
                    }
                    updateReadonlySessionProps(clientCtrlRespMsg) {
                        const props = this._sessionProperties;
                        props._setVpnNameInUse(clientCtrlRespMsg.getVpnNameInUseValue() || "");
                        const oldVirtualRouterName = props.virtualRouterName;
                        const newVirtualRouterName = clientCtrlRespMsg.getVridInUseValue() || "";
                        props._setVirtualRouterName(newVirtualRouterName);
                        if ("" !== oldVirtualRouterName && oldVirtualRouterName !== newVirtualRouterName) this.handleVirtualRouterNameChange(oldVirtualRouterName, newVirtualRouterName);
                        props._setP2pInboxBase(clientCtrlRespMsg.getP2PTopicValue() || "");
                        props._setP2pInboxInUse(P2PUtil.getP2PInboxTopic(props.p2pInboxBase));
                        this._session.updateCapabilities(clientCtrlRespMsg.getRouterCapabilities());
                        const gmCap = this._session._getCapability(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
                        this._gmSendDisallowed = "boolean" === typeof gmCap && !gmCap ? () => {
                            throw new OperationError("Sending guaranteed message is not allowed by router for this client", ErrorSubcode.INVALID_OPERATION, null);
                        } : null;
                    }
                    handleVirtualRouterNameChange(oldName, newName) {
                        if (this._consumers) {
                            this._consumers.flows.forEach(consumer => consumer.onVRNChanged());
                            this._consumers.reconnectingFlows.forEach(consumer => consumer.onVRNChanged());
                        }
                        this.emitSessionEvent(SessionEvent.build(SessionEventCode.VIRTUALROUTER_NAME_CHANGED, `Virtual router name is changed from ${oldName} to ` + newName, null, 0, null, null));
                    }
                    get sessionIdHex() {
                        return this.sessionId && formatHexString(this.sessionId) || "N/A";
                    }
                    updateTransportCompression(callback) {
                        const {} = this.logger;
                        this._plaintextTLS, this._compressedTLS;
                        if (this._plaintextTLS) {
                            TransportLib.TransportFactory.severTls(this._transport, this._compressedTLS, callback);
                            return null;
                        }
                        if (this._compressedTLS) {
                            const newTransport = TransportLib.TransportFactory.startCompression(this._transport);
                            return newTransport;
                        }
                        return this._transport;
                    }
                }
                module.exports.SessionFSM = SessionFSM;
            },
            "./modules/solclient-session/lib/session-operations.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SessionOperation = {
                    CONNECT: "CONNECT",
                    DISCONNECT: "DISCONNECT",
                    CTRL: "CTRL",
                    SEND: "SEND",
                    QUERY_OPERATION: "QUERY_OPERATION"
                };
                module.exports.SessionOperation = Enum.new(SessionOperation);
            },
            "./modules/solclient-session/lib/session-properties-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const PublisherLib = __webpack_require__("./modules/solclient-message-publisher/api.js");
                __webpack_require__("./modules/solclient-session/lib/session-properties.js");
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const {
                    APIPropertiesValidators,
                    parseURL
                } = __webpack_require__("./modules/solclient-util/api.js");
                const AuthenticationScheme = __webpack_require__("./modules/solclient-session/lib/authentication-schemes.js").AuthenticationScheme;
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const {
                    LOG_WARN,
                    LOG_INFO
                } = __webpack_require__("./modules/solclient-log/api.js");
                const {} = __webpack_require__("./modules/solclient-session/lib/ssl-downgrades.js");
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/api.js").TransportProtocol;
                const {
                    validateInstance,
                    valArrayIsMember,
                    valBoolean,
                    valLength,
                    valNotEmpty,
                    valNumber,
                    valRange,
                    valString,
                    valStringOrArray
                } = APIPropertiesValidators;
                const ALLOWED_PROTOCOLS = [ "http:", "https:", "ws:", "wss:", "tcp:", "tcps:" ];
                function valClientName(typeDesc, instance, name) {
                    const error = SMFLib.ClientCtrlMessage.validateClientName(instance[name], errorMessage => new OperationError(typeDesc + ` validation: Property '${name}': ` + errorMessage, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                    if (error) throw error;
                }
                function valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull) {
                    const val = instance[key];
                    if (allowNull && null === val) return;
                    if ("undefined" !== typeof val && !enumInstance.values.some(v => v === val)) throw new OperationError(typeDesc + ` validation: Property '${key}' must be a member of ` + enumName, ErrorSubcode.PARAMETER_INVALID_TYPE);
                }
                function valUrlList(typeDesc, instance, name) {
                    const val = instance[name];
                    const valArray = "string" === typeof val ? val.split(",") : val;
                    if (!Check.array(valArray)) throw new OperationError(typeDesc + ` validation: Property '${name}' not an array or comma-delimited string`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    valArray.forEach(el => {
                        let url = null;
                        try {
                            url = parseURL(el);
                        } catch (ex) {
                            throw new OperationError(typeDesc + ` validation: Property '${name}' contained an invalid URL: ` + el, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        if (!Check.included(url.protocol, ALLOWED_PROTOCOLS)) throw new OperationError(`${typeDesc} validation: Property '${name}' contained a URL'${url.href}' with an invalid protocol: '${url.protocol}'`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    });
                }
                function isHttpTransport(transportProtocol) {
                    return transportProtocol && (transportProtocol === TransportProtocol.HTTP_BINARY_STREAMING || transportProtocol === TransportProtocol.HTTP_BINARY || transportProtocol === TransportProtocol.HTTP_BASE64);
                }
                function validatePropsSupportedByTransport(transportProtocol, nonHttpPropsSet) {
                    if (nonHttpPropsSet.length > 0 && isHttpTransport(transportProtocol)) {
                        const propNames = nonHttpPropsSet.length <= 5 ? nonHttpPropsSet : nonHttpPropsSet.slice(0, 5);
                        throw new OperationError(`SessionProperties validation: properties that are not supported by transport protocol ${transportProtocol} have been set: ` + propNames, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                }
                function matchUrl(instance, name, regex, all) {
                    const val = instance[name];
                    if (val instanceof Array) {
                        const arrayLength = val.length;
                        for (let i = 0; i < arrayLength; i++) {
                            const currententry = val[i];
                            if (!all) {
                                if (Check.string(currententry) && currententry.match(regex)) return true;
                            } else if (all) if (!Check.string(currententry) || !currententry.match(regex)) return false;
                        }
                        if (!all) return false; else if (all) return true;
                    }
                    return Check.string(val) && val.match(regex);
                }
                function useSsl(instance, name, all) {
                    return matchUrl(instance, name, /^(https|wss|tcps):/i, all);
                }
                const SessionPropertiesValidator = {
                    validate(props) {
                        const v = validateInstance.bind(null, "SessionProperties", props);
                        v("url", [ valNotEmpty ], [ valStringOrArray ], [ valUrlList ]);
                        v("userName", [ valString ], [ valLength, 189 ]);
                        v("password", [ valString ], [ valLength, 128 ]);
                        v("clientName", [ valString ], [ valLength, 160 ], [ valClientName ]);
                        v("applicationDescription", [ valString ], [ valLength, 254 ]);
                        v("vpnName", [ valString ], [ valLength, 32 ]);
                        v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("connectRetriesPerHost", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                        v("connectRetries", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                        v("reconnectRetries", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                        v("reconnectRetryWaitInMsecs", [ valNumber ], [ valRange, 0, 6e4 ]);
                        v("readTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("sendBufferMaxSize", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("maxWebPayload", [ valNumber ], [ valRange, 100, Number.MAX_VALUE ]);
                        if (true) v("bufferedAmountQueryIntervalInMsecs", [ valNumber ], [ valRange, 4, Number.MAX_VALUE ]);
                        v("generateSendTimestamps", [ valBoolean ]);
                        v("generateReceiveTimestamps", [ valBoolean ]);
                        v("includeSenderId", [ valBoolean ]);
                        v("keepAliveIntervalInMsecs", [ valNumber ], [ valRange, 0, Number.MAX_VALUE ]);
                        v("keepAliveIntervalsLimit", [ valNumber ], [ valRange, 3, Number.MAX_VALUE ]);
                        v("generateSequenceNumber", [ valBoolean ]);
                        v("subscriberLocalPriority", [ valNumber ], [ valRange, 1, 4 ]);
                        v("subscriberNetworkPriority", [ valNumber ], [ valRange, 1, 4 ]);
                        v("ignoreDuplicateSubscriptionError", [ valBoolean ]);
                        v("ignoreSubscriptionNotFoundError", [ valBoolean ]);
                        v("reapplySubscriptions", [ valBoolean ]);
                        v("noLocal", [ valBoolean ]);
                        v("transportDowngradeTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("idToken", [ valString ]);
                        v("accessToken", [ valString ]);
                        v("payloadCompressionLevel", [ valNumber ], [ valRange, 0, 9 ]);
                        if (props.transportProtocol && props.webTransportProtocolList) throw new OperationError("SessionProperties validation: Property 'transportProtocol' and " + "'webTransportProtocolList' cannot be set at the same time", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        if (null !== props.webTransportProtocolList && void 0 !== props.webTransportProtocolList) {
                            if (!Array.isArray(props.webTransportProtocolList)) throw new OperationError("Property 'webTransportProtocolList' must be an array if set", ErrorSubcode.PARAMETER_INVALID_TYPE);
                            if (0 === props.webTransportProtocolList.length) throw new OperationError("Property 'webTransportProtocolList' must be non-empty if set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        v("authenticationScheme", [ valIsMember, AuthenticationScheme, "AuthenticationScheme", false ]);
                        const useClientCert = props.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
                        if (!useSsl(props, "url", true) && useClientCert) throw new OperationError("SessionProperties validation: Property 'authenticationScheme' cannot be set to client certificate " + "for unsecured sessions", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        if (Check.equal(props.authenticationScheme, AuthenticationScheme.OAUTH2)) {
                            if (!useSsl(props, "url", true)) throw new OperationError(`SessionProperties validation: Property 'authenticationScheme' ${""}cannot be set to '${AuthenticationScheme.OAUTH2}' unless the ${""}session property 'url' is written to use a secure ${""}communication protocol like tcps or https.`, ErrorSubcode.PARAMETER_CONFLICT);
                            if (Check.empty(props.idToken) && Check.empty(props.accessToken)) throw new OperationError(`SessionProperties validation: Property 'authenticationScheme' ${""}can be set to ${""}'${AuthenticationScheme.OAUTH2}' only if there ${""}is an accompanying token set as a session property. The ${""}token types that are ${""}supported for OAuth authentication are OAuth2.0 Access ${""}Tokens and OpenID Connect ID Tokens. To set an access token ${""}you can use the accessToken session property. To set an id ${""}you can use the idToken session property.`, ErrorSubcode.PARAMETER_CONFLICT);
                        } else if (!Check.empty(props.idToken) || !Check.empty(props.accessToken)) LOG_INFO(`SessionProperties validation: Property ${""}'authenticationScheme' must be set to ${""}'${AuthenticationScheme.OAUTH2}'in order to use either ${""} an OAUTH2 access token or an OpenID Connect ID token.`);
                        if (false);
                        v("transportProtocol", [ valIsMember, TransportProtocol, "TransportProtocol", true ]);
                        v("webTransportProtocolList", [ valArrayIsMember, TransportProtocol, "TransportProtocol", true, false, false ]);
                        validatePropsSupportedByTransport(props.transportProtocol, props.nonHTTPTransportPropsSet);
                        if (props.publisherProperties) PublisherLib.MessagePublisherPropertiesValidator.validate(props.publisherProperties);
                        const recommendedMin = props.defaultConnectTimeoutInMsecs;
                        const connectTimeout = props.connectTimeoutInMsecs;
                        const transportCount = props.webTransportProtocolList ? props.webTransportProtocolList.length : 1;
                        if (transportCount > 1 && connectTimeout < recommendedMin) LOG_WARN(`Connect timeout of ${connectTimeout} msecs is less than default and recommended ` + `minimum of ${recommendedMin} msecs for current transport selection. Transport ` + "downgrades may not complete.");
                    }
                };
                module.exports.SessionPropertiesValidator = SessionPropertiesValidator;
            },
            "./modules/solclient-session/lib/session-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
                __webpack_require__("?c549");
                const PublisherLib = __webpack_require__("./modules/solclient-message-publisher/api.js");
                const APIProperties = __webpack_require__("./modules/solclient-util/api.js").APIProperties;
                const AuthenticationScheme = __webpack_require__("./modules/solclient-session/lib/authentication-schemes.js").AuthenticationScheme;
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const LOG_WARN = __webpack_require__("./modules/solclient-log/api.js").LOG_WARN;
                const {} = __webpack_require__("./modules/solclient-session/lib/ssl-downgrades.js");
                function makeDefaults() {
                    const MessagePublisherProperties = PublisherLib.MessagePublisherProperties;
                    return {
                        _vpnNameInUse: "",
                        _virtualRouterName: "",
                        _p2pInboxInUse: "",
                        _p2pInboxBase: "",
                        _userIdentification: "",
                        _tpProtocolInUse: null,
                        _tpContentType: "text/plain",
                        _publisherProperties: new MessagePublisherProperties(),
                        _payloadCompressionLevel: 0
                    };
                }
                class SessionPropertiesBrowser extends APIProperties {
                    get transportProtocol() {
                        return Check.nothing(this._tpProtocol) ? null : this._tpProtocol;
                    }
                    set transportProtocol(newValue) {
                        this._tpProtocol = newValue;
                    }
                    get transportDowngradeTimeoutInMsecs() {
                        return Check.nothing(this._tpDowngradeTimeout) ? 3e3 : this._tpDowngradeTimeout;
                    }
                    set transportDowngradeTimeoutInMsecs(newValue) {
                        this._tpDowngradeTimeout = newValue;
                    }
                    get webTransportProtocolList() {
                        return Check.nothing(this._transportProtocolList) ? null : this._transportProtocolList;
                    }
                    set webTransportProtocolList(newValue) {
                        this._transportProtocolList = newValue;
                    }
                    get bufferedAmountQueryIntervalInMsecs() {
                        return Check.nothing(this._bufferedAmountQueryInterval) ? 100 : this._bufferedAmountQueryInterval;
                    }
                    set bufferedAmountQueryIntervalInMsecs(newValue) {
                        this._bufferedAmountQueryInterval = newValue;
                    }
                    get transportProtocolInUse() {
                        return this._tpProtocolInUse || null;
                    }
                    _setTransportProtocolInUse(value) {
                        this._tpProtocolInUse = value;
                    }
                    get webTransportProtocolInUse() {
                        return this._tpProtocolInUse || null;
                    }
                    _setWebTransportProtocolInUse(value) {
                        this._tpProtocolInUse = value;
                    }
                    get transportContentType() {
                        return this._tpContentType || "text/plain";
                    }
                    set transportContentType(newValue) {
                        this._tpContentType = newValue;
                    }
                    _lendsInspect() {
                        return {
                            bufferedAmountQueryIntervalInMsecs: this.bufferedAmountQueryIntervalInMsecs,
                            transportContentType: this.transportContentType,
                            transportDowngradeTimeoutInMsecs: this.transportDowngradeTimeoutInMsecs,
                            transportProtocol: this.transportProtocol,
                            transportProtocolInUse: this.transportProtocolInUse,
                            webTransportProtocolList: this.webTransportProtocolList
                        };
                    }
                }
                (class extends APIProperties {});
                const SessionPropertiesBase = false ? 0 : SessionPropertiesBrowser;
                class SessionProperties extends SessionPropertiesBase {
                    constructor(options) {
                        super(makeDefaults(), options);
                    }
                    get authenticationScheme() {
                        return Check.nothing(this._authScheme) ? AuthenticationScheme.BASIC : this._authScheme;
                    }
                    set authenticationScheme(newValue) {
                        this._authScheme = newValue;
                    }
                    get accessToken() {
                        return Check.empty(this._accessToken) ? "" : this._accessToken;
                    }
                    set accessToken(newValue) {
                        this._accessToken = newValue;
                    }
                    get idToken() {
                        return Check.empty(this._idToken) ? "" : this._idToken;
                    }
                    set idToken(newValue) {
                        this._idToken = newValue;
                    }
                    get issuerIdentifier() {
                        return Check.empty(this._issuerIdentifier) ? "" : this._issuerIdentifier;
                    }
                    set issuerIdentifier(newValue) {
                        if (!Check.type(newValue, "string")) {
                            LOG_WARN(`Failed to set issuer identifier because the pased value ${""}was not of type String. The passed issuer identifier ${""}must be of type String. Setting issuer identifier to ${""}default value empty string.`);
                            this._issuerIdentifier = "";
                        } else if (Check.empty(newValue)) LOG_WARN(`Failed to set the issuer identifier because the passed string was empty ${""}or null. The passed issuer identifier must not be empty or null. Setting ${""}issuer identifier to default value empty string.`); else this._issuerIdentifier = newValue;
                    }
                    get url() {
                        return Check.nothing(this._url) ? "" : this._url;
                    }
                    set url(newValue) {
                        this._url = newValue;
                    }
                    get password() {
                        return Check.nothing(this._password) ? "" : this._password;
                    }
                    set password(newValue) {
                        this._password = newValue;
                    }
                    get userName() {
                        return Check.nothing(this._userName) ? "" : this._userName;
                    }
                    set userName(newValue) {
                        this._userName = newValue;
                    }
                    get clientName() {
                        return Check.nothing(this._clientName) ? "" : this._clientName;
                    }
                    set clientName(newValue) {
                        this._clientName = newValue;
                    }
                    get applicationDescription() {
                        return Check.nothing(this._appDesc) ? "" : this._appDesc;
                    }
                    set applicationDescription(newValue) {
                        this._appDesc = newValue;
                    }
                    get vpnName() {
                        return Check.nothing(this._vpnName) ? "" : this._vpnName;
                    }
                    set vpnName(newValue) {
                        this._vpnName = newValue;
                    }
                    get vpnNameInUse() {
                        return Check.nothing(this._vpnNameInUse) ? "" : this._vpnNameInUse;
                    }
                    _setVpnNameInUse(value) {
                        this._vpnNameInUse = value;
                    }
                    get virtualRouterName() {
                        return Check.nothing(this._virtualRouterName) ? "" : this._virtualRouterName;
                    }
                    _setVirtualRouterName(value) {
                        this._virtualRouterName = value;
                    }
                    get connectTimeoutInMsecs() {
                        if (Check.nothing(this._connectTimeout)) return this.defaultConnectTimeoutInMsecs;
                        return this._connectTimeout;
                    }
                    set connectTimeoutInMsecs(newValue) {
                        this._connectTimeout = newValue;
                    }
                    get defaultConnectTimeoutInMsecs() {
                        const minTimeout = 8e3;
                        const {
                            webTransportProtocolList,
                            transportDowngradeTimeoutInMsecs
                        } = this;
                        const transportCount = webTransportProtocolList ? webTransportProtocolList.length : 1;
                        const margin = transportCount > 1 ? 1e3 : 0;
                        const connectDowngradeDefault = transportCount * transportDowngradeTimeoutInMsecs + margin;
                        return Math.max(minTimeout, connectDowngradeDefault);
                    }
                    get connectRetries() {
                        return Check.nothing(this._connectRetries) ? 20 : this._connectRetries;
                    }
                    set connectRetries(newValue) {
                        this._connectRetries = newValue;
                    }
                    get connectRetriesPerHost() {
                        return Check.nothing(this._connectRetriesPerHost) ? 0 : this._connectRetriesPerHost;
                    }
                    set connectRetriesPerHost(newValue) {
                        this._connectRetriesPerHost = newValue;
                    }
                    get reconnectRetryWaitInMsecs() {
                        return Check.nothing(this._reconnectRetryWaitInMsecs) ? 3e3 : this._reconnectRetryWaitInMsecs;
                    }
                    set reconnectRetryWaitInMsecs(newValue) {
                        this._reconnectRetryWaitInMsecs = newValue;
                    }
                    get reconnectRetries() {
                        return Check.nothing(this._reconnectRetries) ? 20 : this._reconnectRetries;
                    }
                    set reconnectRetries(newValue) {
                        this._reconnectRetries = newValue;
                    }
                    get generateSendTimestamps() {
                        return Check.nothing(this._genSendTimestamps) ? false : this._genSendTimestamps;
                    }
                    set generateSendTimestamps(newValue) {
                        this._genSendTimestamps = newValue;
                    }
                    get generateReceiveTimestamps() {
                        return Check.nothing(this._genReceiveTimestamps) ? false : this._genReceiveTimestamps;
                    }
                    set generateReceiveTimestamps(newValue) {
                        this._genReceiveTimestamps = newValue;
                    }
                    get includeSenderId() {
                        return Check.nothing(this._includeSenderId) ? false : this._includeSenderId;
                    }
                    set includeSenderId(newValue) {
                        this._includeSenderId = newValue;
                    }
                    get generateSequenceNumber() {
                        return Check.nothing(this._genSequenceNumber) ? false : this._genSequenceNumber;
                    }
                    set generateSequenceNumber(newValue) {
                        this._genSequenceNumber = newValue;
                    }
                    get keepAliveIntervalInMsecs() {
                        return Check.nothing(this._kaInterval) ? 3e3 : this._kaInterval;
                    }
                    set keepAliveIntervalInMsecs(newValue) {
                        this._kaInterval = newValue;
                    }
                    get keepAliveIntervalsLimit() {
                        return Check.nothing(this._kaIntervalsLimit) ? 3 : this._kaIntervalsLimit;
                    }
                    set keepAliveIntervalsLimit(newValue) {
                        this._kaIntervalsLimit = newValue;
                    }
                    get p2pInboxInUse() {
                        return Check.nothing(this._p2pInboxInUse) ? "" : this._p2pInboxInUse;
                    }
                    _setP2pInboxInUse(value) {
                        this._p2pInboxInUse = value;
                    }
                    get p2pInboxBase() {
                        return Check.nothing(this._p2pInboxBase) ? "" : this._p2pInboxBase;
                    }
                    _setP2pInboxBase(value) {
                        this._p2pInboxBase = value;
                    }
                    get userIdentification() {
                        return Check.nothing(this._userIdentification) ? "" : this._userIdentification;
                    }
                    _setUserIdentification(value) {
                        this._userIdentification = value;
                    }
                    get subscriberLocalPriority() {
                        return Check.nothing(this._subLocalPriority) ? 1 : this._subLocalPriority;
                    }
                    set subscriberLocalPriority(newValue) {
                        this._subLocalPriority = newValue;
                    }
                    get subscriberNetworkPriority() {
                        return Check.nothing(this._subNetworkPriority) ? 1 : this._subNetworkPriority;
                    }
                    set subscriberNetworkPriority(newValue) {
                        this._subNetworkPriority = newValue;
                    }
                    get ignoreDuplicateSubscriptionError() {
                        return Check.nothing(this._ignoreDupSubError) ? true : this._ignoreDupSubError;
                    }
                    set ignoreDuplicateSubscriptionError(newValue) {
                        this._ignoreDupSubError = newValue;
                    }
                    get ignoreSubscriptionNotFoundError() {
                        return Check.nothing(this._ignoreSubNotFoundError) ? true : this._ignoreSubNotFoundError;
                    }
                    set ignoreSubscriptionNotFoundError(newValue) {
                        this._ignoreSubNotFoundError = newValue;
                    }
                    get reapplySubscriptions() {
                        return Check.nothing(this._reapplySubcriptions) ? false : this._reapplySubcriptions;
                    }
                    set reapplySubscriptions(newValue) {
                        this._reapplySubcriptions = newValue;
                    }
                    get publisherProperties() {
                        return this._publisherProperties;
                    }
                    set publisherProperties(val) {
                        const MessagePublisherProperties = PublisherLib.MessagePublisherProperties;
                        this._publisherProperties = val instanceof MessagePublisherProperties ? val : new MessagePublisherProperties(val);
                    }
                    get noLocal() {
                        return Check.nothing(this._noLocal) ? false : this._noLocal;
                    }
                    set noLocal(newValue) {
                        this._noLocal = newValue;
                    }
                    get readTimeoutInMsecs() {
                        return Check.nothing(this._readTimeout) ? 1e4 : this._readTimeout;
                    }
                    set readTimeoutInMsecs(newValue) {
                        this._readTimeout = newValue;
                    }
                    get sendBufferMaxSize() {
                        return Check.nothing(this._sendBufferMaxSize) ? 64 * 1024 : this._sendBufferMaxSize;
                    }
                    set sendBufferMaxSize(newValue) {
                        this._sendBufferMaxSize = newValue;
                    }
                    get assumedMaxAdSize() {
                        return Check.nothing(this._assumedMaxAdSize) ? 3e7 : this._assumedMaxAdSize;
                    }
                    set assumedMaxAdSize(newValue) {
                        this._assumedMaxAdSize = newValue;
                    }
                    get maxWebPayload() {
                        return Check.nothing(this._maxWebPayload) ? 1024 * 1024 : this._maxWebPayload;
                    }
                    set maxWebPayload(newValue) {
                        this._maxWebPayload = newValue;
                    }
                    get nonHTTPTransportPropsSet() {
                        return [].filter(k => Check.something(this[k]));
                    }
                    get payloadCompressionLevel() {
                        return Check.nothing(this._payloadCompressionLevel) ? 0 : this._payloadCompressionLevel;
                    }
                    set payloadCompressionLevel(newValue) {
                        this._payloadCompressionLevel = newValue;
                    }
                    ["inspect"]() {
                        return Object.assign(this._lendsInspect(), {
                            authenticationScheme: AuthenticationScheme.describe(this.authenticationScheme),
                            accessToken: this.accessToken ? "*****" : "Not Set",
                            idToken: this.idToken ? "*****" : "Not Set",
                            issuerIdentifier: this.issuerIdentifier ? "*****" : "Not Set",
                            url: this.url,
                            password: this.password ? "*****" : this.password,
                            userName: this.userName,
                            clientName: this.clientName,
                            applicationDescription: this.applicationDescription,
                            vpnName: this.vpnName,
                            vpnNameInUse: this.vpnNameInUse,
                            virtualRouterName: this.virtualRouterName,
                            connectTimeoutInMsecs: this.connectTimeoutInMsecs,
                            connectRetries: this.connectRetries,
                            connectRetriesPerHost: this.connectRetriesPerHost,
                            reconnectRetryWaitInMsecs: this.reconnectRetryWaitInMsecs,
                            reconnectRetries: this.reconnectRetries,
                            generateSendTimestamps: this.generateSendTimestamps,
                            generateReceiveTimestamps: this.generateReceiveTimestamps,
                            includeSenderId: this.includeSenderId,
                            generateSequenceNumber: this.generateSequenceNumber,
                            keepAliveIntervalInMsecs: this.keepAliveIntervalInMsecs,
                            keepAliveIntervalsLimit: this.keepAliveIntervalsLimit,
                            p2pInboxInUse: this.p2pInboxInUse,
                            p2pInboxBase: this.p2pInboxBase,
                            userIdentification: this.userIdentification,
                            subscriberLocalPriority: this.subscriberLocalPriority,
                            subscriberNetworkPriority: this.subscriberNetworkPriority,
                            ignoreDuplicateSubscriptionError: this.ignoreDuplicateSubscriptionError,
                            reapplySubscriptions: this.reapplySubscriptions,
                            publisherProperties: this.publisherProperties,
                            noLocal: this.noLocal,
                            readTimeoutInMsecs: this.readTimeoutInMsecs,
                            sendBufferMaxSize: this.sendBufferMaxSize,
                            maxWebPayload: this.maxWebPayload,
                            payloadCompressionLevel: this.payloadCompressionLevel
                        });
                    }
                    toString() {
                        return super.toString();
                    }
                }
                if (false);
                module.exports.SessionProperties = SessionProperties;
            },
            "./modules/solclient-session/lib/session-request-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SessionRequestType = {
                    ADD_SUBSCRIPTION: 0,
                    REMOVE_SUBSCRIPTION: 1,
                    ADD_P2PINBOX: 2,
                    REMOVE_P2PINBOX: 3,
                    REMOVE_DTE_SUBSCRIPTION: 100
                };
                module.exports.SessionRequestType = Enum.new(SessionRequestType);
            },
            "./modules/solclient-session/lib/session-state-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SessionStateName = {
                    DISCONNECTED: "SessionDisconnected",
                    CONNECTING: "SessionConnecting",
                    WAITING_FOR_TRANSPORT: "WaitingForTransport",
                    WAITING_FOR_TRANSPORT_UP: "WaitingForTransportUp",
                    WAITING_FOR_LOGIN: "WaitingForLogin",
                    TRANSPORT_UP: "SessionTransportUp",
                    FULLY_CONNECTED: "SessionFullyConnected",
                    SESSION_ERROR: "SessionError",
                    DISCONNECTING: "SessionDisconnecting",
                    REAPPLYING_SUBSCRIPTIONS: "ReapplyingSubscriptions",
                    WAITING_FOR_PUBFLOW: "WaitingForMessagePublisher",
                    DISPOSED: "SessionDisposed",
                    WAITING_FOR_SUBCONFIRM: "WaitForSubConfirm",
                    WAITING_FOR_CAN_ACCEPT_DATA: "WaitForCanAcceptData",
                    DISCONNECTING_FLOWS: "DisconnectingFlows",
                    FLUSHING_TRANSPORT: "FlushingTransport",
                    DESTROYING_TRANSPORT: "DestroyingTransport",
                    RECONNECTING: "Reconnecting",
                    TRANSPORT_FAIL: "TransportFail",
                    WAITING_FOR_INTERCONNECT_TIMEOUT: "WaitingForInterconnectTimeout",
                    WAITING_FOR_DNS: "WaitingForDNS",
                    WAITING_FOR_TRANSPORT_CHANGE: "WaitingForTransportChange"
                };
                module.exports.SessionStateName = Enum.new(SessionStateName);
            },
            "./modules/solclient-session/lib/session-states.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SessionState = {
                    CONNECTING: 1,
                    CONNECTED: 2,
                    SESSION_ERROR: 3,
                    DISCONNECTING: 4,
                    DISCONNECTED: 5
                };
                module.exports.SessionState = Enum.new(SessionState);
            },
            "./modules/solclient-session/lib/session.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const DestinationLib = __webpack_require__("./modules/solclient-destination/api.js");
                const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
                const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
                const assert = __webpack_require__("./modules/solclient-eskit/api.js").assert;
                const {
                    CacheSession,
                    CACHE_REQUEST_PREFIX
                } = __webpack_require__("./modules/solclient-solcache-session/api.js");
                const CapabilityType = __webpack_require__("./modules/solclient-session/lib/capability-types.js").CapabilityType;
                const {
                    Check,
                    Parameter
                } = __webpack_require__("./modules/solclient-validate/api.js");
                const DefaultCapabilities = __webpack_require__("./modules/solclient-session/lib/default-capabilities.js").DefaultCapabilities;
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError,
                    NotImplementedError,
                    RequestEventCode
                } = __webpack_require__("./modules/solclient-error/api.js");
                const EventEmitter = __webpack_require__("./modules/solclient-events/api.js").EventEmitter;
                const GlobalContext = __webpack_require__("./modules/solclient-session/lib/global-context.js").GlobalContext;
                const HostList = __webpack_require__("./modules/solclient-session/lib/host-list.js").HostList;
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const MessageRxCBInfo = __webpack_require__("./modules/solclient-session/lib/message-rx-cb-info.js").MessageRxCBInfo;
                const MutableSessionProperty = __webpack_require__("./modules/solclient-session/lib/mutable-session-properties.js").MutableSessionProperty;
                const OutstandingDataRequest = __webpack_require__("./modules/solclient-session/lib/outstanding-data-request.js").OutstandingDataRequest;
                const P2PUtil = __webpack_require__("./modules/solclient-session/lib/p2p-util.js").P2PUtil;
                const {
                    QueueDescriptor,
                    QueueProperties,
                    QueuePropertiesValidator,
                    QueueType,
                    explainInvalidEndpointName
                } = __webpack_require__("./modules/solclient-queue/api.js");
                const {
                    SDTField,
                    SDTFieldType
                } = __webpack_require__("./modules/solclient-sdt/api.js");
                const SessionEvent = __webpack_require__("./modules/solclient-session/lib/session-event.js").SessionEvent;
                const ProvisionEvent = __webpack_require__("./modules/solclient-session/lib/provision-event.js").ProvisionEvent;
                const SessionEventCBInfo = __webpack_require__("./modules/solclient-session/lib/session-event-cb-info.js").SessionEventCBInfo;
                const SessionEventCode = __webpack_require__("./modules/solclient-session/lib/session-event-codes.js").SessionEventCode;
                const SessionEventName = __webpack_require__("./modules/solclient-session/lib/session-event-names.js").SessionEventName;
                const SessionFSM = __webpack_require__("./modules/solclient-session/lib/session-fsm.js").SessionFSM;
                const SessionFSMEvent = __webpack_require__("./modules/solclient-session/lib/session-fsm-event.js").SessionFSMEvent;
                const SessionOperation = __webpack_require__("./modules/solclient-session/lib/session-operations.js").SessionOperation;
                const SessionProperties = __webpack_require__("./modules/solclient-session/lib/session-properties.js").SessionProperties;
                const SessionPropertiesValidator = __webpack_require__("./modules/solclient-session/lib/session-properties-validator.js").SessionPropertiesValidator;
                const SessionRequestType = __webpack_require__("./modules/solclient-session/lib/session-request-types.js").SessionRequestType;
                const SessionState = __webpack_require__("./modules/solclient-session/lib/session-states.js").SessionState;
                const SessionStateName = __webpack_require__("./modules/solclient-session/lib/session-state-names.js").SessionStateName;
                const {
                    Stats,
                    StatType
                } = __webpack_require__("./modules/solclient-stats/api.js");
                const StringUtils = __webpack_require__("./modules/solclient-util/api.js").StringUtils;
                const {
                    TransportCapabilities,
                    TransportProtocol,
                    TransportReturnCode
                } = __webpack_require__("./modules/solclient-transport/api.js");
                function transportProtocolDefaultList() {
                    const ProfileBinding = SolclientFactoryLib.ProfileBinding;
                    if (false);
                    const result = [];
                    if (TransportCapabilities.web.webSocket()) result.push(TransportProtocol.WS_BINARY);
                    const profile = ProfileBinding.value;
                    if (profile.cometEnabled) {
                        if (TransportCapabilities.web.xhrBinary()) {
                            if (TransportCapabilities.web.streaming()) result.push(TransportProtocol.HTTP_BINARY_STREAMING);
                            result.push(TransportProtocol.HTTP_BINARY);
                        }
                        result.push(TransportProtocol.HTTP_BASE64);
                    }
                    return result;
                }
                function isValidADTransport(transportProtocol) {
                    return transportProtocol && (transportProtocol !== TransportProtocol.HTTP_BINARY_STREAMING && transportProtocol !== TransportProtocol.HTTP_BINARY && transportProtocol !== TransportProtocol.HTTP_BASE64);
                }
                function formatEventName(eventName) {
                    return `SessionEventCode.` + SessionEventCode.describe(eventName);
                }
                const SOLCLIENT_REQUEST_PREFIX = "#REQ";
                class Session extends EventEmitter {
                    constructor(properties, messageCallback, eventCallback) {
                        super({
                            emits: SessionEventCode.values,
                            direct: SessionEventCode.MESSAGE,
                            formatEventName: formatEventName
                        });
                        const self = this;
                        this.logger = new LogFormatter();
                        this.logger.formatter = function(...args) {
                            return [ `[session=${self._sessionFSM ? self._sessionFSM.sessionIdHex : "(N/A)"}]`, ...args ];
                        };
                        const {} = this.logger;
                        if (void 0 !== properties && null !== properties) {
                            const {} = this.logger;
                        }
                        this.on("error", error => {
                            const LOG_ERROR = self.logger.LOG_ERROR;
                            LOG_ERROR(error.info.error);
                        });
                        const sessionProperties = new SessionProperties(properties);
                        {
                            const {} = this.logger;
                            sessionProperties;
                        }
                        this._messageCallbackInfo = this.wrapMessageCallback(messageCallback);
                        this._eventCallbackInfo = this.wrapEventCallback(eventCallback);
                        if (Check.empty(sessionProperties.clientName)) sessionProperties.clientName = GlobalContext.GenerateClientName();
                        sessionProperties._setUserIdentification(GlobalContext.GenerateUserIdentification());
                        if (Check.empty(sessionProperties.applicationDescription)) sessionProperties.applicationDescription = GlobalContext.GenerateClientDescription();
                        SessionPropertiesValidator.validate(sessionProperties);
                        if (Check.nothing(sessionProperties.webTransportProtocolList)) {
                            const selectedProtocol = sessionProperties.transportProtocol;
                            const defaultList = transportProtocolDefaultList();
                            const sliceIndex = selectedProtocol ? defaultList.indexOf(selectedProtocol) : 0;
                            if (sliceIndex < 0) throw new OperationError(`Selected transport protocol ${TransportProtocol.describe(selectedProtocol)} is disabled or invalid for this platform`, ErrorSubcode.PARAMETER_CONFLICT);
                            sessionProperties.webTransportProtocolList = defaultList.slice(sliceIndex);
                            if (0 === sessionProperties.webTransportProtocolList.length) throw new OperationError(`No usable transport protocol or fallback from ` + TransportProtocol.describe(selectedProtocol), ErrorSubcode.PARAMETER_CONFLICT);
                            const validForAD = sessionProperties.webTransportProtocolList.filter(x => isValidADTransport(x));
                            if (0 === validForAD.length) this._adDisabledReason = "Guaranteed messaging not compatible with any available " + `transport protocol: ` + sessionProperties.webTransportProtocolList.map(k => TransportProtocol.describe(k)).join(", ");
                            if (sessionProperties.publisherProperties.enabled) {
                                if (this._adDisabledReason) throw new OperationError("Invalid transport protocol(s) for session with Guaranteed Messaging Publisher", ErrorSubcode.PARAMETER_CONFLICT, this._adDisabledReason);
                                sessionProperties.webTransportProtocolList = validForAD;
                            }
                        } else {
                            const transportProtocols = sessionProperties.webTransportProtocolList;
                            const validForAD = transportProtocols.every(isValidADTransport);
                            if (!validForAD) {
                                const invalid = transportProtocols.filter(x => !isValidADTransport(x));
                                this._adDisabledReason = `Guaranteed messaging incompatible with selected transport protocols: ` + invalid.map(k => TransportProtocol.describe(k)).join(", ");
                                if (sessionProperties.publisherProperties.enabled) throw new OperationError("Invalid transport protocol(s) for session with Guaranteed Messaging Publisher", ErrorSubcode.PARAMETER_CONFLICT, this._adDisabledReason);
                            }
                        }
                        this._sessionProperties = sessionProperties;
                        this._sessionStats = new Stats();
                        this._hosts = new HostList(sessionProperties);
                        this._sessionFSM = new SessionFSM(this._sessionProperties, this, this._sessionStats, this._hosts);
                        this._sessionFSM.start();
                        this._sessionFSM.createMessagePublisher();
                        this._outstandingDataReqs = {};
                        this._capabilities = DefaultCapabilities.createDefaultCapabilities(sessionProperties);
                        this._seqNum = 1;
                    }
                    connect() {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.CONNECT);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.CONNECT
                        });
                        this._sessionFSM.processEvent(sEvent);
                    }
                    get canAck() {
                        const statesCanAck = [ SessionStateName.CONNECTING, SessionStateName.TRANSPORT_UP, SessionStateName.DISCONNECTING ];
                        return statesCanAck.some(stateName => !!this._sessionFSM.getActiveState(stateName));
                    }
                    disconnect() {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.DISCONNECT);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.DISCONNECT
                        });
                        this._sessionFSM.processEvent(sEvent);
                    }
                    dispose() {
                        const {} = this.logger;
                        if (this._disposed) return;
                        setTimeout(() => {
                            this._sessionFSM.processEvent(new SessionFSMEvent({
                                name: SessionEventName.DISPOSE
                            }));
                            this._sessionFSM.terminateFsm();
                            this.disableEmitter();
                            this._disposed = true;
                        }, 0);
                    }
                    subscribe(topic, requestConfirmation, correlationKey, requestTimeout) {
                        const {} = this.logger;
                        topic && topic.toString && topic.toString();
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                        topic.validate();
                        if (topic.getType() !== DestinationLib.DestinationType.TOPIC) throw new OperationError(`Topic is required for subscribe; ` + DestinationLib.DestinationType.describe(topic.getType()), ErrorSubcode.INVALID_TOPIC_SYNTAX);
                        Parameter.isBooleanOrNothing("requestConfirmation", requestConfirmation);
                        Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                        Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                        const returnCode = this._sessionFSM.subscriptionUpdate(topic, !!requestConfirmation, correlationKey, requestTimeout, SessionRequestType.ADD_SUBSCRIPTION, false, (rxMsgObj, cancelledRequest) => this.handleSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, requestConfirmation));
                        const TransportLib = __webpack_require__("./modules/solclient-transport/api.js");
                        if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) throw new OperationError("Cannot send subscription request - no space in transport. Please try again later (on CAN_ACCEPT_DATA)", ErrorSubcode.INSUFFICIENT_SPACE, TransportLib.TransportReturnCode.describe(returnCode));
                        if (returnCode !== TransportLib.TransportReturnCode.OK) throw new OperationError("Cannot send subscription request - transport error.", ErrorSubcode.COMMUNICATION_ERROR, TransportLib.TransportReturnCode.describe(returnCode));
                        return returnCode;
                    }
                    updateQueueSubscription(topic, queue, add, messageConsumer, callback, requestTimeout) {
                        const {} = this.logger;
                        topic && topic.toString && topic.toString(), queue && queue.toString && queue.toString();
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                        topic.validate();
                        if (topic.getType() !== DestinationLib.DestinationType.TOPIC) throw new OperationError(`Topic is required for queue subscribe; ` + DestinationLib.DestinationType.describe(topic.getType()), ErrorSubcode.INVALID_TOPIC_SYNTAX);
                        Parameter.isInstanceOf("queue", queue, DestinationLib.Destination);
                        queue.validate();
                        if (queue.getType() !== DestinationLib.DestinationType.QUEUE && queue.getType() !== DestinationLib.DestinationType.TEMPORARY_QUEUE) throw new OperationError(`Queue is required for queue subscribe; ` + DestinationLib.DestinationType.describe(queue.getType()), ErrorSubcode.PARAMETER_INVALID_TYPE);
                        Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                        Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                        const returnCode = this._sessionFSM.queueSubscriptionUpdate(topic, queue, requestTimeout, add, false, (rxMsgObj, cancelledRequest) => this.handleQueueSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, callback));
                        const TransportLib = __webpack_require__("./modules/solclient-transport/api.js");
                        if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) throw new OperationError("Cannot send subscription request - no space in transport. Please try again later (on CAN_ACCEPT_DATA)", ErrorSubcode.INSUFFICIENT_SPACE, TransportLib.TransportReturnCode.describe(returnCode));
                        if (returnCode !== TransportLib.TransportReturnCode.OK) throw new OperationError("Cannot send subscription request - transport error.", ErrorSubcode.COMMUNICATION_ERROR, TransportLib.TransportReturnCode.describe(returnCode));
                        return returnCode;
                    }
                    unsubscribe(topic, requestConfirmation, correlationKey, requestTimeout) {
                        const {} = this.logger;
                        topic && topic.toString && topic.toString();
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                        topic.validate();
                        if (topic.getType() !== DestinationLib.DestinationType.TOPIC) throw new OperationError(`Topic is required for unsubscribe; ` + DestinationLib.DestinationType.describe(topic.getType()), ErrorSubcode.INVALID_TOPIC_SYNTAX);
                        Parameter.isBooleanOrNothing("requestConfirmation", requestConfirmation);
                        Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                        Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                        const returnCode = this._sessionFSM.subscriptionUpdate(topic, !!requestConfirmation, correlationKey, requestTimeout, SessionRequestType.REMOVE_SUBSCRIPTION, false, (rxMsgObj, cancelledRequest) => this.handleSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, requestConfirmation));
                        const TransportLib = __webpack_require__("./modules/solclient-transport/api.js");
                        if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) throw new OperationError("Cannot send unsubscribe request - no space in transport. Please try again later (on CAN_ACCEPT_DATA)", ErrorSubcode.INSUFFICIENT_SPACE, TransportLib.TransportReturnCode.describe(returnCode));
                        if (returnCode !== TransportLib.TransportReturnCode.OK) throw new OperationError("Cannot send unsubscribe request - transport error.", ErrorSubcode.COMMUNICATION_ERROR, TransportLib.TransportReturnCode.describe(returnCode));
                        return returnCode;
                    }
                    unsubscribeDurableTopicEndpoint(queueDescriptor) {
                        const {} = this.logger;
                        queueDescriptor && queueDescriptor.toString && queueDescriptor.toString();
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        const destination = this.createDestinationFromDescriptor(QueueDescriptor.createFromSpec(queueDescriptor));
                        const requestConfirmation = true;
                        const returnCode = this._sessionFSM.subscriptionUpdate(destination, requestConfirmation, void 0, void 0, SessionRequestType.REMOVE_DTE_SUBSCRIPTION, false, (rxMsgObj, cancelledRequest) => this.handleDTEUnsubscribeResponse(rxMsgObj, cancelledRequest));
                        const TransportLib = __webpack_require__("./modules/solclient-transport/api.js");
                        if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) throw new OperationError("Cannot send subscription request - no space in transport. Please try again later (on CAN_ACCEPT_DATA)", ErrorSubcode.INSUFFICIENT_SPACE, TransportLib.TransportReturnCode.describe(returnCode));
                        if (returnCode !== TransportLib.TransportReturnCode.OK) throw new OperationError("Cannot send subscription request - transport error.", ErrorSubcode.COMMUNICATION_ERROR, TransportLib.TransportReturnCode.describe(returnCode));
                        return returnCode;
                    }
                    updateProperty(mutableSessionProperty, newValue, requestTimeout, correlationKey) {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        const Topic = DestinationLib.Topic;
                        Parameter.isEnumMember("mutableSessionProperty", mutableSessionProperty, MutableSessionProperty);
                        Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                        Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                        let sessionEvent;
                        const responseCallback = respMsg => {
                            const response = respMsg.getResponse();
                            if (200 === response.responseCode) {
                                if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
                                    this._sessionProperties.applicationDescription = newValue;
                                    sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, response.responseString, response.responseCode, 0, correlationKey, null);
                                    this.sendEvent(sessionEvent);
                                } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
                                    const oldP2pTopicName = P2PUtil.getP2PTopicSubscription(this._sessionProperties.p2pInboxBase);
                                    const oldP2pTopic = Topic.createFromName(oldP2pTopicName);
                                    const newP2pTopicName = P2PUtil.getP2PTopicSubscription(respMsg.getP2PTopicValue());
                                    const newP2pTopic = Topic.createFromName(newP2pTopicName);
                                    const afterAddCallback = smpResp => {
                                        const resp = smpResp.getResponse();
                                        if (200 === resp.responseCode) {
                                            this._sessionProperties._setP2pInboxBase(respMsg.getP2PTopicValue() || "");
                                            this._sessionProperties._setP2pInboxInUse(P2PUtil.getP2PInboxTopic(this._sessionProperties.p2pInboxBase));
                                            this._sessionProperties.clientName = newValue;
                                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, resp.responseString, resp.responseCode, 0, correlationKey, null);
                                            this.sendEvent(sessionEvent);
                                        } else {
                                            const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode, resp.responseString);
                                            if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT && this._sessionProperties.ignoreDuplicateSubscriptionError) {
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, resp.responseString, resp.responseCode, 0, correlationKey, null);
                                                this.sendEvent(sessionEvent);
                                            } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT || errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID || errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED || errorSubcode === ErrorSubcode.SUBSCRIPTION_TOO_MANY) {
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, errorSubcode, correlationKey, null);
                                                this.sendEvent(sessionEvent);
                                            } else {
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, ErrorSubcode.SUBSCRIPTION_ERROR_OTHER, correlationKey, null);
                                                this.sendEvent(sessionEvent);
                                            }
                                        }
                                    };
                                    const afterRemoveCallback = smpResp => {
                                        const resp = smpResp.getResponse();
                                        if (200 === resp.responseCode) this._sessionFSM.subscriptionUpdate(newP2pTopic, true, correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.ADD_P2PINBOX, true, afterAddCallback); else {
                                            const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode, resp.responseString);
                                            if (errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND && this._sessionProperties.ignoreSubscriptionNotFoundError) this._sessionFSM.subscriptionUpdate(newP2pTopic, true, correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.ADD_P2PINBOX, true, afterAddCallback); else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT || errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND || errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED) {
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, errorSubcode, null, null);
                                                this.sendEvent(sessionEvent);
                                            } else {
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, ErrorSubcode.SUBSCRIPTION_ERROR_OTHER, null, null);
                                                this.sendEvent(sessionEvent);
                                            }
                                        }
                                    };
                                    this._sessionFSM.subscriptionUpdate(oldP2pTopic, true, correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.REMOVE_P2PINBOX, true, afterRemoveCallback);
                                }
                            } else {
                                const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(response.responseCode, response.responseString);
                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, response.responseString, response.responseCode, errorSubcode, correlationKey, null);
                                this.sendEvent(sessionEvent);
                            }
                        };
                        const returnCode = this._sessionFSM.sendUpdateProperty(mutableSessionProperty, newValue, correlationKey, requestTimeout, responseCallback);
                        if (returnCode !== TransportReturnCode.OK) {
                            if (returnCode === TransportReturnCode.NO_SPACE) sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, "Property update failed - no space in transport", null, ErrorSubcode.INSUFFICIENT_SPACE, null, null); else sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, "Property update failed", null, ErrorSubcode.INVALID_OPERATION, null, null);
                            this.sendEvent(sessionEvent);
                        }
                    }
                    updateAuthenticationOnReconnect(authenticationProperties) {
                        const {} = this.logger;
                        const allowedProperties = [ "accessToken", "idToken" ];
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        if (!authenticationProperties || "object" !== typeof authenticationProperties) throw new OperationError("updateAuthenticationOnReconnect parameter must be a non-empty object.", ErrorSubcode.PARAMETER_INVALID_TYPE, null);
                        for (var key in authenticationProperties) if (!allowedProperties.includes(key)) throw new OperationError("Invalid property in updateAuthenticationOnReconnect parameter.", ErrorSubcode.PARAMETER_CONFLICT, null);
                        const newProps = this.getSessionProperties();
                        Object.assign(newProps, authenticationProperties);
                        SessionPropertiesValidator.validate(newProps);
                        this._sessionProperties = newProps;
                        Object.assign(this._sessionFSM._sessionProperties, authenticationProperties);
                    }
                    send(message) {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.SEND, message);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isInstanceOf("message", message, MessageLib.Message);
                        if (!this.isCapable(CapabilityType.VAR_LEN_EXT_PARAM)) {
                            message.clearExtendedVarLenParams();
                            if (this._failOnExtendedVariableLengthProperties(message)) throw new OperationError("Broker does not support variable length SMF extended parameters", ErrorSubcode.INVALID_OPERATION);
                        }
                        this.validateAndSendMessage(message);
                    }
                    _failOnExtendedVariableLengthProperties(message) {
                        return false;
                    }
                    sendRequest(message, timeout = void 0, replyReceivedCBFunction = void 0, requestFailedCBFunction = void 0, userObject = void 0) {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.SEND, message);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isInstanceOf("message", message, MessageLib.Message);
                        Parameter.isNumberOrNothing("timeout", timeout);
                        Parameter.isRangeCompareOrNothing("timeout", timeout, ">=", 100);
                        Parameter.isFunctionOrNothing("replyReceivedCBFunction", replyReceivedCBFunction);
                        Parameter.isFunctionOrNothing("requestFailedCBFunction", requestFailedCBFunction);
                        const correlationId = message.getCorrelationId();
                        if (null === correlationId || void 0 === correlationId) message.setCorrelationId(SOLCLIENT_REQUEST_PREFIX + GlobalContext.NextId());
                        const replyTo = message.getReplyTo();
                        if (null === replyTo || void 0 === replyTo) {
                            const replyToTopic = DestinationLib.Topic.createFromName(this._sessionProperties.p2pInboxInUse);
                            message.setReplyTo(replyToTopic);
                        }
                        this.validateAndSendMessage(message);
                        this.enqueueOutstandingDataReq(message.getCorrelationId(), requestFailedCBFunction, timeout, replyReceivedCBFunction, userObject);
                    }
                    sendReply(messageToReplyTo, replyMessage) {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.SEND, replyMessage);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isInstanceOfOrNothing("messageToReplyTo", messageToReplyTo, MessageLib.Message);
                        Parameter.isInstanceOf("replyMessage", replyMessage, MessageLib.Message);
                        replyMessage.setAsReplyMessage(true);
                        if (messageToReplyTo) {
                            replyMessage.setCorrelationId(messageToReplyTo.getCorrelationId());
                            const replyTo = messageToReplyTo.getReplyTo();
                            if (null === replyTo || void 0 === replyTo) throw new OperationError("ReplyTo destination may not be null.", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            replyMessage.setDestination(messageToReplyTo.getReplyTo());
                        }
                        this.validateAndSendMessage(replyMessage);
                    }
                    getStat(statType) {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isEnumMember("statType", statType, StatType);
                        return this._sessionFSM.getStat(statType);
                    }
                    resetStats() {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        this._sessionFSM.resetStats();
                    }
                    getSessionProperties() {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        const properties = this._sessionProperties.clone();
                        const sessionState = this.getSessionState();
                        if (sessionState !== SessionStateName.DISCONNECTED && this._sessionFSM._transport) properties._setWebTransportProtocolInUse(this._sessionFSM._transport.getTransportProtocol());
                        return properties;
                    }
                    isCapable(capabilityType) {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isNumber("capabilityType", capabilityType);
                        const caps = this._capabilities;
                        if (!caps) return false;
                        return "boolean" === typeof caps[capabilityType] ? caps[capabilityType] : false;
                    }
                    getCapability(capabilityType) {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        Parameter.isNumber("capabilityType", capabilityType);
                        const val = this._getCapability(capabilityType);
                        if ("boolean" === typeof val) return SDTField.create(SDTFieldType.BOOL, val);
                        if ("number" === typeof val) return SDTField.create(SDTFieldType.INT64, val);
                        if ("string" === typeof val) return SDTField.create(SDTFieldType.STRING, val);
                        return null;
                    }
                    _getCapability(capabilityType) {
                        const caps = this._capabilities;
                        if (!caps) return null;
                        const value = caps[capabilityType];
                        return void 0 === value ? null : value;
                    }
                    getSessionState() {
                        const {} = this.logger;
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        const sessionStateName = this.getFSMState();
                        switch (sessionStateName) {
                          case SessionStateName.FULLY_CONNECTED:
                            return SessionState.CONNECTED;

                          case SessionStateName.DISCONNECTING:
                            return SessionState.DISCONNECTING;

                          case SessionStateName.DISCONNECTED:
                            return SessionState.DISCONNECTED;

                          case SessionStateName.SESSION_ERROR:
                            return SessionState.SESSION_ERROR;

                          case SessionStateName.CONNECTING:
                          case SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT:
                          case SessionStateName.WAITING_FOR_DNS:
                          case SessionStateName.WAITING_FOR_TRANSPORT_UP:
                          case SessionStateName.WAITING_FOR_SESSION_UP:
                          case SessionStateName.WAITING_FOR_LOGIN:
                          case SessionStateName.WAITING_FOR_P2PINBOX_REG:
                          case SessionStateName.WAITING_FOR_PUBFLOW:
                          case SessionStateName.REAPPLYING_SUBSCRIPTIONS:
                            return SessionState.CONNECTING;

                          default:
                            {
                                const LOG_INFO = this.logger.LOG_INFO;
                                LOG_INFO(`Unmapped session state ` + SessionStateName.describe(sessionStateName));
                                return null;
                            }
                        }
                    }
                    getFSMState() {
                        return this._sessionFSM.getCurrentStateName();
                    }
                    createCacheSession(properties) {
                        const {} = this.logger;
                        return new CacheSession(properties, this, {
                            incStat: this._sessionFSM.incStat.bind(this._sessionFSM)
                        });
                    }
                    createMessageConsumer(consumerProperties) {
                        const {} = this.logger;
                        if (this._adDisabledReason) throw new OperationError("Session does not provide MessageConsumer capability", ErrorSubcode.GM_UNAVAILABLE, this._adDisabledReason);
                        if (void 0 !== consumerProperties && null !== consumerProperties) {
                            const {} = this.logger;
                        }
                        return this._sessionFSM.createMessageConsumer(consumerProperties);
                    }
                    provisionEndpoint(queueDescriptor, queueProperties, ignoreExists, correlationKey) {
                        Parameter.isBooleanOrNothing("ignoreExists", ignoreExists);
                        Parameter.isInstanceOf("queueDescriptor", queueDescriptor, Object, ErrorSubcode.PARAMETER_INVALID_TYPE, "queueDescriptor must be supplied, can't be " + queueDescriptor);
                        Parameter.isString("queueDescriptor.name", queueDescriptor.name, ErrorSubcode.PARAMETER_INVALID_TYPE, "provisionEndpoint only works on named endpoints");
                        const queueDescriptor2 = new QueueDescriptor(queueDescriptor);
                        if (!queueDescriptor2.durable) throw new NotImplementedError("provisionEndpoint() only works for durable endpoints.");
                        if (queueProperties) {
                            Parameter.isInstanceOfOrNothing("queueProperties", queueProperties, Object, ErrorSubcode.PARAMETER_INVALID_TYPE, "queueProperties must be an object, ideally a solace.QueueProperties instance. Can't be " + queueProperties);
                            QueuePropertiesValidator.validate(queueProperties);
                        }
                        const callback = this.handleProvisionResponse.bind(this, ignoreExists, true);
                        return this._sessionFSM.provisionEndpoint(queueDescriptor2, queueProperties, correlationKey, callback);
                    }
                    deprovisionEndpoint(queueDescriptor, ignoreMissing, correlationKey) {
                        Parameter.isBooleanOrNothing("ignoreMissing", ignoreMissing);
                        if (!(queueDescriptor instanceof Object)) throw new OperationError("queueDesscriptor object required", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        Parameter.isString("queueDescriptor.name", queueDescriptor.name, ErrorSubcode.PARAMETER_INVALID_TYPE, "deprovisionEndpoint only works on named endpoints");
                        const callback = this.handleProvisionResponse.bind(this, ignoreMissing, false);
                        return this._sessionFSM.deprovisionEndpoint(queueDescriptor, correlationKey, callback);
                    }
                    handleProvisionResponse(ignore, provision, msg, request) {
                        const correlationKey = request.correlationKey;
                        const responseCode = msg._smfHeader.pm_respcode;
                        const responseString = msg._smfHeader.pm_respstr;
                        const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, responseString);
                        const queueDescriptor = new QueueDescriptor();
                        queueDescriptor.durable = void 0;
                        const queueProperties = new QueueProperties();
                        const DestinationUtil = DestinationLib.DestinationUtil;
                        if (msg.getQueueNameBytes() && msg.getQueueNameBytes().length > 0) {
                            queueDescriptor.name = DestinationUtil.decodeBytes(msg.getQueueNameBytes());
                            queueDescriptor.type = QueueType.QUEUE;
                        } else if (msg.getTopicEndpointBytes() && msg.getTopicEndpointBytes().length > 0) {
                            queueDescriptor.name = DestinationUtil.decodeBytes(msg.getTopicEndpointBytes());
                            queueDescriptor.type = QueueType.TOPIC_ENDPOINT;
                        } else {
                            queueDescriptor.name = void 0;
                            queueDescriptor.type = void 0;
                        }
                        queueDescriptor.durable = msg.getDurability();
                        queueProperties.accessType = msg.getAccessType();
                        queueProperties.discardBehavior = msg.getQueueDiscardBehavior();
                        queueProperties.maxMessageRedelivery = msg.getMaxRedelivery();
                        queueProperties.maxMessageSize = msg.getMaxMsgSize();
                        queueProperties.permissions = msg.getAllOthersPermissions();
                        queueProperties.quotaMB = msg.getQuota();
                        queueProperties.respectsTTL = msg.getRespectsTTL();
                        let reason = null;
                        if (400 === responseCode && (errorSubcode === ErrorSubcode.INVALID_QUEUE_NAME || errorSubcode === ErrorSubcode.INVALID_TE_NAME)) reason = explainInvalidEndpointName(queueDescriptor.name);
                        let outcome = SessionEventCode.PROVISION_ERROR;
                        if (200 === responseCode) outcome = SessionEventCode.PROVISION_OK; else if (ignore && provision && errorSubcode == ErrorSubcode.ENDPOINT_ALREADY_EXISTS) outcome = SessionEventCode.PROVISION_OK; else if (ignore && !provision && (errorSubcode == ErrorSubcode.UNKNOWN_QUEUE_NAME || errorSubcode == ErrorSubcode.UNKNOWN_TOPIC_ENDPOINT_NAME)) outcome = SessionEventCode.PROVISION_OK;
                        const provisionEvent = new ProvisionEvent(outcome, responseString, responseCode, errorSubcode, correlationKey, reason, queueDescriptor, queueProperties);
                        this.sendEvent(provisionEvent);
                    }
                    createQueueBrowser(browserProperties) {
                        const {} = this.logger;
                        if (this._adDisabledReason) throw new OperationError("Session does not provide QueueBrowser capability", ErrorSubcode.GM_UNAVAILABLE, this._adDisabledReason);
                        if (void 0 !== browserProperties && null !== browserProperties) {
                            const {} = this.logger;
                        }
                        return this._sessionFSM.createQueueBrowser(browserProperties);
                    }
                    createDestinationFromDescriptor(queueDescriptor) {
                        const {
                            DestinationType,
                            Queue,
                            Topic
                        } = DestinationLib;
                        let destinationType = DestinationType.TOPIC;
                        if (queueDescriptor.type === QueueType.QUEUE) destinationType = queueDescriptor.durable ? DestinationType.QUEUE : DestinationType.TEMPORARY_QUEUE;
                        const name = queueDescriptor.name || null;
                        if (queueDescriptor.durable) {
                            assert(name, "Durable endpoint with generated name is not a valid configuration");
                            const factoryMethod = queueDescriptor.getType() === QueueType.QUEUE ? Queue.createFromLocalName : Topic.createFromName;
                            return factoryMethod(name);
                        }
                        return this.createTemporaryDestination(destinationType, name);
                    }
                    createTemporaryDestination(destinationType, name) {
                        const {} = this.logger;
                        const {
                            DestinationFromNetwork,
                            DestinationUtil
                        } = DestinationLib;
                        const vrn = this.getSessionProperties().virtualRouterName;
                        if (!this.isCapable(CapabilityType.TEMPORARY_ENDPOINT) || null === vrn || void 0 === vrn || 0 === vrn.length) throw new OperationError("Attempt to generate temporary destination or endpoint without suitable session", ErrorSubcode.INVALID_OPERATION);
                        const localName = name && name.startsWith("#P2P") ? name : DestinationUtil.createTemporaryName(destinationType, vrn, name);
                        localName;
                        return DestinationFromNetwork.createDestinationFromName(localName);
                    }
                    sendEvent(sessionEvent) {
                        if (!sessionEvent) return;
                        if (this._disposed) return;
                        const {} = this.logger;
                        this._eventCallbackInfo.sessionEventCBFunction(this, sessionEvent, this._eventCallbackInfo.userObject);
                    }
                    getTransportInfo() {
                        const {} = this.logger;
                        return this._sessionFSM.getTransportInfo();
                    }
                    injectTransportInterceptor(interceptor) {
                        this._sessionFSM.injectTransportInterceptor(interceptor);
                    }
                    allowOperation(operationEnum, message) {
                        if (!this._sessionFSM) return false;
                        let allow = true;
                        const sessionStateName = this._sessionFSM.getCurrentStateName();
                        if (sessionStateName === SessionStateName.DISPOSED) allow = false; else if (Check.anything(operationEnum)) switch (operationEnum) {
                          case SessionOperation.CONNECT:
                            if (sessionStateName !== SessionStateName.NEW && sessionStateName !== SessionStateName.DISCONNECTED) allow = false;
                            break;

                          case SessionOperation.DISCONNECT:
                            if (sessionStateName === SessionStateName.NEW) allow = false;
                            break;

                          case SessionOperation.SEND:
                          case SessionOperation.CTRL:
                            allow = sessionStateName === SessionStateName.FULLY_CONNECTED || message && message.getDeliveryMode() !== MessageLib.MessageDeliveryModeType.DIRECT;
                            break;

                          case SessionOperation.QUERY_OPERATION:
                            allow = true;
                            break;

                          default:
                            allow = false;
                        } else allow = false;
                        if (allow) return null;
                        return `Cannot perform operation ${operationEnum} while in state ` + sessionStateName;
                    }
                    updateCapabilities(routerCapabilities) {
                        this._capabilities = routerCapabilities;
                    }
                    validateAndSendMessage(message) {
                        const sendDest = message.getDestination();
                        if (Check.nothing(sendDest) || Check.empty(sendDest.getName())) throw new OperationError("Message must have a valid Destination", ErrorSubcode.TOPIC_MISSING);
                        const senderTimestamp = message.getSenderTimestamp();
                        const noSenderTimestamp = null === senderTimestamp || void 0 === senderTimestamp;
                        if (this._sessionProperties.generateSendTimestamps && (noSenderTimestamp || message.hasAutoSenderTimestamp)) {
                            const now = new Date();
                            message.setSenderTimestamp(now.getTime());
                            message.hasAutoSenderTimestamp = true;
                        }
                        const sequenceNumber = message.getSequenceNumber();
                        const noSequenceNumber = null === sequenceNumber || void 0 === sequenceNumber;
                        if (this._sessionProperties.generateSequenceNumber && (noSequenceNumber || message.hasAutoSequenceNumber)) {
                            message.setSequenceNumber(this._seqNum++);
                            message.hasAutoSequenceNumber = true;
                        }
                        const senderId = message.getSenderId();
                        const noSenderId = null === senderId || void 0 === senderId;
                        if (this._sessionProperties.includeSenderId && noSenderId) message.setSenderId(this._sessionProperties.clientName);
                        this._sessionFSM.prepareAndSendMessage(message);
                    }
                    enqueueOutstandingDataReq(correlationId, reqFailedCb, reqTimeout, replyRecvdCb, userObject) {
                        if (Check.none(correlationId)) return;
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        const timer = setTimeout(() => {
                            this._sessionFSM.incStat(StatType.TX_REQUEST_TIMEOUT);
                            try {
                                const result = delete this._outstandingDataReqs[correlationId];
                                if (!result) LOG_ERROR(`Cannot delete data request ` + correlationId);
                            } catch (e) {
                                LOG_ERROR(`Cannot delete data request ` + correlationId, e);
                            }
                            if (Check.anything(reqFailedCb)) {
                                const requestEvent = SessionEvent.build(RequestEventCode.REQUEST_TIMEOUT, "Request timeout", correlationId);
                                reqFailedCb(this, requestEvent, userObject);
                            }
                        }, reqTimeout || this._sessionProperties.readTimeoutInMsecs);
                        const outstandingReq = new OutstandingDataRequest(correlationId, timer, replyRecvdCb, reqFailedCb, userObject);
                        this._outstandingDataReqs[correlationId] = outstandingReq;
                    }
                    cancelOutstandingDataReq(correlationId) {
                        const LOG_ERROR = this.logger.LOG_ERROR;
                        if (Check.none(correlationId) || !this._outstandingDataReqs) return null;
                        const req = this._outstandingDataReqs[correlationId];
                        if (void 0 === req || null === req) return null;
                        if (req.timer) {
                            clearTimeout(req.timer);
                            req.timer = null;
                        }
                        try {
                            const result = delete this._outstandingDataReqs[correlationId];
                            if (!result) LOG_ERROR(`Cannot delete data request ` + correlationId);
                        } catch (e) {
                            LOG_ERROR(`Cannot delete data request ` + correlationId, e);
                        }
                        return req;
                    }
                    cleanupSession() {
                        const {} = this.logger;
                        if (this._outstandingDataReqs) Object.keys(this._outstandingDataReqs).forEach(key => {
                            const dataReq = this.cancelOutstandingDataReq(key);
                            if (dataReq && dataReq.reqFailedCBFunction) {
                                const requestEvent = SessionEvent.build(RequestEventCode.REQUEST_ABORTED, "Request aborted", key);
                                dataReq.reqFailedCBFunction(this, requestEvent, dataReq.userObject);
                            }
                        });
                    }
                    handleDataMessage(dataMessageIn) {
                        const LOG_INFO = this.logger.LOG_INFO;
                        const dataMessage = dataMessageIn;
                        if (this._sessionProperties.generateReceiveTimestamps) {
                            const now = new Date();
                            dataMessage._receiverTimestamp = now.getTime();
                        }
                        if (dataMessage.isReplyMessage()) {
                            const correlationId = dataMessage.getCorrelationId();
                            if (Check.anything(correlationId)) {
                                const dataReq = this.cancelOutstandingDataReq(correlationId);
                                if (null !== dataReq) {
                                    this._sessionFSM.incStat(StatType.RX_REPLY_MSG_RECVED);
                                    dataReq.replyReceivedCBFunction(this, dataMessage, dataReq.userObject);
                                    return;
                                }
                                if (correlationId.startsWith(SOLCLIENT_REQUEST_PREFIX)) {
                                    LOG_INFO("DROP: Discard reply message due to missing outstanding request");
                                    this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
                                    return;
                                }
                                if (correlationId.startsWith(CACHE_REQUEST_PREFIX) && !(CacheSession && this._messageCallbackInfo.userObject instanceof CacheSession)) {
                                    LOG_INFO("DROP: Discard cache reply due to no cache session active");
                                    this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
                                    return;
                                }
                            }
                        }
                        this._messageCallbackInfo.messageRxCBFunction(this, dataMessage, this._messageCallbackInfo.userObject);
                    }
                    handleSubscriptionUpdateResponse(smpMsg, request, requestConfirm) {
                        const response = smpMsg.getResponse();
                        const {
                            responseCode,
                            responseString
                        } = response;
                        const correlationKey = request.correlationKey;
                        if (200 === responseCode) {
                            const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_OK, responseString, responseCode, 0, correlationKey, null);
                            this.sendEvent(sessionEvent);
                        } else {
                            const subscriptionStr = StringUtils.stripNullTerminate(smpMsg.encodedUtf8Subscription);
                            this._sessionFSM.handleSubscriptionUpdateError(responseCode, responseString, subscriptionStr, correlationKey, requestConfirm);
                        }
                    }
                    handleQueueSubscriptionUpdateResponse(smpMsg, request, callback) {
                        const {} = this.logger;
                        if (!smpMsg) {
                            callback(false, ErrorSubcode.TIMEOUT, 0, "Timeout");
                            return;
                        }
                        const response = smpMsg.getResponse();
                        const {
                            responseCode,
                            responseString
                        } = response;
                        const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, responseString);
                        if (200 === responseCode || errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND) callback(true, 0, responseCode, responseString); else callback(false, errorSubcode, responseCode, responseString);
                    }
                    handleDTEUnsubscribeResponse(adCtrlMessage, request) {
                        const response = adCtrlMessage.getResponse();
                        const {
                            responseCode,
                            responseString
                        } = response;
                        const correlationKey = request.correlationKey;
                        const eventCode = 200 === responseCode ? SessionEventCode.UNSUBSCRIBE_TE_TOPIC_OK : SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR;
                        const subcode = 200 === responseCode ? 0 : ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, responseString);
                        this.sendEvent(SessionEvent.build(eventCode, responseString, responseCode, subcode, correlationKey));
                    }
                    handleSubscriptionUpdateError(respCode, respText, subscriptionStr, correlationKey, requestConfirm) {
                        const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                        if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT && this._sessionProperties.ignoreDuplicateSubscriptionError || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND && this._sessionProperties.ignoreSubscriptionNotFoundError) {
                            if (requestConfirm) {
                                const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_OK, respText, respCode, 0, correlationKey, null);
                                this.sendEvent(sessionEvent);
                            }
                        } else {
                            const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_ERROR, respText, respCode, errorSubcode, correlationKey, `Topic: ` + subscriptionStr);
                            this.sendEvent(sessionEvent);
                        }
                    }
                    getEventCBInfo() {
                        return this._eventCallbackInfo;
                    }
                    setEventCBInfo(eventCBInfo) {
                        this._eventCallbackInfo = eventCBInfo;
                    }
                    getMessageCBInfo() {
                        return this._messageCallbackInfo;
                    }
                    setMessageCBInfo(messageCBInfo) {
                        this._messageCallbackInfo = messageCBInfo;
                    }
                    getCorrelationTag() {
                        return this._sessionFSM.getCorrelationTag();
                    }
                    wrapEventCallback(eventCallback) {
                        const LOG_WARN = this.logger.LOG_WARN;
                        const eventCallbackInfo = (() => {
                            if (!eventCallback) return null;
                            if (eventCallback.sessionEventCBFunction) return eventCallback;
                            return new SessionEventCBInfo(eventCallback);
                        })();
                        return new SessionEventCBInfo((session, sessionEvent, obj, rfu) => {
                            const sessionEventCode = sessionEvent.sessionEventCode;
                            if (eventCallbackInfo) try {
                                eventCallbackInfo.sessionEventCBFunction(session, sessionEvent, obj, rfu);
                            } catch (ex) {
                                const error = Object.assign(new OperationError(`Unhandled error in SessionEventRxCBInfo callback on sessionEventCode ` + SessionEventCode.describe(sessionEventCode), ErrorSubcode.CALLBACK_ERROR, `On event: ${[ sessionEventCode, sessionEvent, obj, rfu ]} ` + ex), {
                                    stack: ex.stack,
                                    info: {
                                        event: {
                                            name: sessionEventCode,
                                            formattedName: `SessionEventCode.` + SessionEventCode.describe(sessionEventCode),
                                            args: [ sessionEvent, obj, rfu ]
                                        },
                                        error: ex
                                    }
                                });
                                LOG_WARN(error.toString(), error.info);
                            }
                            this.emit(sessionEventCode, sessionEvent);
                        });
                    }
                    wrapMessageCallback(messageCallback) {
                        const LOG_WARN = this.logger.LOG_WARN;
                        const messageCallbackInfo = (() => {
                            if (!messageCallback) return null;
                            if (messageCallback.messageRxCBFunction) return messageCallback;
                            return new MessageRxCBInfo(messageCallback);
                        })();
                        const formattedName = `SessionEventCode.` + SessionEventCode.describe(SessionEventCode.MESSAGE);
                        const buildErrorEvent = (ex, message, object) => Object.assign(new OperationError(`Unhandled error in MessageRxCBInfo callback/handler for ` + formattedName, ErrorSubcode.CALLBACK_ERROR), {
                            stack: ex.stack,
                            info: {
                                event: {
                                    name: SessionEventCode.MESSAGE,
                                    formattedName: formattedName,
                                    args: [ message, object ]
                                },
                                error: ex
                            }
                        });
                        return new MessageRxCBInfo((session, message, object) => {
                            if (messageCallbackInfo) try {
                                messageCallbackInfo.messageRxCBFunction(session, message, object);
                            } catch (ex) {
                                const error = buildErrorEvent(ex, message, object).toString();
                                LOG_WARN(error, error.info, ex);
                            }
                            try {
                                this.emitDirect(message);
                            } catch (ex) {
                                this.emit("error", buildErrorEvent(ex, message, object));
                            }
                        });
                    }
                    get adLocallyDisabled() {
                        return !!this._adDisabledReason;
                    }
                    get canConnectConsumer() {
                        if (this.adLocallyDisabled) return false;
                        if (this._capabilities) return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME);
                        return;
                    }
                    get canConnectPublisher() {
                        if (this.adLocallyDisabled) return false;
                        if (this._capabilities) return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
                        return;
                    }
                    get disposed() {
                        return this._disposed;
                    }
                    ["inspect"]() {
                        return {
                            sessionId: this._sessionFSM && this._sessionFSM.sessionIdHex || "(N/A)",
                            transport: this.getTransportInfo(),
                            state: SessionState.describe(this.getSessionState())
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.Session = Session;
            },
            "./modules/solclient-session/lib/ssl-downgrades.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SslDowngrade = {
                    NONE: "NONE",
                    PLAINTEXT: "PLAIN_TEXT"
                };
                module.exports.SslDowngrade = Enum.new(SslDowngrade);
            },
            "./modules/solclient-session/lib/subscription-update-timeout-messages.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SessionRequestType = __webpack_require__("./modules/solclient-session/lib/session-request-types.js").SessionRequestType;
                module.exports = {
                    SubscriptionUpdateTimeoutMessages: {
                        [SessionRequestType.ADD_SUBSCRIPTION]: "Add subscription request timeout",
                        [SessionRequestType.REMOVE_SUBSCRIPTION]: "Remove subscription request timeout",
                        [SessionRequestType.ADD_P2PINBOX]: "Add P2P inbox subscription timeout",
                        [SessionRequestType.REMOVE_P2PINBOX]: "Remove P2P inbox subscription timeout",
                        [SessionRequestType.REMOVE_DTE_SUBSCRIPTION]: "Remove endpoint topic subscription",
                        default: "Request timeout"
                    }
                };
            },
            "./modules/solclient-smf/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const CodecLib = __webpack_require__("./modules/solclient-smf/lib/codec/api.js");
                const {
                    AdProtocolMessage,
                    BinaryMetaBlock,
                    ClientCtrlMessage,
                    KeepAliveMessage,
                    SMPMessage
                } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
                const SMFAdProtocolMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-adprotocol-message-types.js").SMFAdProtocolMessageType;
                const SMFAdProtocolParam = __webpack_require__("./modules/solclient-smf/lib/smf-adprotocol-params.js").SMFAdProtocolParam;
                const SMFClientCtrlMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-client-ctrl-message-types.js").SMFClientCtrlMessageType;
                const SMFClientCtrlParam = __webpack_require__("./modules/solclient-smf/lib/smf-client-ctrl-params.js").SMFClientCtrlParam;
                const {
                    SMFParameterType,
                    SMFExtendedParameterType
                } = __webpack_require__("./modules/solclient-smf/lib/smf-parameter-types.js");
                const SMFProtocol = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js").SMFProtocol;
                const SMFSMPMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-types.js").SMFSMPMessageType;
                const SMFSMPMessageTypeFlags = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-type-flags.js").SMFSMPMessageTypeFlags;
                const SMFTransportSessionMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-transport-session-message-types.js").SMFTransportSessionMessageType;
                module.exports.AdProtocolMessage = AdProtocolMessage;
                module.exports.BinaryMetaBlock = BinaryMetaBlock;
                module.exports.ClientCtrlMessage = ClientCtrlMessage;
                module.exports.Codec = CodecLib;
                module.exports.KeepAliveMessage = KeepAliveMessage;
                module.exports.SMFAdProtocolMessageType = SMFAdProtocolMessageType;
                module.exports.SMFAdProtocolParam = SMFAdProtocolParam;
                module.exports.SMFClientCtrlMessageType = SMFClientCtrlMessageType;
                module.exports.SMFClientCtrlParam = SMFClientCtrlParam;
                module.exports.SMFParameterType = SMFParameterType;
                module.exports.SMFProtocol = SMFProtocol;
                module.exports.SMFSMPMessageTypeFlags = SMFSMPMessageTypeFlags;
                module.exports.SMFSMPMessageType = SMFSMPMessageType;
                module.exports.SMFTransportSessionMessageType = SMFTransportSessionMessageType;
                module.exports.SMPMessage = SMPMessage;
                module.exports.SMFExtendedParameterType = SMFExtendedParameterType;
            },
            "./modules/solclient-smf/lib/codec/adprotocol.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const {
                    AdProtocolMessage,
                    SMFParameter
                } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    Bits,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const {
                    LOG_INFO,
                    LOG_ERROR
                } = __webpack_require__("./modules/solclient-log/api.js");
                const ReplayStartType = __webpack_require__("./modules/solclient-replaystart/api.js").ReplayStartType;
                const {
                    get: bits,
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    int16ToStr,
                    int24ToStr,
                    int32ToStr
                } = Convert;
                function parseAdpAt(dataBuf, offset) {
                    if (offset + 3 > dataBuf.length) return false;
                    let pos = offset;
                    let onebyte = dataBuf.readUInt8(pos);
                    pos++;
                    const adpVersion = bits(onebyte, 0, 6);
                    let msgLength;
                    let msgType;
                    if (adpVersion < 3) {
                        const twobyte = dataBuf.readUInt16BE(pos);
                        pos += 2;
                        msgType = bits(twobyte, 12, 4);
                        msgLength = bits(twobyte, 0, 12);
                        msgLength <<= 2;
                    } else if (3 === adpVersion) {
                        onebyte = dataBuf.readUInt8(pos);
                        pos++;
                        msgType = bits(onebyte, 0, 8);
                        msgLength = dataBuf.readUInt32BE(pos);
                        pos += 4;
                    } else {
                        LOG_ERROR("Found unsupported ADP Version", adpVersion);
                        return false;
                    }
                    if (offset + msgLength > dataBuf.length) {
                        LOG_ERROR(`Invalid Asssured Control Protocol length=${msgLength} exceeds remaining message buffer = ` + (dataBuf.length - offset));
                        return false;
                    }
                    const adpMsg = new AdProtocolMessage(msgType, adpVersion);
                    while (pos < offset + msgLength) {
                        onebyte = dataBuf.readUInt8(pos);
                        pos++;
                        const paramUH = bits(onebyte, 6, 2);
                        const paramType = bits(onebyte, 0, 6);
                        if (0 === paramType) continue;
                        if (pos >= offset + msgLength) {
                            LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} at position =` + pos);
                            return false;
                        }
                        let paramLen = dataBuf.readUInt8(pos);
                        let paramValueLen;
                        pos++;
                        if (0 === paramLen) {
                            if (pos + 5 > offset + msgLength) {
                                LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} at position =` + pos);
                                return false;
                            }
                            paramLen = dataBuf.readUInt32BE(pos);
                            pos += 4;
                            paramValueLen = paramLen - 5;
                        } else paramValueLen = paramLen - 2;
                        if (paramLen <= 0) return false;
                        if (pos + paramValueLen > offset + msgLength) {
                            LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} length =${paramValueLen} invalid at position =` + pos);
                            return false;
                        }
                        const smfParam = new SMFParameter(paramUH, paramType, null, dataBuf, pos, pos + paramValueLen);
                        adpMsg.addParameter(smfParam);
                        pos += paramValueLen;
                    }
                    return adpMsg;
                }
                function encAdp0Param(uh, paramtype) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(2));
                    return data.join("");
                }
                function encAdp8Param(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(3));
                    data.push(Convert.int8ToStr(value));
                    return data.join("");
                }
                function encAdp16Param(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(4));
                    data.push(Convert.int16ToStr(value));
                    return data.join("");
                }
                function encAdp32Param(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(6));
                    data.push(Convert.int32ToStr(value));
                    return data.join("");
                }
                function encAdp64Param(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(10));
                    data.push(Convert.int64ToStr(value));
                    return data.join("");
                }
                const RSValueLenMap = {};
                RSValueLenMap[ReplayStartType.BEGINNING] = 3;
                RSValueLenMap[ReplayStartType.DATE] = 11;
                RSValueLenMap[ReplayStartType.RGMID] = 19;
                function encAdpReplayParam(uh, paramtype, value) {
                    const data = [];
                    const valType = value.type;
                    const valObj = value.value;
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(RSValueLenMap[valType]));
                    data.push(Convert.int8ToStr(valType));
                    switch (valType) {
                      case ReplayStartType.DATE:
                        data.push(Convert.int64ToStr(valObj));
                        break;

                      case ReplayStartType.RGMID:
                        data.push(Convert.int64ToStr(valObj.suid));
                        data.push(Convert.int64ToStr(valObj.messageId));
                        break;

                      case ReplayStartType.BEGINNING:
                        break;

                      default:
                        break;
                    }
                    return data.join("");
                }
                function encAdp64AckPairParam(uh, paramtype, min, max, outcome = void 0) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    const paramLength = void 0 == outcome || 0 === outcome ? 18 : 19;
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(paramLength));
                    data.push(Convert.int64ToStr(min));
                    data.push(Convert.int64ToStr(max));
                    if (void 0 != outcome && outcome > 0) data.push(Convert.int8ToStr(outcome));
                    return data.join("");
                }
                function encAdpUTF8NTParam(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    let byte2 = 0;
                    if (value.length <= 253) {
                        byte2 = value.length + 2;
                        data.push(Convert.int8ToStr(byte2));
                    } else {
                        byte2 = 0;
                        data.push(Convert.int8ToStr(byte2));
                        data.push(Convert.int32ToStr(value.length + 5));
                    }
                    data.push(value);
                    return data.join("");
                }
                function encAdp(adpMsg) {
                    const paramspace = [];
                    const paramarray = adpMsg.getParameterArray();
                    let p;
                    for (p = 0; p < paramarray.length; p++) {
                        const param = paramarray[p];
                        if (void 0 === param) continue;
                        switch (param.getType()) {
                          case SMFLib.SMFAdProtocolParam.WINDOW:
                          case SMFLib.SMFAdProtocolParam.EP_DURABLE:
                          case SMFLib.SMFAdProtocolParam.ACCESSTYPE:
                          case SMFLib.SMFAdProtocolParam.FLOWTYPE:
                          case SMFLib.SMFAdProtocolParam.EP_RESPECTS_TTL:
                          case SMFLib.SMFAdProtocolParam.TRANSACTION_CTRL_MESSAGE_TYPE:
                          case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_STATE:
                          case SMFLib.SMFAdProtocolParam.ACTIVE_FLOW_INDICATION:
                          case SMFLib.SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY:
                          case SMFLib.SMFAdProtocolParam.MAX_REDELIVERY:
                            paramspace.push(encAdp8Param(param.getUh(), param.getType(), param.getValue()));
                            break;

                          case SMFLib.SMFAdProtocolParam.EP_BEHAVIOUR:
                          case SMFLib.SMFAdProtocolParam.PARTITION_GROUP_ID:
                            paramspace.push(encAdp16Param(param.getUh(), param.getType(), param.getValue()));
                            break;

                          case SMFLib.SMFAdProtocolParam.FLOWID:
                          case SMFLib.SMFAdProtocolParam.TRANSPORT_WINDOW:
                          case SMFLib.SMFAdProtocolParam.EP_ALLOTHER_PERMISSION:
                          case SMFLib.SMFAdProtocolParam.EP_QUOTA:
                          case SMFLib.SMFAdProtocolParam.EP_MAX_MSGSIZE:
                          case SMFLib.SMFAdProtocolParam.GRANTED_PERMISSION:
                          case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_ID:
                          case SMFLib.SMFAdProtocolParam.PUBLISHER_ID:
                            paramspace.push(encAdp32Param(param.getUh(), param.getType(), param.getValue()));
                            break;

                          case SMFLib.SMFAdProtocolParam.LASTMSGIDSENT:
                          case SMFLib.SMFAdProtocolParam.LASTMSGIDACKED:
                          case SMFLib.SMFAdProtocolParam.LASTMSGIDRECEIVED:
                          case SMFLib.SMFAdProtocolParam.TRANSACTION_ID:
                          case SMFLib.SMFAdProtocolParam.ENDPOINT_ERROR_ID:
                            paramspace.push(encAdp64Param(param.getUh(), param.getType(), param.getValue()));
                            break;

                          case SMFLib.SMFAdProtocolParam.REPLAY_START_LOCATION:
                            {
                                const replayParamVal = param.getValue();
                                if (void 0 === replayParamVal.value) paramspace.push(encAdp8Param(param.getUh(), param.getType(), replayParamVal.type)); else paramspace.push(encAdpReplayParam(param.getUh(), param.getType(), replayParamVal));
                                break;
                            }

                          case SMFLib.SMFAdProtocolParam.APPLICATION_ACK:
                            {
                                const ranges = param.getValue();
                                const uh = param.getUh();
                                const type = param.getType();
                                ranges.forEach((settlementRanges, outcome) => {
                                    for (let i = 0; i < settlementRanges.length; ++i) {
                                        const range = settlementRanges[i];
                                        paramspace.push(encAdp64AckPairParam(uh, type, range[0], range[1], outcome));
                                    }
                                });
                                break;
                            }

                          case SMFLib.SMFAdProtocolParam.QUEUENAME:
                          case SMFLib.SMFAdProtocolParam.DTENAME:
                          case SMFLib.SMFAdProtocolParam.TOPICNAME:
                          case SMFLib.SMFAdProtocolParam.FLOWNAME:
                          case SMFLib.SMFAdProtocolParam.SELECTOR:
                          case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_NAME:
                            paramspace.push(encAdpUTF8NTParam(param.getUh(), param.getType(), param.getValue()));
                            break;

                          case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY:
                            break;

                          case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK:
                            break;

                          case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK:
                            break;

                          case SMFLib.SMFAdProtocolParam.NOLOCAL:
                          case SMFLib.SMFAdProtocolParam.CUT_THROUGH:
                            paramspace.push(encAdp0Param(param.getUh(), param.getType()));
                            break;

                          case SMFLib.SMFAdProtocolParam.APPLICATION_PUB_ACK:
                            break;

                          default:
                            LOG_INFO("Unrecognized ADProtocol Parameter in Message");
                            break;
                        }
                    }
                    const paramdata = paramspace.join("");
                    const data = [];
                    if (2 === adpMsg.version) {
                        let threebytes = 0;
                        threebytes = setBits(threebytes, 0, 22, 2);
                        threebytes = setBits(threebytes, adpMsg.version, 16, 6);
                        threebytes = setBits(threebytes, adpMsg.msgType, 12, 4);
                        let padBytes = 4 - (3 + paramdata.length & 3);
                        const length = 3 + paramdata.length + padBytes >> 2;
                        threebytes = setBits(threebytes, length, 0, 12);
                        data.push(int24ToStr(threebytes));
                        data.push(paramdata);
                        if (4 === padBytes) padBytes = 0;
                        while (padBytes > 0) {
                            data.push(int8ToStr(0));
                            padBytes--;
                        }
                    } else if (3 === adpMsg.version) {
                        let twobytes = 0;
                        twobytes = setBits(twobytes, 0, 14, 2);
                        twobytes = setBits(twobytes, adpMsg.version, 8, 6);
                        twobytes = setBits(twobytes, adpMsg.msgType, 0, 8);
                        data.push(int16ToStr(twobytes));
                        data.push(int32ToStr(6 + paramdata.length));
                        data.push(paramdata);
                    } else LOG_ERROR(`Invalid Version ${adpMsg.version} found while encoding`);
                    return data.join("");
                }
                module.exports.parseAdpAt = parseAdpAt;
                module.exports.encAdp = encAdp;
            },
            "./modules/solclient-smf/lib/codec/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ContentSummaryType = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-types.js").ContentSummaryType;
                const Decode = __webpack_require__("./modules/solclient-smf/lib/codec/decode.js").Decode;
                const Encode = __webpack_require__("./modules/solclient-smf/lib/codec/encode.js").Encode;
                const ParamParse = __webpack_require__("./modules/solclient-smf/lib/codec/param-parse.js").ParamParse;
                const ParseSMF = __webpack_require__("./modules/solclient-smf/lib/codec/parse-smf.js").ParseSMF;
                const Transport = __webpack_require__("./modules/solclient-smf/lib/codec/transport.js").Transport;
                module.exports.ContentSummaryType = ContentSummaryType;
                module.exports.Encode = Encode;
                module.exports.Decode = Decode;
                module.exports.ParamParse = ParamParse;
                module.exports.ParseSMF = ParseSMF;
                module.exports.Transport = Transport;
            },
            "./modules/solclient-smf/lib/codec/client-ctrl.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Bits,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const {
                    ClientCtrlMessage,
                    SMFParameter
                } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
                const LOG_ERROR = __webpack_require__("./modules/solclient-log/api.js").LOG_ERROR;
                const {
                    get: bits,
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    int16ToStr,
                    int32ToStr
                } = Convert;
                function parseCCAt(dataBuf, offset, payloadLen) {
                    const ccMsg = new ClientCtrlMessage();
                    if (payloadLen < 6 || offset + 6 > dataBuf.length) return ccMsg;
                    let pos = offset;
                    const twobytes = dataBuf.readUInt16BE(pos);
                    pos += 2;
                    const version = bits(twobytes, 8, 3);
                    const msgType = bits(twobytes, 0, 8);
                    const len = dataBuf.readUInt32BE(pos);
                    pos += 4;
                    if (1 !== version) {
                        LOG_ERROR(`Unsupported ClientCtrl version ` + version);
                        return false;
                    }
                    if (len <= 0 || offset + len > dataBuf.length) return false;
                    ccMsg.msgType = msgType;
                    ccMsg.version = version;
                    while (pos < offset + len) {
                        const onebyte = dataBuf.readUInt8(pos);
                        pos++;
                        const paramUh = bits(onebyte, 7, 1);
                        const paramType = bits(onebyte, 0, 7);
                        const paramLen = dataBuf.readUInt32BE(pos);
                        if (paramLen <= 0) return false;
                        pos += 4;
                        const paramValueLen = paramLen - 5;
                        const smfP = new SMFParameter(paramUh, paramType, null, dataBuf, pos, pos + paramValueLen);
                        ccMsg.addParameter(smfP);
                        pos += paramValueLen;
                    }
                    return ccMsg;
                }
                function encCC(ccMsg) {
                    const paramSpace = [];
                    const paramArray = ccMsg.getParameterArray();
                    for (let p = 0, n = paramArray.length; p < n; ++p) {
                        const currentParam = paramArray[p];
                        if (void 0 === currentParam) continue;
                        let currentParamOneByte = 0;
                        currentParamOneByte = setBits(currentParamOneByte, currentParam.getUh(), 7, 1);
                        currentParamOneByte = setBits(currentParamOneByte, currentParam.getType(), 0, 7);
                        paramSpace.push(int8ToStr(currentParamOneByte));
                        paramSpace.push(int32ToStr(currentParam.getValue().length + 5));
                        paramSpace.push(currentParam.getValue());
                    }
                    const paramData = paramSpace.join("");
                    let twobytes = 0;
                    twobytes = setBits(twobytes, 0, 15, 1);
                    twobytes = setBits(twobytes, 0, 11, 4);
                    twobytes = setBits(twobytes, 1, 8, 3);
                    twobytes = setBits(twobytes, ccMsg.msgType, 0, 8);
                    const data = [];
                    data.push(int16ToStr(twobytes));
                    data.push(int32ToStr(6 + paramData.length));
                    data.push(paramData);
                    return data.join("");
                }
                module.exports.parseCCAt = parseCCAt;
                module.exports.encCC = encCC;
            },
            "./modules/solclient-smf/lib/codec/content-summary-element.js": module => {
                class ContentSummaryElement {
                    constructor(type = null, position = 0, length = 0) {
                        this.type = type;
                        this.position = position;
                        this.length = length;
                    }
                }
                module.exports.ContentSummaryElement = ContentSummaryElement;
            },
            "./modules/solclient-smf/lib/codec/content-summary-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const ContentSummaryType = {
                    XML_META: 0,
                    XML_PAYLOAD: 1,
                    BINARY_ATTACHMENT: 2,
                    CID_LIST: 3,
                    BINARY_METADATA: 4
                };
                module.exports.ContentSummaryType = Enum.new(ContentSummaryType);
            },
            "./modules/solclient-smf/lib/codec/decode.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
                const SolclientDestinationLib = __webpack_require__("./modules/solclient-destination/api.js");
                const SolclientMessageLib = __webpack_require__("./modules/solclient-message/api.js");
                const {
                    Baggage,
                    TraceContextSetter
                } = __webpack_require__("./modules/solclient-message-tracing/api.js");
                const SolclientSDTLib = __webpack_require__("./modules/solclient-sdt/api.js");
                const {
                    BinaryMetaBlock,
                    KeepAliveMessage
                } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
                const ContentSummaryType = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-types.js").ContentSummaryType;
                const {
                    Hex,
                    Long,
                    Convert: {
                        anythingToBuffer
                    }
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const Lazy = __webpack_require__("./modules/solclient-eskit/api.js").Lazy;
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const parseAdpAt = __webpack_require__("./modules/solclient-smf/lib/codec/adprotocol.js").parseAdpAt;
                const parseCCAt = __webpack_require__("./modules/solclient-smf/lib/codec/client-ctrl.js").parseCCAt;
                const ParseSMF = __webpack_require__("./modules/solclient-smf/lib/codec/parse-smf.js").ParseSMF;
                const PriorityUserCosMap = __webpack_require__("./modules/solclient-smf/lib/codec/priority-user-cos-map.js").PriorityUserCosMap;
                const SMFProtocol = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js").SMFProtocol;
                const SMP = __webpack_require__("./modules/solclient-smf/lib/codec/smp.js").SMP;
                const Transport = __webpack_require__("./modules/solclient-smf/lib/codec/transport.js").Transport;
                __webpack_require__("?41db");
                const fflate = __webpack_require__("./node_modules/fflate/lib/browser.cjs");
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const formatHexString = Hex.formatHexString;
                const lazyValue = Lazy.lazyValue;
                const parseSMFAt = ParseSMF.parseSMFAt;
                const parseSMPAt = SMP.parseSMPAt;
                const parseTsSmfMsgAt = Transport.parseTsSmfMsgAt;
                const logger = new LogFormatter("[smf-decode]");
                const {
                    LOG_ERROR,
                    LOG_WARN
                } = logger;
                const userCosForPriority = lazyValue(() => new PriorityUserCosMap().reverse);
                const BIN_STRUCTYPES = {
                    10: SolclientMessageLib.MessageType.MAP,
                    11: SolclientMessageLib.MessageType.STREAM,
                    7: SolclientMessageLib.MessageType.TEXT
                };
                function adaptBinaryMetaToMessage(binaryMeta, messageIn) {
                    const message = messageIn;
                    const messageSdt = SolclientSDTLib.Codec.parseSingleElement(binaryMeta.payload, 0);
                    if (!(messageSdt && messageSdt.getType() === SolclientSDTLib.SDTFieldType.STREAM)) return;
                    const sdtstream = messageSdt.getValue();
                    let sdtfield = sdtstream.getNext();
                    if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.BYTEARRAY && sdtfield._value && sdtfield._value.length > 0) {
                        let preambleByte0 = sdtfield._value.readUInt8(0);
                        if (0 !== (64 & preambleByte0)) message._setPayloadCompressed(preambleByte0);
                        if (0 === (128 & preambleByte0)) message._messageType = BIN_STRUCTYPES[15 & preambleByte0] || SolclientMessageLib.MessageType.BINARY;
                        if (sdtfield._value.length > 1) {
                            const preambleByte1 = sdtfield._value.readUInt8(1);
                            message.setAsReplyMessage(0 !== (128 & preambleByte1));
                        }
                    }
                    sdtfield = sdtstream.getNext();
                    if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.MAP) {
                        const sdtMap = sdtfield.getValue();
                        const p = sdtMap.getField("p");
                        const h = sdtMap.getField("h");
                        if (p) message.setUserPropertyMap(p.getValue());
                        if (h) {
                            const headerMap = h.getValue();
                            const ci = headerMap.getField("ci");
                            const mi = headerMap.getField("mi");
                            const mt = headerMap.getField("mt");
                            const rt = headerMap.getField("rt");
                            const si = headerMap.getField("si");
                            const sn = headerMap.getField("sn");
                            const ts = headerMap.getField("ts");
                            const ex = headerMap.getField("ex");
                            const ce = headerMap.getField("ce");
                            const ct = headerMap.getField("ct");
                            const bag = headerMap.getField("bag");
                            const ctx = headerMap.getField("ctx");
                            if (ci) message.setCorrelationId(ci.getValue());
                            if (mi) message.setApplicationMessageId(mi.getValue());
                            if (mt) message.setApplicationMessageType(mt.getValue());
                            if (rt) message.setReplyTo(rt.getValue());
                            if (si) message.setSenderId(si.getValue());
                            if (sn) message.setSequenceNumber(sn.getValueNoThrow());
                            if (ts) message.setSenderTimestamp(ts.getValue());
                            if (ex) message.setGMExpiration(ex.getValue());
                            if (ce) message.setHttpContentEncoding(ce.getValue());
                            if (ct) message.setHttpContentType(ct.getValue());
                            if (bag) {
                                const _baggageObj = new Baggage();
                                _baggageObj.setBaggage(bag.getValue());
                                message._setBaggage(_baggageObj);
                            }
                            if (ctx) {
                                const _traceContextSetter = TraceContextSetter.fromTraceContext(ctx.getValue());
                                message._setCreationContext(_traceContextSetter);
                            }
                        }
                    }
                }
                function adaptSmfToMessage(smfHeader, messageIn, stream, offset) {
                    const message = messageIn;
                    message._setDeliverToOne(!!smfHeader.smf_dto);
                    message._setDeliveryMode(smfHeader.pm_deliverymode || SolclientMessageLib.MessageDeliveryModeType.DIRECT);
                    if (null !== smfHeader.pm_tr_topicname_bytes) message._setDestination(SolclientDestinationLib.DestinationFromNetwork.createDestinationFromBytes(smfHeader.pm_tr_topicname_bytes));
                    message._setDiscardIndication(!!smfHeader.smf_di);
                    message._setElidingEligible(!!smfHeader.smf_elidingEligible);
                    message._setDMQEligible(!!smfHeader.smf_deadMessageQueueEligible);
                    message._setUserCos(userCosForPriority.value.get(smfHeader.smf_priority));
                    message._setPriority(smfHeader.pm_msg_priority);
                    if (smfHeader.pm_userdata) message._setUserData(smfHeader.pm_userdata);
                    message.setRedelivered(!!smfHeader.pm_ad_redelflag || !!smfHeader.pm_ad_flowredelflag);
                    message.setFlowId(smfHeader.pm_ad_flowid);
                    message.setGuaranteedMessageId(smfHeader.pm_ad_msgid);
                    message.setGuaranteedPreviousMessageId(smfHeader.pm_ad_prevmsgid);
                    message.setPublisherId(smfHeader.pm_ad_publisherid);
                    message.setPublisherMessageId(smfHeader.pm_ad_publishermsgid);
                    message.setTopicSequenceNumber(smfHeader.pm_ad_topicSequenceNumber);
                    if (message.getDeliveryMode() === SolclientMessageLib.MessageDeliveryModeType.DIRECT) message.setDeliveryCount(-1); else if (smfHeader.pm_ad_redeliveryCount) message.setDeliveryCount(smfHeader.pm_ad_redeliveryCount + 1); else message.setDeliveryCount(1);
                    if (smfHeader.pm_ad_spooler_unique_id) message._setSpoolerUniqueId(smfHeader.pm_ad_spooler_unique_id);
                    if (smfHeader.pm_ad_replication_mate_ack_message_id) message._setSpoolerMessageId(smfHeader.pm_ad_replication_mate_ack_message_id); else if (smfHeader.pm_ad_local_spooler_message_id) message._setSpoolerMessageId(smfHeader.pm_ad_local_spooler_message_id);
                    if (Long.isLong(smfHeader.pm_ad_ttl)) message.setTimeToLive(smfHeader.pm_ad_ttl.toNumber()); else message.setTimeToLive(smfHeader.pm_ad_ttl);
                    if (smfHeader.pm_ts_transport_context) {
                        const _traceContextSetter = TraceContextSetter.fromTraceContext(smfHeader.pm_ts_transport_context);
                        message._setTransportContext(_traceContextSetter);
                    }
                    const payloadOffset = offset + smfHeader.headerLength;
                    const cs = smfHeader.pm_content_summary;
                    if (!(cs && cs.length)) {
                        message._setBinaryAttachment(smfHeader.payloadLength > 0 ? stream.slice(payloadOffset, payloadOffset + smfHeader.payloadLength) : void 0);
                        return;
                    }
                    for (let i = 0, n = cs.length; i < n; ++i) {
                        const currentChunk = cs[i];
                        const chunkBegin = payloadOffset + currentChunk.position;
                        const chunkEnd = payloadOffset + currentChunk.position + currentChunk.length;
                        switch (currentChunk.type) {
                          case ContentSummaryType.BINARY_ATTACHMENT:
                            message._setBinaryAttachment(stream.slice(chunkBegin, chunkEnd));
                            break;

                          case ContentSummaryType.BINARY_METADATA:
                            {
                                const binaryMeta = BinaryMetaBlock.fromEncodedSmf(stream, chunkBegin);
                                message.binaryMetadataChunk = binaryMeta;
                                if (0 === binaryMeta.type) adaptBinaryMetaToMessage(binaryMeta, message);
                                break;
                            }

                          case ContentSummaryType.XML_META:
                            message._setXmlMetadata(stream.toString("latin1", chunkBegin, chunkEnd));
                            break;

                          case ContentSummaryType.XML_PAYLOAD:
                            message._setXmlContentInternal(stream.toString("latin1", chunkBegin, chunkEnd));
                            break;

                          default:
                            LOG_ERROR(`Unhandled ContentSummaryType: ` + ContentSummaryType.describe(currentChunk.type));
                        }
                    }
                    if (message._getPayloadCompressed() && Check.anything(message.getHttpContentEncoding())) if (message.getHttpContentEncoding().endsWith("deflate")) try {
                        let inflatedAttachment;
                        if (false); else {
                            inflatedAttachment = fflate.unzlibSync(message._binaryAttachment);
                            inflatedAttachment = anythingToBuffer(inflatedAttachment);
                        }
                        message._setBinaryAttachment(inflatedAttachment);
                        message._setPayloadCompressed(null);
                        if ("deflate" === message.getHttpContentEncoding().trim()) delete message._httpContentEncoding; else {
                            let newCE = message.getHttpContentEncoding().slice(0, 0 - "deflate".length).trimRight();
                            if (newCE.endsWith(",")) {
                                newCE = newCE.slice(0, -1);
                                message.setHttpContentEncoding(newCE);
                            } else delete message._httpContentEncoding;
                        }
                    } catch (err) {
                        LOG_WARN("Message payload was not decompressed, there was an error. Leaving the message body compressed ", err);
                        message._messageType = SolclientMessageLib.MessageType.BINARY;
                    }
                }
                function decodeCompoundMessage(dataBuf, pos) {
                    const header = parseSMFAt(dataBuf, pos);
                    if (!header) return null;
                    const payloadPosition = pos + header.headerLength;
                    const payloadLen = header.payloadLength;
                    let message;
                    switch (header.smf_protocol) {
                      case SMFProtocol.TSESSION:
                        message = parseTsSmfMsgAt(dataBuf, payloadPosition, header);
                        if (!message) break;
                        message.smfHeader = header;
                        return message;

                      case SMFProtocol.TRMSG:
                        message = new SolclientMessageLib.Message();
                        message._smfHeader = header;
                        adaptSmfToMessage(header, message, dataBuf, pos);
                        return message;

                      case SMFProtocol.ADCTRL:
                        message = parseAdpAt(dataBuf, payloadPosition, payloadLen);
                        message.smfHeader = header;
                        return message;

                      case SMFProtocol.CLIENTCTRL:
                        message = parseCCAt(dataBuf, payloadPosition, payloadLen);
                        if (!message) break;
                        message.smfHeader = header;
                        return message;

                      case SMFProtocol.SMP:
                        message = parseSMPAt(dataBuf, payloadPosition);
                        if (!message) break;
                        message.smfHeader = header;
                        return message;

                      case SMFProtocol.KEEPALIVE:
                      case SMFProtocol.KEEPALIVEV2:
                        message = new KeepAliveMessage();
                        message.smfHeader = header;
                        return message;

                      default:
                        LOG_ERROR(`Unknown protocol: 0x${formatHexString(header.smf_protocol)}, ` + `dump message content: 
` + DebugLib.Debug.formatDumpBytes(dataBuf.slice(pos, pos + header.messageLength).toString("latin1"), true, 0));
                        break;
                    }
                    return null;
                }
                const Decode = {
                    decodeCompoundMessage: decodeCompoundMessage
                };
                module.exports.Decode = Decode;
            },
            "./modules/solclient-smf/lib/codec/encode.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
                const {
                    Base64,
                    Bits,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const {
                    BinaryMetaBlock,
                    SMFHeader,
                    SMPMessage
                } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const {
                    ClientCtrlMessage,
                    KeepAliveMessage,
                    AdProtocolMessage
                } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
                const SDTCodec = __webpack_require__("./modules/solclient-sdt/api.js").Codec;
                const ContentSummaryElement = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-element.js").ContentSummaryElement;
                const ContentSummaryType = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-types.js").ContentSummaryType;
                const DestinationType = __webpack_require__("./modules/solclient-destination/api.js").DestinationType;
                const encAdp = __webpack_require__("./modules/solclient-smf/lib/codec/adprotocol.js").encAdp;
                const encCC = __webpack_require__("./modules/solclient-smf/lib/codec/client-ctrl.js").encCC;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const Lazy = __webpack_require__("./modules/solclient-eskit/api.js").Lazy;
                const LOG_INFO = __webpack_require__("./modules/solclient-log/api.js").LOG_INFO;
                const ParamParse = __webpack_require__("./modules/solclient-smf/lib/codec/param-parse.js").ParamParse;
                const PriorityUserCosMap = __webpack_require__("./modules/solclient-smf/lib/codec/priority-user-cos-map.js").PriorityUserCosMap;
                const {
                    SDTField,
                    SDTFieldType,
                    SDTMapContainer,
                    SDTStreamContainer
                } = __webpack_require__("./modules/solclient-sdt/api.js");
                const {
                    SMFParameterType,
                    SMFExtendedParameterType
                } = __webpack_require__("./modules/solclient-smf/lib/smf-parameter-types.js");
                const SMFProtocol = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js").SMFProtocol;
                const SMP = __webpack_require__("./modules/solclient-smf/lib/codec/smp.js").SMP;
                const base64Encode = Base64.encode;
                const setBits = Bits.set;
                const {
                    int8ToStr,
                    int16ToStr,
                    int24ToStr,
                    int32ToStr,
                    int64ToStr,
                    uint8ArrayToString
                } = Convert;
                const lazyValue = Lazy.lazyValue;
                const {
                    encContentSummary,
                    encDeliveryMode,
                    encLightSMFParam,
                    encodeSMFParam,
                    encodeSMFExtendedParam,
                    FORCED_LENGTH_MODE
                } = ParamParse;
                const encodeSingleElement = SDTCodec.encodeSingleElement;
                const encSmp = SMP.encSmp;
                const priorityForUserCos = lazyValue(() => new PriorityUserCosMap().forward);
                function addContentElementToArrays(csumm, payloadArray, dataChunk, cstype) {
                    if (Check.anything(dataChunk) && dataChunk.length > 0) {
                        const cse = new ContentSummaryElement(cstype, NaN, dataChunk.length);
                        csumm.push(cse);
                        payloadArray.push(dataChunk);
                    }
                }
                function addToMapIfPresent(headerMap, key, type, value) {
                    if (Check.anything(value)) headerMap.addField(key, SDTField.create(type, value));
                }
                function adaptMessageToBinaryMeta(message) {
                    let result;
                    const headerMap = new SDTMapContainer();
                    addToMapIfPresent(headerMap, "ci", SDTFieldType.STRING, message.getCorrelationId());
                    addToMapIfPresent(headerMap, "mi", SDTFieldType.STRING, message.getApplicationMessageId());
                    addToMapIfPresent(headerMap, "mt", SDTFieldType.STRING, message.getApplicationMessageType());
                    addToMapIfPresent(headerMap, "rt", SDTFieldType.DESTINATION, message.getReplyTo());
                    addToMapIfPresent(headerMap, "si", SDTFieldType.STRING, message.getSenderId());
                    addToMapIfPresent(headerMap, "sn", SDTFieldType.INT64, message.getSequenceNumber());
                    addToMapIfPresent(headerMap, "ts", SDTFieldType.INT64, message.getSenderTimestamp());
                    addToMapIfPresent(headerMap, "ex", SDTFieldType.INT64, message.getGMExpiration());
                    addToMapIfPresent(headerMap, "ce", SDTFieldType.STRING, message._compressedCE ? message._compressedCE : message.getHttpContentEncoding());
                    addToMapIfPresent(headerMap, "ct", SDTFieldType.STRING, message.getHttpContentType());
                    const _baggage = message.getBaggage();
                    addToMapIfPresent(headerMap, "bag", SDTFieldType.STRING, _baggage ? _baggage.getBaggage() : null);
                    const _creationContext = message.getCreationContext();
                    addToMapIfPresent(headerMap, "ctx", SDTFieldType.BYTEARRAY, _creationContext ? _creationContext.getEncodedTraceContext() : null);
                    const sdtMap = new SDTMapContainer();
                    if (message.getUserPropertyMap()) sdtMap.addField("p", SDTField.create(SDTFieldType.MAP, message.getUserPropertyMap()));
                    if (headerMap.getKeys().length > 0) sdtMap.addField("h", SDTField.create(SDTFieldType.MAP, headerMap));
                    let preambleByte0 = 0;
                    if (Check.anything(message._getCompressedBinaryAttachment())) preambleByte0 |= 64;
                    switch (message.getType()) {
                      case MessageLib.MessageType.BINARY:
                        preambleByte0 |= 128;
                        break;

                      case MessageLib.MessageType.MAP:
                        preambleByte0 |= 10;
                        if (Check.nothing(message._getCompressedBinaryAttachment())) result = encodeSingleElement(message._structuredContainer);
                        break;

                      case MessageLib.MessageType.STREAM:
                        preambleByte0 |= 11;
                        if (Check.nothing(message._getCompressedBinaryAttachment())) result = encodeSingleElement(message._structuredContainer);
                        break;

                      case MessageLib.MessageType.TEXT:
                        preambleByte0 |= 7;
                        if (Check.nothing(message._getCompressedBinaryAttachment())) result = encodeSingleElement(message._structuredContainer);
                        break;

                      default:
                        LOG_INFO(`Unhandled messageType: ` + message.getType());
                        break;
                    }
                    const preambleByte1 = message.isReplyMessage() ? 128 : 0;
                    const sdtPreamble = SDTField.create(SDTFieldType.BYTEARRAY, String.fromCharCode(preambleByte0, preambleByte1));
                    const sdtStreamContainer = new SDTStreamContainer();
                    sdtStreamContainer.addField(sdtPreamble);
                    sdtStreamContainer.addField(SDTField.create(SDTFieldType.MAP, sdtMap));
                    const binaryMeta = new BinaryMetaBlock();
                    binaryMeta.type = 0;
                    binaryMeta.payload = encodeSingleElement(SDTField.create(SDTFieldType.STREAM, sdtStreamContainer));
                    message.binaryMetadataChunk = binaryMeta;
                    return result;
                }
                function adaptMessageToSmf_nonPayload(message, smfHeaderIn) {
                    const smfHeader = smfHeaderIn;
                    const deliveryMode = message.getDeliveryMode();
                    smfHeader.smf_dto = message.isDeliverToOne();
                    smfHeader.pm_deliverymode = deliveryMode;
                    smfHeader.smf_adf = deliveryMode === MessageLib.MessageDeliveryModeType.DIRECT ? 0 : 1;
                    smfHeader.smf_di = message.isDiscardIndication();
                    smfHeader.smf_elidingEligible = message.isElidingEligible();
                    smfHeader.smf_deadMessageQueueEligible = message.isDMQEligible();
                    smfHeader.pm_ad_flowid = message.getFlowId();
                    smfHeader.pm_ad_publisherid = message.getPublisherId();
                    smfHeader.pm_ad_publishermsgId = message.getPublisherMessageId();
                    smfHeader.pm_ad_msgid = message.getGuaranteedMessageId();
                    smfHeader.pm_ad_prevmsgid = message.getGuaranteedPreviousMessageId();
                    smfHeader.pm_ad_ttl = message.getTimeToLive();
                    smfHeader.pm_ad_ackimm = message.isAcknowledgeImmediately();
                    smfHeader.pm_ad_redelflag = message.isRedelivered();
                    const _transportContext = message.getTransportContext();
                    if (null != _transportContext) smfHeader.pm_ts_transport_context = _transportContext.getEncodedTraceContext();
                    const dest = message.getDestination();
                    if (dest) {
                        smfHeader.pm_tr_topicname_bytes = dest.getBytes();
                        if (dest.type === DestinationType.QUEUE || dest.type === DestinationType.TEMPORARY_QUEUE) {
                            const offset = dest.offset;
                            smfHeader.pm_queue_len = smfHeader.pm_tr_topicname_bytes.length - offset;
                            smfHeader.pm_queue_offset = offset;
                        }
                    }
                    smfHeader.smf_priority = priorityForUserCos.value.get(message.getUserCos());
                    if (void 0 !== message.getPriority() && "number" === typeof message.getPriority() && message.getPriority() <= 255 && message.getPriority() >= 0) smfHeader.pm_msg_priority = message.getPriority(); else smfHeader.pm_msg_priority = null;
                    const userData = message.getUserData();
                    smfHeader.pm_userdata = null === userData || void 0 === userData ? null : message.getUserData();
                }
                function adaptMessageToSmf_payloadMemoize(message) {
                    let encodedSdtPayload;
                    if (message.getCorrelationId() || message.getApplicationMessageId() || message.getApplicationMessageType() || message.getReplyTo() || message.getSenderId() || message.getSequenceNumber() || message.getSenderTimestamp() || message.getUserPropertyMap() || message.isReplyMessage() || message.getCreationContext() || message._compressedCE || message.getHttpContentEncoding() || message.getHttpContentType() || message.getBaggage() && message.getBaggage().getBaggage() || message.getType() !== MessageLib.MessageType.BINARY) encodedSdtPayload = adaptMessageToBinaryMeta(message);
                    const csumm = [];
                    const payload = [];
                    addContentElementToArrays(csumm, payload, message.getXmlMetadata(), ContentSummaryType.XML_META);
                    addContentElementToArrays(csumm, payload, message.getXmlContent(), ContentSummaryType.XML_PAYLOAD);
                    if (encodedSdtPayload) addContentElementToArrays(csumm, payload, encodedSdtPayload, ContentSummaryType.BINARY_ATTACHMENT); else if (Check.anything(message._getCompressedBinaryAttachment())) addContentElementToArrays(csumm, payload, message._getCompressedBinaryAttachment().toString("latin1"), ContentSummaryType.BINARY_ATTACHMENT); else addContentElementToArrays(csumm, payload, message._binaryAttachment ? message._binaryAttachment.toString("latin1") : "", ContentSummaryType.BINARY_ATTACHMENT);
                    const binaryMeta = message.binaryMetadataChunk;
                    if (null !== binaryMeta) {
                        const binaryMetaSMF = binaryMeta.asEncodedSmf();
                        const MAX_24BITS = 16777215;
                        if (binaryMetaSMF.length > MAX_24BITS) {
                            binaryMetaSMF.length, MAX_24BITS;
                            throw new OperationError(`binary-meta data (${binaryMetaSMF.length}) over the ${MAX_24BITS} limit`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        } else addContentElementToArrays(csumm, payload, binaryMetaSMF, ContentSummaryType.BINARY_METADATA);
                    }
                    message._memoized_csumm = csumm;
                    message._memoized_payload = payload.join("");
                    message._payload_is_memoized = true;
                    return message._memoized_payload ? message._memoized_payload.length : 0;
                }
                function adaptMessageToSmf_payloadFinalize(message, smfHeaderIn) {
                    const smfHeader = smfHeaderIn;
                    if (!message._payload_is_memoized) adaptMessageToSmf_payloadMemoize(message);
                    const csumm = message._memoized_csumm;
                    const payloadBytes = message._memoized_payload;
                    if (0 === csumm.length || 1 === csumm.length && csumm[0].type === ContentSummaryType.BINARY_ATTACHMENT); else smfHeader.pm_content_summary = csumm;
                    smfHeader.payload = payloadBytes;
                }
                function adaptMessageToSmf(message, smfHeaderIn) {
                    adaptMessageToSmf_payloadFinalize(message, smfHeaderIn);
                    adaptMessageToSmf_nonPayload(message, smfHeaderIn);
                }
                const bitRange = bits => Array.from(Array(Math.pow(2, bits))).map((el, i) => i);
                const maskValues = (shift, bits) => bitRange(bits).map(val => setBits(0, val, shift, bits));
                const DI_BIT = maskValues(31, 1);
                const ELIDING_ELIGIBLE_BIT = maskValues(30, 1);
                const DTO_BIT = maskValues(29, 1);
                const ADF_BIT = maskValues(28, 1);
                const DMQE_BIT = maskValues(27, 1);
                const VERSION_BITS = maskValues(24, 3);
                const UH_BITS = maskValues(22, 2);
                const PROTOCOL_BITS = maskValues(16, 6);
                const PRIORITY_BITS = maskValues(12, 4);
                const TTL_BITS = maskValues(0, 8);
                const QT_OFFSET_BYTES = maskValues(8, 8);
                const QT_LEN_BYTES = maskValues(0, 8);
                function encodeSMF(header) {
                    let w1 = 0;
                    w1 |= DI_BIT[header.smf_di && 1 || 0];
                    w1 |= ELIDING_ELIGIBLE_BIT[header.smf_elidingEligible && 1 || 0];
                    w1 |= DTO_BIT[header.smf_dto && 1 || 0];
                    w1 |= ADF_BIT[header.smf_adf && 1 || 0];
                    w1 |= DMQE_BIT[header.smf_deadMessageQueueEligible && 1 || 0];
                    w1 |= VERSION_BITS[header.smf_version || 0];
                    w1 |= UH_BITS[header.smf_uh || 0];
                    w1 |= PROTOCOL_BITS[header.smf_protocol || 0];
                    w1 |= PRIORITY_BITS[header.smf_priority || 0];
                    w1 |= TTL_BITS[header.smf_ttl || 0];
                    const params = [];
                    if (header.pm_tr_topicname_bytes) params.push(encodeSMFParam(2, SMFParameterType.TR_TOPICNAME, `` + header.pm_tr_topicname_bytes));
                    if (header.pm_queue_len) params.push(encLightSMFParam(0, SMFParameterType.LIGHT_QUEUE_NAME_OFFSET, int16ToStr(QT_OFFSET_BYTES[header.pm_queue_offset] | QT_LEN_BYTES[header.pm_queue_len])));
                    if (header.pm_topic_len) params.push(encLightSMFParam(0, SMFParameterType.LIGHT_TOPIC_NAME_OFFSET, int16ToStr(QT_OFFSET_BYTES[header.pm_topic_offset] | QT_OFFSET_BYTES[header.pm_topic_len])));
                    if (null !== header.pm_corrtag && void 0 !== header.pm_corrtag) params.push(encLightSMFParam(0, SMFParameterType.LIGHT_CORRELATION, int24ToStr(header.pm_corrtag)));
                    if (header.pm_ad_ackimm) params.push(encLightSMFParam(0, SMFParameterType.LIGHT_ACK_IMMEDIATELY, ""));
                    if (null !== header.pm_msg_priority) params.push(encodeSMFParam(0, SMFParameterType.MESSAGEPRIORITY, int8ToStr(header.pm_msg_priority)));
                    if (null !== header.pm_userdata && "" !== header.pm_userdata) params.push(encodeSMFParam(0, SMFParameterType.USERDATA, header.pm_userdata));
                    if (header.pm_username) params.push(encodeSMFParam(0, SMFParameterType.USERNAME, base64Encode(header.pm_username)));
                    if (header.pm_password) params.push(encodeSMFParam(0, SMFParameterType.PASSWORD, base64Encode(header.pm_password)));
                    if (header.pm_respcode) params.push(encodeSMFParam(0, SMFParameterType.RESPONSE, int32ToStr(header.pm_respcode) + header.pm_respstr));
                    if (null !== header.pm_deliverymode) params.push(encodeSMFParam(0, SMFParameterType.DELIVERY_MODE, encDeliveryMode(header.pm_deliverymode)));
                    if (void 0 !== header.pm_ad_msgid) {
                        params.push(encodeSMFParam(2, SMFParameterType.ASSURED_MESSAGE_ID, int64ToStr(header.pm_ad_msgid)));
                        params.push(encodeSMFParam(2, SMFParameterType.ASSURED_PREVMESSAGE_ID, int64ToStr(header.pm_ad_prevmsgid)));
                    }
                    if (header.pm_ad_flowid) params.push(encodeSMFParam(0, SMFParameterType.ASSURED_FLOWID, int32ToStr(header.pm_ad_flowid)));
                    if (header.pm_ad_redelflag) params.push(encodeSMFParam(0, SMFParameterType.ASSURED_REDELIVERED_FLAG, void 0));
                    if (void 0 !== header.pm_ad_ttl) params.push(encodeSMFParam(0, SMFParameterType.AD_TIMETOLIVE, int64ToStr(header.pm_ad_ttl)));
                    if (header.pm_ad_publisherid) params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_ID, int32ToStr(header.pm_ad_publisherid)));
                    if (header.pm_ad_publisherMsgId) params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_MSGID, int64ToStr(header.pm_ad_publisherMsgId)));
                    if (header.pm_content_summary) params.push(encodeSMFParam(2, SMFParameterType.MESSAGE_CONTENT_SUMMARY, encContentSummary(header.pm_content_summary)));
                    let extendedStreamContents = "";
                    let extendedUH = 0;
                    if (header.pm_oauth2_access_token) {
                        extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OAUTH2_ACCESS_TOKEN, header.pm_oauth2_access_token);
                        extendedUH = extendedUH || 0;
                    }
                    if (header.pm_oidc_id_token) {
                        extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OIDC_ID_TOKEN, header.pm_oidc_id_token);
                        extendedUH = extendedUH || 0;
                    }
                    if (header.pm_oauth2_issuer_identifier) {
                        extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OAUTH2_ISSUER_IDENTIFIER, header.pm_oauth2_issuer_identifier);
                        extendedUH = extendedUH || 0;
                    }
                    if (header.pm_ts_transport_context) {
                        extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.TS_TRANSPORT_CONTEXT, uint8ArrayToString(header.pm_ts_transport_context), FORCED_LENGTH_MODE.SIX);
                        extendedUH = extendedUH || 0;
                    }
                    if (extendedStreamContents.length > 0) params.push(encodeSMFParam(extendedUH, SMFParameterType.EXTENDED_TYPE_STREAM, extendedStreamContents));
                    const encodedParams = params.join("");
                    const hdrlen = 12 + encodedParams.length;
                    const msglen = hdrlen + header.payloadLength;
                    header.setMessageSizes(hdrlen, header.payloadLength);
                    return int32ToStr(w1) + int32ToStr(hdrlen) + int32ToStr(msglen) + encodedParams;
                }
                function encodeCompoundMessage(msg) {
                    let payload = "";
                    if (msg instanceof MessageLib.Message) {
                        if (!msg.smfHeader) msg.smfHeader = new SMFHeader(SMFProtocol.TRMSG, 255);
                        adaptMessageToSmf(msg, msg._smfHeader);
                        payload = msg._smfHeader.payload;
                    } else if (msg instanceof ClientCtrlMessage) payload = encCC(msg); else if (msg instanceof SMPMessage) payload = encSmp(msg); else if (msg instanceof KeepAliveMessage); else if (msg instanceof AdProtocolMessage) payload = encAdp(msg);
                    const header = msg.smfHeader;
                    header.setPayloadSize(payload.length);
                    const encodedHeader = encodeSMF(header);
                    return encodedHeader + payload;
                }
                const Encode = {
                    encodeCompoundMessage: encodeCompoundMessage,
                    encodeSMF: encodeSMF,
                    adaptMessageToSmf_payloadMemoize: adaptMessageToSmf_payloadMemoize
                };
                module.exports.Encode = Encode;
            },
            "./modules/solclient-smf/lib/codec/param-parse.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
                const {
                    BidiMap,
                    Lazy
                } = __webpack_require__("./modules/solclient-eskit/api.js");
                const {
                    Bits,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const ContentSummaryElement = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-element.js").ContentSummaryElement;
                const ContentSummaryType = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-types.js").ContentSummaryType;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const LOG_ERROR = __webpack_require__("./modules/solclient-log/api.js").LOG_ERROR;
                const SMFUH = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js").SMFUH;
                const lazyValue = Lazy.lazyValue;
                const {
                    int8ToStr,
                    int16ToStr,
                    int24ToStr,
                    int32ToStr
                } = Convert;
                const delModeEnumBidiMap = lazyValue(() => {
                    const source = [ [ 0, MessageLib.MessageDeliveryModeType.NON_PERSISTENT ], [ 1, MessageLib.MessageDeliveryModeType.PERSISTENT ], [ 2, MessageLib.MessageDeliveryModeType.DIRECT ] ].map(el => [ el[0], el[1] ]);
                    return new BidiMap(...source);
                });
                const lutDelModeToEnum = lazyValue(() => delModeEnumBidiMap.value.forward);
                const lutEnumToDelMode = lazyValue(() => delModeEnumBidiMap.value.reverse);
                const uhTypeMap = (() => {
                    const result = [];
                    const paramTypeBits = 5;
                    const paramTypeCount = Math.pow(2, paramTypeBits);
                    SMFUH.values.forEach(uh => {
                        result[uh] = [];
                        for (let i = 0; i < paramTypeCount; ++i) {
                            let byte1 = 0;
                            byte1 = Bits.set(byte1, uh, 6, 2);
                            byte1 = Bits.set(byte1, i, 0, paramTypeBits);
                            result[uh][i] = int8ToStr(byte1);
                        }
                    });
                    return result;
                })();
                const lenMap = new Array(256).fill(null).map((_, idx) => int8ToStr(idx));
                const lightMap = (() => {
                    const result = [];
                    const paramTypeBits = 3;
                    const paramTypeCount = Math.pow(2, paramTypeBits);
                    const lenBits = 2;
                    const lenCount = Math.pow(2, lenBits);
                    SMFUH.values.forEach(uh => {
                        result[uh] = [];
                        for (let i = 0; i < paramTypeCount; ++i) {
                            result[uh][i] = [];
                            for (let j = 0; j < lenCount; ++j) {
                                let byte1 = 0;
                                byte1 = Bits.set(byte1, uh, 6, 2);
                                byte1 = Bits.set(byte1, 1, 5, 1);
                                byte1 = Bits.set(byte1, i, 2, 3);
                                byte1 = Bits.set(byte1, j, 0, 2);
                                result[uh][i][j] = int8ToStr(byte1);
                            }
                        }
                    });
                    return result;
                })();
                const ContentSummaryDecodeMap = [ ContentSummaryType.XML_META, ContentSummaryType.XML_PAYLOAD, ContentSummaryType.BINARY_ATTACHMENT, ContentSummaryType.CID_LIST, ContentSummaryType.BINARY_METADATA ];
                const ParamParse = {};
                ParamParse.FORCED_LENGTH_MODE = {
                    FIVE: 5,
                    SIX: 6
                };
                ParamParse.parseTopicQueueOffsets = function(dataBuf, offset) {
                    const result = [];
                    result[0] = dataBuf.readUInt8(offset);
                    result[1] = dataBuf.readUInt8(offset + 1);
                    return result;
                };
                ParamParse.parseResponseParam = function(dataBuf, offset, paramLen) {
                    const result = [];
                    result[0] = dataBuf.readInt32BE(offset);
                    if (paramLen > 4) result[1] = dataBuf.toString("latin1", offset + 4, offset + paramLen); else result[1] = "";
                    return result;
                };
                ParamParse.parseDeliveryMode = function(dataBuf, offset) {
                    const delmode = dataBuf.readUInt8(offset);
                    const lookup = lutDelModeToEnum.value.get(delmode);
                    return void 0 !== lookup ? lookup : MessageLib.MessageDeliveryModeType.DIRECT;
                };
                ParamParse.encDeliveryMode = function(delmode) {
                    const lut = lutEnumToDelMode.value;
                    const lookup = lut.get(delmode);
                    return int8ToStr(void 0 !== lookup ? lookup : MessageLib.MessageDeliveryModeType.DIRECT);
                };
                ParamParse.parseContentSummary = function(dataBuf, offset, length) {
                    const elements = [];
                    let cumulativeSize = 0;
                    let pos = offset;
                    while (pos < offset + length) {
                        const byte1 = dataBuf.readUInt8(pos);
                        const elementType = Bits.get(byte1, 4, 4);
                        const elementDeclaredLength = Bits.get(byte1, 0, 4);
                        let elementSize = 0;
                        switch (elementDeclaredLength) {
                          case 2:
                            elementSize = dataBuf.readUInt8(pos + 1);
                            break;

                          case 3:
                            elementSize = dataBuf.readUInt16BE(pos + 1);
                            break;

                          case 4:
                            elementSize = dataBuf.readUIntBE(pos + 1, 3);
                            break;

                          case 5:
                            elementSize = dataBuf.readInt32BE(pos + 1);
                            break;

                          default:
                            break;
                        }
                        if (0 === elementDeclaredLength) {
                            LOG_ERROR("Invalid content summary parameter - pos not advancing");
                            return null;
                        }
                        pos += elementDeclaredLength;
                        const cst = ContentSummaryDecodeMap[elementType];
                        if (void 0 === cst) LOG_ERROR(`Unhandled element type ` + elementType);
                        const currentElement = new ContentSummaryElement(cst, cumulativeSize, elementSize);
                        elements.push(currentElement);
                        cumulativeSize += elementSize;
                    }
                    return elements;
                };
                ParamParse.encContentSummary = function(contentSummaryArr) {
                    const messageElementDescriptions = [];
                    for (let i = 0, n = contentSummaryArr.length; i < n; ++i) {
                        const currentContentSummary = contentSummaryArr[i];
                        let currentSizeStr = "";
                        let firstByte = Bits.set(0, currentContentSummary.type, 4, 4);
                        if (currentContentSummary.length <= 255) {
                            firstByte = Bits.set(firstByte, 2, 0, 4);
                            currentSizeStr = int8ToStr(currentContentSummary.length);
                        } else if (currentContentSummary.length <= 65535) {
                            firstByte = Bits.set(firstByte, 3, 0, 4);
                            currentSizeStr = int16ToStr(currentContentSummary.length);
                        } else if (currentContentSummary.length <= 16777215) {
                            firstByte = Bits.set(firstByte, 4, 0, 4);
                            currentSizeStr = int24ToStr(currentContentSummary.length);
                        } else {
                            firstByte = Bits.set(firstByte, 5, 0, 4);
                            currentSizeStr = int32ToStr(currentContentSummary.length);
                        }
                        messageElementDescriptions.push(int8ToStr(firstByte));
                        messageElementDescriptions.push(currentSizeStr);
                    }
                    return messageElementDescriptions.join("");
                };
                ParamParse.encodeSMFParam = function(uh, paramtype, value) {
                    if (void 0 === value) return uhTypeMap[uh][paramtype] + lenMap[2];
                    const len = value.length;
                    if (len <= 253) return uhTypeMap[uh][paramtype] + lenMap[len + 2] + value;
                    return uhTypeMap[uh][paramtype] + lenMap[0] + int32ToStr(len + 6) + value;
                };
                ParamParse.encodeSMFExtendedParam = function(uh, paramtype, value, forcedLengthMode = -1) {
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh ? 1 : 0, 7, 1);
                    const length = void 0 === value || null === value ? 0 : value.length;
                    const lengthModeMap = {
                        0: 0,
                        1: 1,
                        2: 2,
                        4: 3,
                        8: 4
                    };
                    let lengthMode = 0;
                    let lengthString = "";
                    if (forcedLengthMode !== ParamParse.FORCED_LENGTH_MODE.FIVE && forcedLengthMode !== ParamParse.FORCED_LENGTH_MODE.SIX) forcedLengthMode = -1;
                    if (Object.prototype.hasOwnProperty.call(lengthModeMap, length)) lengthMode = lengthModeMap[length]; else if (length < 253 && forcedLengthMode !== ParamParse.FORCED_LENGTH_MODE.SIX || forcedLengthMode === ParamParse.FORCED_LENGTH_MODE.FIVE) {
                        lengthMode = 5;
                        lengthString = int8ToStr(length + 3);
                    } else if (length < 256 * 256 - 4 && forcedLengthMode !== ParamParse.FORCED_LENGTH_MODE.FIVE || forcedLengthMode === ParamParse.FORCED_LENGTH_MODE.SIX) {
                        lengthMode = 6;
                        lengthString = int16ToStr(length + 4);
                    } else {
                        LOG_ERROR(`Extended parameter type ${paramtype} is too long (${length} bytes) `);
                        throw new OperationError(`Extended parameter (${paramtype}) over the 2^16 byte limit`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    byte1 = Bits.set(byte1, lengthMode, 4, 3);
                    byte1 = Bits.set(byte1, paramtype >> 8, 0, 4);
                    const byte2 = 255 & paramtype;
                    return int8ToStr(byte1) + int8ToStr(byte2) + lengthString + value;
                };
                ParamParse.encLightSMFParam = function(uh, paramtype, value) {
                    return lightMap[uh][paramtype][value.length] + value;
                };
                module.exports.ParamParse = ParamParse;
            },
            "./modules/solclient-smf/lib/codec/parse-smf.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Long = __webpack_require__("./node_modules/long/umd/index.js");
                const {
                    LOG_ERROR,
                    LOG_INFO
                } = __webpack_require__("./modules/solclient-log/api.js");
                const {
                    Base64,
                    Bits
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const ParamParse = __webpack_require__("./modules/solclient-smf/lib/codec/param-parse.js").ParamParse;
                const SMFHeader = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js").SMFHeader;
                const {
                    SMFParameterType,
                    SMFExtendedParameterType
                } = __webpack_require__("./modules/solclient-smf/lib/smf-parameter-types.js");
                const base64Decode = Base64.decode;
                const bits = Bits.get;
                function isSMFHeaderAvailable(dataBuf, offset) {
                    const remaining = dataBuf.length - offset;
                    if (remaining < 12) return false;
                    return true;
                }
                function isSMFHeaderValid(dataBuf, offset) {
                    if (!isSMFHeaderAvailable(dataBuf, offset)) return false;
                    const version = 7 & dataBuf.readUInt8(offset);
                    if (3 !== version) {
                        LOG_ERROR(`Invalid smf version in smf header, version=` + version);
                        return false;
                    }
                    return true;
                }
                function isSMFAvailable(dataBuf, offset) {
                    if (!isSMFHeaderValid(dataBuf, offset)) return false;
                    const remaining = dataBuf.length - offset;
                    const totalLen = dataBuf.readUInt32BE(offset + 8);
                    return totalLen <= remaining;
                }
                function parseSMFExtendedStream(smfHeader, dataBuf, offset, streamLen) {
                    let pos = offset;
                    while (pos < offset + streamLen) {
                        if (pos + 2 > offset + streamLen) {
                            LOG_ERROR("Extended parameter stream had padding inside.");
                            break;
                        }
                        const byte1 = dataBuf.readUInt8(pos);
                        const byte2 = dataBuf.readUInt8(pos + 1);
                        const pUH = bits(byte1, 7, 1);
                        const lengthMode = bits(byte1, 4, 3);
                        const type = (bits(byte1, 0, 4) << 8) + byte2;
                        pos += 2;
                        const lengthModeMap = {
                            0: 0,
                            1: 1,
                            2: 2,
                            3: 4,
                            4: 8
                        };
                        let valueLen = 0;
                        if (Object.prototype.hasOwnProperty.call(lengthModeMap, lengthMode)) valueLen = lengthModeMap[lengthMode]; else if (5 === lengthMode) {
                            valueLen = dataBuf.readUInt8(pos) - 3;
                            pos++;
                        } else if (6 === lengthMode) {
                            valueLen = dataBuf.readUInt16BE(pos) - 4;
                            pos += 2;
                        } else {
                            LOG_ERROR(`Invalid length mode ${lengthMode} in Extended Parameter type ` + type);
                            return false;
                        }
                        switch (type) {
                          case SMFParameterType.AD_REDELIVERY_COUNT:
                            smfHeader.pm_ad_redeliveryCount = dataBuf.readUInt32BE(pos);
                            break;

                          case SMFParameterType.AD_SPOOLER_UNIQUE_ID:
                            smfHeader.pm_ad_spooler_unique_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.AD_ACK_MESSAGE_ID:
                            smfHeader.pm_ad_local_spooler_message_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.AD_REPL_MATE_ACK_MSGID:
                            smfHeader.pm_ad_replication_mate_ack_message_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFExtendedParameterType.TS_TRANSPORT_CONTEXT:
                            if (valueLen >= 32) smfHeader.pm_ts_transport_context = dataBuf.toString("latin1", pos, pos + valueLen); else type, 
                            valueLen, pos;
                            break;

                          default:
                            if (0 === pUH) type, valueLen, pUH; else {
                                smfHeader.discardMessage = true;
                                type, valueLen, pUH;
                            }
                            break;
                        }
                        pos += valueLen;
                    }
                    if (pos > offset + streamLen) LOG_ERROR(`Last extended parameter ran beyond extended stream length by ${pos - (offset + streamLen)}.`);
                    return true;
                }
                function parseSMFAt(dataBuf, offset, readHeaderOnly = false) {
                    if (!isSMFHeaderValid(dataBuf, offset)) return null;
                    let pos = offset;
                    const word1 = dataBuf.readUInt32BE(pos);
                    const headerLen = dataBuf.readUInt32BE(pos + 4);
                    const word3 = dataBuf.readUInt32BE(pos + 8);
                    const smfHeader = new SMFHeader();
                    smfHeader.smf_di = bits(word1, 31, 1);
                    smfHeader.smf_elidingEligible = bits(word1, 30, 1);
                    smfHeader.smf_dto = bits(word1, 29, 1);
                    smfHeader.smf_adf = bits(word1, 28, 1);
                    smfHeader.smf_deadMessageQueueEligible = bits(word1, 27, 1);
                    smfHeader.smf_version = bits(word1, 24, 3);
                    smfHeader.smf_uh = bits(word1, 22, 2);
                    smfHeader.smf_protocol = bits(word1, 16, 6);
                    smfHeader.smf_priority = bits(word1, 12, 4);
                    smfHeader.smf_ttl = bits(word1, 0, 8);
                    const payloadLen = word3 - headerLen;
                    if (payloadLen < 0) {
                        LOG_ERROR("SMF parse error: lost framing");
                        return null;
                    }
                    smfHeader.setMessageSizes(headerLen, payloadLen);
                    if (readHeaderOnly) return smfHeader;
                    pos += 12;
                    const end = offset + headerLen;
                    while (pos < end) {
                        const paramByte1 = dataBuf.readUInt8(pos);
                        ++pos;
                        const prmUh = bits(paramByte1, 6, 2);
                        const paramIsLightweight = 0 !== bits(paramByte1, 5, 1);
                        if (paramIsLightweight) {
                            const lwpType = bits(paramByte1, 2, 3);
                            const lwpLen = bits(paramByte1, 0, 2) + 1;
                            const lwpValueLen = lwpLen - 1;
                            if (lwpLen <= 0) {
                                LOG_ERROR("Invalid lightweight parameter length");
                                return null;
                            }
                            switch (lwpType) {
                              case SMFParameterType.LIGHT_CORRELATION:
                                smfHeader.pm_corrtag = dataBuf.readUIntBE(pos, 3);
                                break;

                              case SMFParameterType.LIGHT_TOPIC_NAME_OFFSET:
                                {
                                    const parsedQueueOffsets = ParamParse.parseTopicQueueOffsets(dataBuf, pos);
                                    smfHeader.pm_queue_offset = parsedQueueOffsets[0];
                                    smfHeader.pm_queue_len = parsedQueueOffsets[1];
                                    break;
                                }

                              case SMFParameterType.LIGHT_QUEUE_NAME_OFFSET:
                                {
                                    const parsedTopicOffsets = ParamParse.parseTopicQueueOffsets(dataBuf, pos);
                                    smfHeader.pm_topic_offset = parsedTopicOffsets[0];
                                    smfHeader.pm_topic_len = parsedTopicOffsets[1];
                                    break;
                                }

                              case SMFParameterType.LIGHT_ACK_IMMEDIATELY:
                                smfHeader.pm_ad_ackimm = !!dataBuf.readUInt8(pos);
                                break;

                              default:
                                if (0 === prmUh) lwpType, prmUh; else {
                                    lwpType, prmUh;
                                    smfHeader.discardMessage = true;
                                }
                                break;
                            }
                            pos += lwpValueLen;
                        } else {
                            const pStart = pos;
                            const pType = bits(paramByte1, 0, 5);
                            if (0 === pType) break;
                            let pLen = dataBuf.readUInt8(pos);
                            pos++;
                            let pValueLen;
                            if (0 === pLen) {
                                pLen = dataBuf.readUInt32BE(pos);
                                pos += 4;
                                pValueLen = pLen - 6;
                            } else pValueLen = pLen - 2;
                            if (pLen <= 0) {
                                LOG_ERROR(`Invalid regular parameter length ${pLen}/${pValueLen} with suspect type ${SMFParameterType.describe(pType)} at parameter at position ` + pStart);
                                return null;
                            }
                            switch (pType) {
                              case SMFParameterType.PUBLISHER_ID:
                                break;

                              case SMFParameterType.PUBLISHER_MSGID:
                                smfHeader.pm_ad_publishermsgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.MESSAGEPRIORITY:
                                smfHeader.pm_msg_priority = dataBuf.readUInt8(pos);
                                break;

                              case SMFParameterType.USERDATA:
                                smfHeader.pm_userdata = dataBuf.toString("latin1", pos, pos + pValueLen);
                                break;

                              case SMFParameterType.USERNAME:
                                smfHeader.pm_username = base64Decode(dataBuf.toString("latin1", pos, pos + pValueLen));
                                break;

                              case SMFParameterType.PASSWORD:
                                smfHeader.pm_password = base64Decode(dataBuf.toString("latin1", pos, pos + pValueLen));
                                break;

                              case SMFParameterType.RESPONSE:
                                {
                                    const parsedResponse = ParamParse.parseResponseParam(dataBuf, pos, pValueLen);
                                    smfHeader.pm_respcode = parsedResponse[0];
                                    smfHeader.pm_respstr = parsedResponse[1];
                                    break;
                                }

                              case SMFParameterType.SUB_ID_LIST:
                              case SMFParameterType.GENERIC_ATTACHMENT:
                              case SMFParameterType.BINARY_ATTACHMENT:
                                LOG_INFO("Skipping deprecated parameter type");
                                break;

                              case SMFParameterType.DELIVERY_MODE:
                                if (smfHeader.smf_adf) smfHeader.pm_deliverymode = ParamParse.parseDeliveryMode(dataBuf, pos);
                                break;

                              case SMFParameterType.ASSURED_MESSAGE_ID:
                                smfHeader.pm_ad_msgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.ASSURED_PREVMESSAGE_ID:
                                smfHeader.pm_ad_prevmsgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.ASSURED_REDELIVERED_FLAG:
                                smfHeader.pm_ad_redelflag = true;
                                break;

                              case SMFParameterType.AD_TIMETOLIVE:
                                smfHeader.pm_ad_ttl = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.AD_TOPICSEQUENCE_NUMBER:
                                smfHeader.pm_ad_topicSequenceNumber = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.MESSAGE_CONTENT_SUMMARY:
                                {
                                    const contentSummary = ParamParse.parseContentSummary(dataBuf, pos, pValueLen);
                                    if (!contentSummary) {
                                        LOG_ERROR(`Invalid message content summary at ${pos}, len ` + pValueLen);
                                        return false;
                                    }
                                    smfHeader.pm_content_summary = contentSummary;
                                    break;
                                }

                              case SMFParameterType.ASSURED_FLOWID:
                                smfHeader.pm_ad_flowid = dataBuf.readUInt32BE(pos);
                                break;

                              case SMFParameterType.TR_TOPICNAME:
                                smfHeader.pm_tr_topicname_bytes = dataBuf.toString("latin1", pos, pos + pValueLen);
                                break;

                              case SMFParameterType.AD_FLOWREDELIVERED_FLAG:
                                smfHeader.pm_ad_flowredelflag = true;
                                break;

                              case SMFParameterType.EXTENDED_TYPE_STREAM:
                                {
                                    const extSuccess = parseSMFExtendedStream(smfHeader, dataBuf, pos, pValueLen);
                                    if (!extSuccess) return null;
                                    break;
                                }

                              default:
                                if (0 === prmUh) pType, prmUh; else {
                                    pType, prmUh;
                                    smfHeader.discardMessage = true;
                                }
                                break;
                            }
                            pos += pValueLen;
                        }
                    }
                    return smfHeader;
                }
                const ParseSMF = {
                    isSMFHeaderAvailable: isSMFHeaderAvailable,
                    isSMFHeaderValid: isSMFHeaderValid,
                    isSMFAvailable: isSMFAvailable,
                    parseSMFAt: parseSMFAt
                };
                module.exports.ParseSMF = ParseSMF;
            },
            "./modules/solclient-smf/lib/codec/priority-user-cos-map.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
                const BidiMap = __webpack_require__("./modules/solclient-eskit/api.js").BidiMap;
                class PriorityUserCosMap extends BidiMap {
                    constructor() {
                        super([ MessageLib.MessageUserCosType.COS1, 0 ], [ MessageLib.MessageUserCosType.COS2, 1 ], [ MessageLib.MessageUserCosType.COS3, 2 ]);
                    }
                }
                module.exports.PriorityUserCosMap = PriorityUserCosMap;
            },
            "./modules/solclient-smf/lib/codec/smp.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Bits,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const SMFSMPMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-types.js").SMFSMPMessageType;
                const SMPMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js").SMPMessage;
                const {
                    get: bits,
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    int32ToStr
                } = Convert;
                const SMP = {};
                SMP.parseSMPAt = function(dataBuf, offset) {
                    if (offset + 6 > dataBuf.length) return false;
                    let pos = offset;
                    const onebyte = dataBuf.readUInt8(pos);
                    pos++;
                    const msgType = bits(onebyte, 0, 7);
                    const smpMsg = new SMPMessage();
                    if (!(msgType === SMFSMPMessageType.ADDSUBSCRIPTION || msgType === SMFSMPMessageType.REMSUBSCRIPTION || msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION)) {
                        msgType;
                        return false;
                    }
                    dataBuf.toString("latin1");
                    const msgLength = dataBuf.readUInt32BE(pos);
                    pos += 4;
                    if (offset + msgLength > dataBuf.length) {
                        msgLength;
                        return false;
                    }
                    const msgFlags = dataBuf.readUInt8(pos);
                    pos++;
                    smpMsg.msgType = msgType;
                    smpMsg.smpFlags = msgFlags;
                    if (msgType === SMFSMPMessageType.ADDSUBSCRIPTION || msgType === SMFSMPMessageType.REMSUBSCRIPTION) smpMsg.encodedUtf8Subscription = dataBuf.toString("latin1", pos, pos + msgLength - 6); else {
                        const queueLength = dataBuf.readUInt8(pos);
                        pos++;
                        smpMsg.encodedUtf8QueueName = dataBuf.toString("latin1", pos, pos + queueLength);
                        pos += queueLength;
                        const subsLength = dataBuf.readUInt8(pos);
                        pos++;
                        smpMsg.encodedUtf8Subscription = dataBuf.toString("latin1", pos, pos + subsLength);
                        pos += subsLength;
                    }
                    return smpMsg;
                };
                SMP.encSmp = function(smpMsg) {
                    if (!(smpMsg.msgType === SMFSMPMessageType.ADDSUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMSUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION)) return false;
                    const data = [];
                    let onebyte = 0;
                    onebyte = setBits(onebyte, 1, 7, 1);
                    onebyte = setBits(onebyte, smpMsg.msgType, 0, 7);
                    data.push(int8ToStr(onebyte));
                    let msgLength = 6 + smpMsg.encodedUtf8Subscription.length;
                    if (smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION) msgLength += 2 + smpMsg.encodedUtf8QueueName.length;
                    data.push(int32ToStr(msgLength));
                    data.push(int8ToStr(smpMsg.smpFlags));
                    if (smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION) {
                        data.push(int8ToStr(smpMsg.encodedUtf8QueueName.length));
                        data.push(smpMsg.encodedUtf8QueueName);
                        data.push(int8ToStr(smpMsg.encodedUtf8Subscription.length));
                        data.push(smpMsg.encodedUtf8Subscription);
                    } else data.push(smpMsg.encodedUtf8Subscription);
                    return data.join("");
                };
                module.exports.SMP = SMP;
            },
            "./modules/solclient-smf/lib/codec/transport.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Bits,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const Lazy = __webpack_require__("./modules/solclient-eskit/api.js").Lazy;
                const LOG_ERROR = __webpack_require__("./modules/solclient-log/api.js").LOG_ERROR;
                const SMFTransportSessionMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-transport-session-message-types.js").SMFTransportSessionMessageType;
                const TransportSMFMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js").TransportSMFMessage;
                const bits = Bits.get;
                const {
                    int16ToStr,
                    int32ToStr
                } = Convert;
                const lazyValue = Lazy.lazyValue;
                function remains(dataBuf, offset) {
                    return dataBuf.length - offset;
                }
                function parseTsSmfHdrAt(dataBuf, offset, smfheader) {
                    let pos = offset;
                    if (remains(dataBuf, pos) < 10) {
                        LOG_ERROR("TsSmf parse failed: not enough data, expected at least 10B");
                        return false;
                    }
                    const transportSMFMessage = new TransportSMFMessage();
                    transportSMFMessage.smfHeader = smfheader;
                    const twobyte = dataBuf.readUInt16BE(pos);
                    pos += 2;
                    transportSMFMessage.uh = bits(twobyte, 15, 1);
                    transportSMFMessage.messageType = bits(twobyte, 8, 7);
                    const tsHdrLen = bits(twobyte, 0, 8);
                    transportSMFMessage.tsHeaderLength = tsHdrLen;
                    transportSMFMessage.sessionId = dataBuf.toString("latin1", pos, pos + 8);
                    pos += 8;
                    if (transportSMFMessage.messageType === SMFTransportSessionMessageType.CREATE_RESP) {
                        const rtrTagLen = dataBuf.readUInt8(pos);
                        pos++;
                        if (remains(dataBuf, pos) < rtrTagLen) {
                            LOG_ERROR(`TsSmf parse failed: not enough data for RouterTag, expected ${rtrTagLen}B`);
                            return false;
                        }
                        transportSMFMessage.routerTag = dataBuf.toString("latin1", pos, pos + rtrTagLen);
                        pos += rtrTagLen;
                    }
                    pos = offset + tsHdrLen;
                    if (4294967295 === smfheader.payloadLength) transportSMFMessage.payloadLength = smfheader.payloadLength; else transportSMFMessage.payloadLength = smfheader.payloadLength - tsHdrLen;
                    return transportSMFMessage;
                }
                const tsHeaderPreLength = lazyValue(() => int32ToStr(51642369) + int32ToStr(12));
                const tsDestroyHeaderPreSid = lazyValue(() => tsHeaderPreLength.value + int32ToStr(22) + int16ToStr(33290));
                const tsCreateHeader = lazyValue(() => tsHeaderPreLength.value + int32ToStr(22) + int16ToStr(32778) + int32ToStr(0) + int32ToStr(0));
                const tsDataTokenPreSid = lazyValue(() => int32ToStr(60030977) + int32ToStr(12) + int32ToStr(22) + int16ToStr(34058));
                const tsDataStreamTokenPreSid = lazyValue(() => int32ToStr(60030977) + int32ToStr(12) + int32ToStr(24) + int16ToStr(34316));
                function genTsCreateHeader() {
                    return tsCreateHeader.value;
                }
                function genTsDestroyHeader(sid) {
                    return tsDestroyHeaderPreSid.value + sid;
                }
                function genTsDataTokenMsg(sid) {
                    return tsDataTokenPreSid.value + sid;
                }
                function genTsDataStreamTokenMsg(sid, paddingBytes) {
                    return tsDataStreamTokenPreSid.value + sid + (paddingBytes && paddingBytes > 0 ? int16ToStr(paddingBytes) : int16ToStr(0));
                }
                function genTsDataMsgHeaderParts(sid) {
                    return [ int32ToStr(60030977) + int32ToStr(12), int16ToStr(33802) + sid ];
                }
                function parseTsSmfMsgAt(dataBuf, offset, smfheader) {
                    const transportSMFMessage = parseTsSmfHdrAt(dataBuf, offset, smfheader);
                    if (!transportSMFMessage) return null;
                    const pos = offset + transportSMFMessage.tsHeaderLength;
                    if (remains(dataBuf, pos) < transportSMFMessage.payloadLength) {
                        LOG_ERROR(`Couldn't read full encapsulated TsSmf payload, expected ${transportSMFMessage.payloadLength}B`);
                        return null;
                    }
                    transportSMFMessage.payload = dataBuf.slice(pos, pos + transportSMFMessage.payloadLength);
                    return transportSMFMessage;
                }
                const Transport = {
                    genTsCreateHeader: genTsCreateHeader,
                    genTsDestroyHeader: genTsDestroyHeader,
                    genTsDataTokenMsg: genTsDataTokenMsg,
                    genTsDataStreamTokenMsg: genTsDataStreamTokenMsg,
                    genTsDataMsgHeaderParts: genTsDataMsgHeaderParts,
                    parseTsSmfHdrAt: parseTsSmfHdrAt,
                    parseTsSmfMsgAt: parseTsSmfMsgAt
                };
                module.exports.Transport = Transport;
            },
            "./modules/solclient-smf/lib/message-objects/adprotocol-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const BaseMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js").BaseMessage;
                const {
                    Convert,
                    Long
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const DestinationType = __webpack_require__("./modules/solclient-destination/api.js").DestinationType;
                const LOG_INFO = __webpack_require__("./modules/solclient-log/api.js").LOG_INFO;
                const OperationError = __webpack_require__("./modules/solclient-error/api.js").OperationError;
                const {
                    QueueAccessType,
                    QueueDiscardBehavior
                } = __webpack_require__("./modules/solclient-queue/api.js");
                const {
                    QueuePermissions,
                    QueueType
                } = __webpack_require__("./modules/solclient-queue/api.js");
                const ReplayStartType = __webpack_require__("./modules/solclient-replaystart/api.js").ReplayStartType;
                const MessageOutcome = __webpack_require__("./modules/solclient-message/api.js").MessageOutcome;
                const SMFAdProtocolMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-adprotocol-message-types.js").SMFAdProtocolMessageType;
                const SMFAdProtocolParam = __webpack_require__("./modules/solclient-smf/lib/smf-adprotocol-params.js").SMFAdProtocolParam;
                const SMFHeader = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js").SMFHeader;
                const SMFParameter = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-parameter.js").SMFParameter;
                const SMFProtocol = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js").SMFProtocol;
                const SMFUH = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-uh.js").SMFUH;
                const StringUtils = __webpack_require__("./modules/solclient-util/api.js").StringUtils;
                const BufferImpl = __webpack_require__("./node_modules/buffer/index.js").Buffer;
                const {
                    strToInt8,
                    strToInt16,
                    strToUInt32,
                    strToUInt64
                } = Convert;
                const bUInt8 = BufferImpl.prototype.readUInt8;
                const bUInt16BE = BufferImpl.prototype.readUInt16BE;
                const bUInt32BE = BufferImpl.prototype.readUInt32BE;
                const bUInt64BE = function(pos) {
                    return Long.fromBits(this.readUInt32BE(pos + 4), this.readUInt32BE(pos), true);
                };
                const {
                    nullTerminate,
                    stripNullTerminate
                } = StringUtils;
                const EndpointTypeToParam = {
                    [DestinationType.TOPIC]: SMFAdProtocolParam.DTENAME,
                    [DestinationType.QUEUE]: SMFAdProtocolParam.QUEUENAME
                };
                const QueueDescriptorTypeToParam = {
                    [QueueType.TOPIC_ENDPOINT]: SMFAdProtocolParam.DTENAME,
                    [QueueType.QUEUE]: SMFAdProtocolParam.QUEUENAME
                };
                const QUEUE_PERMISSIONS_TO_BITS = {
                    [QueuePermissions.NONE]: 0,
                    [QueuePermissions.READ_ONLY]: 1,
                    [QueuePermissions.CONSUME]: 3,
                    [QueuePermissions.MODIFY_TOPIC]: 7,
                    [QueuePermissions.DELETE]: 15
                };
                const ACCESS_TYPE_INT_TO_ENUM = {
                    1: QueueAccessType.EXCLUSIVE,
                    2: QueueAccessType.NONEXCLUSIVE
                };
                const ACCESS_TYPE_ENUM_TO_BITS = {
                    [QueueAccessType.EXCLUSIVE]: 1,
                    [QueueAccessType.NONEXCLUSIVE]: 2
                };
                const DUARBILITY_INT_TO_BOOL = {
                    1: true,
                    2: false,
                    3: false
                };
                const DISCARD_ENUM_TO_VALUE = {
                    [QueueDiscardBehavior.NOTIFY_SENDER_OFF]: 1,
                    [QueueDiscardBehavior.NOTIFY_SENDER_ON]: 2
                };
                function addQueueProperties(message, queueProperties, skipAccessType = false) {
                    if (!queueProperties) return;
                    const {
                        accessType,
                        discardBehavior,
                        maxMessageRedelivery,
                        maxMessageSize,
                        permissions,
                        quotaMB,
                        respectsTTL
                    } = queueProperties;
                    if (permissions && void 0 !== QUEUE_PERMISSIONS_TO_BITS[permissions]) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_ALLOTHER_PERMISSION, QUEUE_PERMISSIONS_TO_BITS[permissions]));
                    if (!skipAccessType && void 0 !== accessType && void 0 !== ACCESS_TYPE_ENUM_TO_BITS[accessType]) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ACCESSTYPE, ACCESS_TYPE_ENUM_TO_BITS[accessType]));
                    if (null !== quotaMB && void 0 !== quotaMB) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_QUOTA, quotaMB));
                    if (void 0 !== maxMessageSize && null !== maxMessageSize) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_MAX_MSGSIZE, maxMessageSize));
                    let flags = 0;
                    if (null !== discardBehavior && void 0 !== discardBehavior) {
                        const discardBehaviorValue = DISCARD_ENUM_TO_VALUE[discardBehavior];
                        flags |= discardBehaviorValue << 12;
                    }
                    if (flags) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_BEHAVIOUR, flags));
                    if (void 0 !== maxMessageRedelivery && null !== maxMessageRedelivery) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.MAX_REDELIVERY, maxMessageRedelivery));
                    if (void 0 !== respectsTTL && null !== respectsTTL) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_RESPECTS_TTL, respectsTTL ? 1 : 0));
                }
                class AdProtocolMessage extends BaseMessage {
                    constructor(messageType = 0, version = 3) {
                        super(new SMFHeader(SMFProtocol.ADCTRL, 1));
                        this.msgType = messageType;
                        this.version = version;
                    }
                    _readParameter(paramtype, decoder = null, bufMethod = null) {
                        const param = this.getParameter(paramtype);
                        if (void 0 === param) return;
                        if (bufMethod && param.getBuffer()) return bufMethod.call(param.getBuffer(), param.getBegin());
                        const value = param.getValue();
                        return decoder ? decoder(value) : value;
                    }
                    getAccessType() {
                        const param = this._readParameter(SMFAdProtocolParam.ACCESSTYPE, strToInt8, bUInt8);
                        return ACCESS_TYPE_INT_TO_ENUM[param];
                    }
                    getDurability() {
                        const param = this._readParameter(SMFAdProtocolParam.EP_DURABLE, strToInt8, bUInt8);
                        if (3 === param) LOG_INFO("Non durable reliable queue. This does not happen often.");
                        return DUARBILITY_INT_TO_BOOL[param];
                    }
                    getActiveFlow() {
                        return this._readParameter(SMFAdProtocolParam.ACTIVE_FLOW_INDICATION, strToInt8, bUInt8);
                    }
                    getQueueDiscardBehavior() {
                        const param = this._readParameter(SMFAdProtocolParam.EP_BEHAVIOUR, strToInt16, bUInt16BE);
                        if (void 0 === param) return;
                        const masked = (12288 & param) >> 12;
                        if (masked === DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_OFF]) return QueueDiscardBehavior.NOTIFY_SENDER_OFF; else if (masked === DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_ON]) return QueueDiscardBehavior.NOTIFY_SENDER_ON;
                        return;
                    }
                    getEndpointDeliveryCountSent() {
                        const param = this._readParameter(SMFAdProtocolParam.EP_BEHAVIOUR, strToInt16, bUInt16BE);
                        const masked = (3072 & param) >> 10;
                        switch (masked) {
                          case 0:
                            return;

                          case 1:
                            return false;

                          case 2:
                            return true;

                          default:
                            return;
                        }
                    }
                    getEndpointId() {
                        return this._readParameter(SMFAdProtocolParam.ENDPOINT_ID, strToUInt32, bUInt32BE);
                    }
                    getRespectsTTL() {
                        const value = this._readParameter(SMFAdProtocolParam.EP_RESPECTS_TTL, strToInt8, bUInt8);
                        if (void 0 === value) return;
                        value;
                        return !!value;
                    }
                    getFlowName() {
                        return this._readParameter(SMFAdProtocolParam.FLOWNAME, stripNullTerminate);
                    }
                    getFlowId() {
                        return this._readParameter(SMFAdProtocolParam.FLOWID, strToUInt32, bUInt32BE);
                    }
                    getQuota() {
                        return this._readParameter(SMFAdProtocolParam.EP_QUOTA, strToUInt32, bUInt32BE);
                    }
                    getMaxMsgSize() {
                        return this._readParameter(SMFAdProtocolParam.EP_MAX_MSGSIZE, strToUInt32, bUInt32BE);
                    }
                    getTopicEndpointBytes() {
                        return this._readParameter(SMFAdProtocolParam.DTENAME);
                    }
                    getQueueNameBytes() {
                        return this._readParameter(SMFAdProtocolParam.QUEUENAME);
                    }
                    getGrantedPermissions() {
                        const permissions = this._readParameter(SMFAdProtocolParam.GRANTED_PERMISSIONS, strToUInt32, bUInt32BE);
                        let result;
                        Object.keys(QUEUE_PERMISSIONS_TO_BITS).forEach(key => {
                            if (QUEUE_PERMISSIONS_TO_BITS[key] === permissions) result = key;
                        });
                        return result;
                    }
                    getAllOthersPermissions() {
                        const permissions = this._readParameter(SMFAdProtocolParam.EP_ALLOTHER_PERMISSION, strToUInt32, bUInt32BE);
                        let result;
                        Object.keys(QUEUE_PERMISSIONS_TO_BITS).forEach(key => {
                            if (QUEUE_PERMISSIONS_TO_BITS[key] === permissions) result = key;
                        });
                        return result;
                    }
                    getLastMsgIdAcked() {
                        return this._readParameter(SMFAdProtocolParam.LASTMSGIDACKED, strToUInt64, bUInt64BE);
                    }
                    getLastMsgIdReceived() {
                        return this._readParameter(SMFAdProtocolParam.LASTMSGIDRECEIVED, strToUInt64, bUInt64BE);
                    }
                    getPublisherId() {
                        return this._readParameter(SMFAdProtocolParam.PUBLISHER_ID, strToUInt32, bUInt32BE);
                    }
                    getWantFlowChangeNotify() {
                        return !!this._readParameter(SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY, strToInt8, bUInt8);
                    }
                    getWindow() {
                        return this._readParameter(SMFAdProtocolParam.WINDOW, strToInt8, bUInt8);
                    }
                    getMaxRedelivery() {
                        return this._readParameter(SMFAdProtocolParam.MAX_REDELIVERY, strToInt8, bUInt8);
                    }
                    getMaxUnackedMessages() {
                        return this._readParameter(SMFAdProtocolParam.MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW, strToUInt32, bUInt32BE);
                    }
                    getEndpointErrorId() {
                        return this._readParameter(SMFAdProtocolParam.ENDPOINT_ERROR_ID, strToUInt64, bUInt64BE);
                    }
                    getPartitionGroupId() {
                        return this._readParameter(SMFAdProtocolParam.PARTITION_GROUP_ID, strToInt16, bUInt16BE);
                    }
                    getSpoolerUniqueId() {
                        return this._readParameter(SMFAdProtocolParam.SPOOLER_UNIQUE_ID, strToUInt64, bUInt64BE);
                    }
                    static getCloseMessagePublisher(flowId, correlationTag) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.CLOSEPUBFLOW);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                        return message;
                    }
                    static getCreate(queueDescriptor, queueProperties, correlationTag) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.CREATE);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        const endpointTypeParam = QueueDescriptorTypeToParam[queueDescriptor.type];
                        if (void 0 === endpointTypeParam) throw new OperationError("Unknown destination type");
                        message.addParameter(new SMFParameter(SMFUH.REJECT, endpointTypeParam, nullTerminate(queueDescriptor.name)));
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_DURABLE, queueDescriptor.durable ? 1 : 2));
                        addQueueProperties(message, queueProperties);
                        return message;
                    }
                    static getDelete(queueDescriptor, correlationTag) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.DELETE);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        const endpointTypeParam = QueueDescriptorTypeToParam[queueDescriptor.type];
                        if (void 0 === endpointTypeParam) throw new OperationError("Unknown destination type");
                        message.addParameter(new SMFParameter(SMFUH.REJECT, endpointTypeParam, nullTerminate(queueDescriptor.name)));
                        return message;
                    }
                    static getOpenMessagePublisher(lastMsgIdAcked, lastMsgIdSent, windowSize, flowName, correlationTag) {
                        const adMsg = new AdProtocolMessage(SMFAdProtocolMessageType.OPENPUBFLOW);
                        const smfHeader = adMsg.smfHeader;
                        smfHeader.pm_corrtag = correlationTag;
                        if (void 0 !== lastMsgIdAcked) adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMsgIdAcked));
                        if (void 0 !== lastMsgIdSent) adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDSENT, lastMsgIdSent));
                        adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.WINDOW, windowSize));
                        adMsg.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.FLOWNAME, flowName || ""));
                        return adMsg;
                    }
                    static getOpenMessageConsumer(queueDescriptor, queueProperties, endpoint, topicSubscription, correlationTag, windowSize, noLocal, wantFlowChangeUpdate, lastMsgIdAcked = Long.UZERO, lastMsgIdReceived = Long.UZERO, browser = false, replayStartLocation = void 0, endpointErrorId = void 0, partitionGroupId = void 0, hasNackSupport = false) {
                        const durable = queueDescriptor.durable;
                        const endpointBytes = endpoint.bytes;
                        const endpointType = endpoint.type;
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.BIND);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        const endpointTypeParam = EndpointTypeToParam[endpointType];
                        if (void 0 === endpointTypeParam) throw new OperationError("Unknown destination type");
                        message.addParameter(new SMFParameter(SMFUH.REJECT, endpointTypeParam, endpointBytes));
                        if (topicSubscription) message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.TOPICNAME, topicSubscription.bytes));
                        if (endpointType === DestinationType.QUEUE) {
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMsgIdAcked));
                            message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.LASTMSGIDRECEIVED, lastMsgIdReceived));
                        }
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.WINDOW, windowSize));
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_DURABLE, durable));
                        addQueueProperties(message, queueProperties, true);
                        if (noLocal) message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.NOLOCAL, 1));
                        if (wantFlowChangeUpdate) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY, 1));
                        if (hasNackSupport) message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWTYPE, 3)); else if (browser) message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWTYPE, 2));
                        if (void 0 !== replayStartLocation) {
                            let rsValue = replayStartLocation._replayStartValue;
                            if (replayStartLocation._type === ReplayStartType.DATE) {
                                const replayStartTimeMs = Long.fromNumber(replayStartLocation._replayStartValue, true);
                                const replayStartTimeNs = replayStartTimeMs.multiply(1e6);
                                rsValue = replayStartTimeNs;
                            }
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.REPLAY_START_LOCATION, {
                                type: replayStartLocation._type,
                                value: rsValue
                            }));
                        }
                        if (void 0 !== endpointErrorId) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ENDPOINT_ERROR_ID, endpointErrorId));
                        if (void 0 !== partitionGroupId && null !== partitionGroupId) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.PARTITION_GROUP_ID, partitionGroupId));
                        return message;
                    }
                    static getCloseMessageConsumer(flowId, correlationTag) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNBIND);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                        return message;
                    }
                    static getDTEUnsubscribeMessage(correlationTag, topic) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNSUBSCRIBE);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.DTENAME, topic.getBytes()));
                        return message;
                    }
                    static getAck(flowId, lastMessageIdAcked = void 0, windowSize = void 0, applicationAckRanges = void 0) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.CLIENTACK);
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                        if (lastMessageIdAcked) message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMessageIdAcked));
                        if (void 0 !== windowSize && null !== windowSize) message.addParameter(new SMFParameter(SMFUH.REJECT, windowSize <= 255 ? SMFAdProtocolParam.WINDOW : SMFAdProtocolParam.TRANSPORT_WINDOW, windowSize));
                        if (applicationAckRanges && applicationAckRanges.size > 0) {
                            let totalRangeLen = 0;
                            const allOutcomes = MessageOutcome.values;
                            for (let i = 0; i < allOutcomes.length; i++) totalRangeLen += applicationAckRanges.has(allOutcomes[i]) ? applicationAckRanges.get(allOutcomes[i]).length : 0;
                            if (totalRangeLen > AdProtocolMessage.MAX_CLIENT_ACK_RANGES) throw new OperationError("Application ack range count exceeds limit of 64");
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.APPLICATION_ACK, applicationAckRanges));
                        }
                        return message;
                    }
                    static getUnbindAck(flowId, endpointErrorId = void 0, lastMessageIdAcked) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNBIND);
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                        if (endpointErrorId) message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ENDPOINT_ERROR_ID, endpointErrorId));
                        return message;
                    }
                }
                AdProtocolMessage.MAX_CLIENT_ACK_RANGES = 64;
                module.exports.AdProtocolMessage = AdProtocolMessage;
            },
            "./modules/solclient-smf/lib/message-objects/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const AdProtocolMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/adprotocol-message.js").AdProtocolMessage;
                const BinaryMetaBlock = __webpack_require__("./modules/solclient-smf/lib/message-objects/binary-meta-block.js").BinaryMetaBlock;
                const ClientCtrlMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/client-ctrl-message.js").ClientCtrlMessage;
                const KeepAliveMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/keep-alive-message.js").KeepAliveMessage;
                const SMFHeader = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js").SMFHeader;
                const SMFParameter = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-parameter.js").SMFParameter;
                const SMFUH = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-uh.js").SMFUH;
                const SMPMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/smp-message.js").SMPMessage;
                const TransportSMFMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/transport-smf-message.js").TransportSMFMessage;
                module.exports.AdProtocolMessage = AdProtocolMessage;
                module.exports.BinaryMetaBlock = BinaryMetaBlock;
                module.exports.ClientCtrlMessage = ClientCtrlMessage;
                module.exports.KeepAliveMessage = KeepAliveMessage;
                module.exports.SMFHeader = SMFHeader;
                module.exports.SMFParameter = SMFParameter;
                module.exports.SMFUH = SMFUH;
                module.exports.SMPMessage = SMPMessage;
                module.exports.TransportSMFMessage = TransportSMFMessage;
            },
            "./modules/solclient-smf/lib/message-objects/base-message.js": module => {
                class BaseMessage {
                    constructor(header = null, params = []) {
                        this._smfHeader = header;
                        this._parameters = params;
                    }
                    addParameter(param) {
                        this._parameters[param.getType()] = param;
                    }
                    getParameter(paramType) {
                        return this._parameters[paramType];
                    }
                    getParameterArray() {
                        return this._parameters;
                    }
                    get smfHeader() {
                        return this._smfHeader;
                    }
                    set smfHeader(val) {
                        this._smfHeader = val;
                    }
                    getResponse() {
                        const smf = this.smfHeader;
                        if (!(smf && smf.pm_respcode && smf.pm_respstr)) return null;
                        return {
                            responseCode: smf.pm_respcode,
                            responseString: smf.pm_respstr
                        };
                    }
                }
                module.exports.BaseMessage = BaseMessage;
            },
            "./modules/solclient-smf/lib/message-objects/binary-meta-block.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Bits,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const bits = Bits.get;
                const {
                    int8ToStr,
                    int24ToStr
                } = Convert;
                class BinaryMetaBlock {
                    constructor(type, payload) {
                        this.type = type;
                        this.payload = payload;
                    }
                    asEncodedSmf() {
                        const smf = [];
                        smf.push(int8ToStr(1));
                        smf.push(int8ToStr(this.type));
                        smf.push(int24ToStr(this.payload.length));
                        smf.push(this.payload.toString("latin1"));
                        return smf.join("");
                    }
                    static fromEncodedSmf(bufSmf, offset = 0) {
                        if (bufSmf.length - offset < 6) return null;
                        const chunkCount = bufSmf.readUInt8(offset);
                        const fourbyte = bufSmf.readInt32BE(offset + 1);
                        const type = bits(fourbyte, 24, 8);
                        const payloadLen = bits(fourbyte, 0, 24);
                        const payloadOffset = 4 * chunkCount + 1;
                        const payload = bufSmf.slice(offset + payloadOffset, offset + payloadOffset + payloadLen);
                        return new BinaryMetaBlock(type, payload);
                    }
                }
                module.exports.BinaryMetaBlock = BinaryMetaBlock;
            },
            "./modules/solclient-smf/lib/message-objects/client-ctrl-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    AuthenticationScheme,
                    CapabilityType,
                    ClientCapabilityType,
                    MutableSessionProperty,
                    SessionProperties
                } = __webpack_require__("./modules/solclient-session/api.js");
                const BaseMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js").BaseMessage;
                const {
                    Bits,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const {
                    DestinationType,
                    DestinationUtil
                } = __webpack_require__("./modules/solclient-destination/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const {
                    Process,
                    StringUtils,
                    Version
                } = __webpack_require__("./modules/solclient-util/api.js");
                const SMFClientCtrlMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-client-ctrl-message-types.js").SMFClientCtrlMessageType;
                const {
                    SMFClientCtrlParam,
                    SMFClientCtrlAuthType
                } = __webpack_require__("./modules/solclient-smf/lib/smf-client-ctrl-params.js");
                const SMFHeader = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js").SMFHeader;
                const SMFParameter = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-parameter.js").SMFParameter;
                const SMFProtocol = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js").SMFProtocol;
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const {
                    get: bits,
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    strToInt8,
                    int16ToStr,
                    int32ToStr,
                    strToInt16,
                    strToInt32
                } = Convert;
                const {
                    nullTerminate,
                    stripNullTerminate
                } = StringUtils;
                const validateAndEncode = DestinationUtil.validateAndEncode;
                const BOOLEAN_CAPS_BITS = [ CapabilityType.JNDI, CapabilityType.COMPRESSION, CapabilityType.GUARANTEED_MESSAGE_CONSUME, CapabilityType.TEMPORARY_ENDPOINT, CapabilityType.GUARANTEED_MESSAGE_PUBLISH, CapabilityType.GUARANTEED_MESSAGE_BROWSE, CapabilityType.ENDPOINT_MGMT, CapabilityType.SELECTOR, CapabilityType.ENDPOINT_MESSAGE_TTL, CapabilityType.QUEUE_SUBSCRIPTIONS, null, CapabilityType.SUBSCRIPTION_MANAGER, CapabilityType.MESSAGE_ELIDING, CapabilityType.TRANSACTED_SESSION, CapabilityType.NO_LOCAL, CapabilityType.ACTIVE_CONSUMER_INDICATION, CapabilityType.PER_TOPIC_SEQUENCE_NUMBERING, CapabilityType.ENDPOINT_DISCARD_BEHAVIOR, CapabilityType.CUT_THROUGH, null, CapabilityType.MESSAGE_REPLAY, CapabilityType.COMPRESSED_SSL, null, CapabilityType.SHARED_SUBSCRIPTIONS, CapabilityType.BR_REPLAY_ERRORID, CapabilityType.AD_APP_ACK_FAILED, CapabilityType.VAR_LEN_EXT_PARAM ];
                const CLIENT_CAPS_VALUES = new Map([ [ ClientCapabilityType.UNBIND_ACK, 128 ], [ ClientCapabilityType.BR_ERRORID, 64 ], [ ClientCapabilityType.PQ, 32 ] ]);
                class ClientCtrlMessage extends BaseMessage {
                    constructor(messageType = 0) {
                        super(new SMFHeader(SMFProtocol.CLIENTCTRL, 1));
                        this.msgType = messageType;
                        this.version = 1;
                    }
                    getP2PTopicValue() {
                        const p2pParam = this.getParameter(SMFClientCtrlParam.P2PTOPIC);
                        if (!p2pParam) return null;
                        return stripNullTerminate(p2pParam.getValue());
                    }
                    getVpnNameInUseValue() {
                        const vpnParam = this.getParameter(SMFClientCtrlParam.MSGVPNNAME);
                        if (!vpnParam) return null;
                        return stripNullTerminate(vpnParam.getValue());
                    }
                    getVridInUseValue() {
                        const vridParam = this.getParameter(SMFClientCtrlParam.VRIDNAME);
                        if (!vridParam) return null;
                        return stripNullTerminate(vridParam.getValue());
                    }
                    getUserIdValue() {
                        const userIdParam = this.getParameter(SMFClientCtrlParam.USERID);
                        if (!userIdParam) return null;
                        return stripNullTerminate(userIdParam.getValue());
                    }
                    getRouterCapabilities() {
                        let caps = [];
                        let capParam = this.getParameter(SMFClientCtrlParam.ROUTER_CAPABILITIES);
                        if (capParam) caps = ClientCtrlMessage.prmParseCapabilitiesValue(capParam.getValue(), caps);
                        capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREVERSION);
                        if (capParam) caps[CapabilityType.PEER_SOFTWARE_VERSION] = stripNullTerminate(capParam.getValue());
                        capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREDATE);
                        if (capParam) caps[CapabilityType.PEER_SOFTWARE_DATE] = stripNullTerminate(capParam.getValue());
                        capParam = this.getParameter(SMFClientCtrlParam.PLATFORM);
                        if (capParam) caps[CapabilityType.PEER_PLATFORM] = stripNullTerminate(capParam.getValue());
                        capParam = this.getParameter(SMFClientCtrlParam.PHYSICALROUTERNAME);
                        if (capParam) caps[CapabilityType.PEER_ROUTER_NAME] = stripNullTerminate(capParam.getValue());
                        return caps;
                    }
                    static prmGetDtoPriorityValue(dto) {
                        if (void 0 === dto.local || void 0 === dto.network) return false;
                        let twobyte = 0;
                        twobyte = setBits(twobyte, dto.local, 8, 8);
                        twobyte = setBits(twobyte, dto.network, 0, 8);
                        return int16ToStr(twobyte);
                    }
                    static prmParseDtoPriorityValue(strDtoPriority) {
                        const dto = {};
                        const twobyte = strToInt16(strDtoPriority.substr(0, 2));
                        dto.local = bits(twobyte, 8, 8);
                        dto.network = bits(twobyte, 0, 8);
                        return dto;
                    }
                    static prmParseCapabilitiesValue(strCapabilities, capsIn) {
                        const caps = capsIn;
                        if (!(strCapabilities && caps)) return false;
                        const CT = CapabilityType;
                        let pos = 0;
                        const boolCapCount = strToInt8(strCapabilities[pos]);
                        ++pos;
                        let capsByte;
                        for (let bitIndex = 0; bitIndex < boolCapCount; ++bitIndex) {
                            const msbIndex = 7 & bitIndex;
                            if (0 === msbIndex) {
                                capsByte = strToInt8(strCapabilities[pos]);
                                ++pos;
                            }
                            const capsKey = BOOLEAN_CAPS_BITS[bitIndex];
                            if (!capsKey) continue;
                            caps[capsKey] = !!bits(capsByte, 7 - msbIndex, 1);
                        }
                        const sanityLoop = 500;
                        for (let i = 0; pos < strCapabilities.length && i < sanityLoop; ++i) {
                            const onebyte = strToInt8(strCapabilities[pos]);
                            pos++;
                            const capLen = strToInt32(strCapabilities.substr(pos, 4)) - 5;
                            pos += 4;
                            const strValue = strCapabilities.substr(pos, capLen);
                            pos += capLen;
                            switch (onebyte) {
                              case 0:
                                caps[CT.PEER_PORT_SPEED] = 4 === strValue.length ? strToInt32(strValue) : 0;
                                break;

                              case 1:
                                caps[CT.PEER_PORT_TYPE] = 1 === strValue.length ? strToInt8(strValue) : 0;
                                break;

                              case 2:
                                caps[CT.MAX_GUARANTEED_MSG_SIZE] = 4 === strValue.length ? strToInt32(strValue) : 0;
                                break;

                              case 3:
                                caps[CT.MAX_DIRECT_MSG_SIZE] = 4 === strValue.length ? strToInt32(strValue) : 0;
                                break;

                              default:
                                break;
                            }
                        }
                        return caps;
                    }
                    static getLogin(sprop, compressedTLS, plaintextTLS, correlationTag) {
                        function clientCapsToStr(clientCapList) {
                            const highestCap = Math.max.apply(null, clientCapList) + 1;
                            let capBits = 0;
                            clientCapList.forEach(cap => {
                                capBits += CLIENT_CAPS_VALUES.get(cap);
                            });
                            return int8ToStr(highestCap) + int8ToStr(capBits);
                        }
                        if (!(sprop instanceof SessionProperties)) return false;
                        const cc = new ClientCtrlMessage(SMFClientCtrlMessageType.LOGIN);
                        const smfHeader = cc._smfHeader;
                        const isClientCert = sprop.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
                        smfHeader.pm_corrtag = correlationTag;
                        if (sprop.password && !isClientCert) smfHeader.pm_password = sprop.password;
                        if (sprop.userName) smfHeader.pm_username = sprop.userName;
                        if (sprop.subscriberLocalPriority && sprop.subscriberNetworkPriority) cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.DELIVERTOONEPRIORITY, ClientCtrlMessage.prmGetDtoPriorityValue({
                            local: sprop.subscriberLocalPriority,
                            network: sprop.subscriberNetworkPriority
                        })));
                        if (sprop.vpnName && sprop.vpnName.length > 0) cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.MSGVPNNAME, nullTerminate(sprop.vpnName)));
                        if (sprop.applicationDescription && sprop.applicationDescription.length > 0) cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTDESC, nullTerminate(sprop.applicationDescription)));
                        if (sprop.userIdentification && sprop.userIdentification.length > 0) cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.USERID, nullTerminate(sprop.userIdentification)));
                        if (sprop.authenticationScheme === AuthenticationScheme.OAUTH2) {
                            cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.AUTHENTICATION_SCHEME, SMFClientCtrlAuthType.OAUTH2));
                            if (sprop.idToken) smfHeader.pm_oidc_id_token = nullTerminate(sprop.idToken);
                            if (sprop.accessToken) smfHeader.pm_oauth2_access_token = nullTerminate(sprop.accessToken);
                            if (sprop.issuerIdentifier) smfHeader.pm_oauth2_issuer_identifier = nullTerminate(sprop.issuerIdentifier);
                        }
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTNAME, nullTerminate(sprop.clientName)));
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.PLATFORM, nullTerminate(`${Process.platform} - JS API (${Version.mode})`)));
                        if (sprop.noLocal) cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.NO_LOCAL, ""));
                        if (isClientCert) cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.AUTHENTICATION_SCHEME, SMFClientCtrlAuthType.CLIENT_CERTIFICATE));
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.SOFTWAREDATE, nullTerminate(Version.formattedDate)));
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.SOFTWAREVERSION, nullTerminate(Version.version)));
                        if (compressedTLS && plaintextTLS) cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, "")); else if (compressedTLS) cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, "")); else if (plaintextTLS) cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, "\0"));
                        const clientCaps = clientCapsToStr([ ClientCapabilityType.UNBIND_ACK, ClientCapabilityType.BR_ERRORID, ClientCapabilityType.PQ ]);
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENT_CAPABILITIES, clientCaps));
                        const keepaliveVal = int32ToStr(sprop.keepAliveIntervalInMsecs / 1e3);
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.KEEP_ALIVE_INTERVAL, keepaliveVal));
                        return cc;
                    }
                    static getUpdate(mutableSessionProperty, newValue, correlationTag) {
                        const cc = new ClientCtrlMessage(SMFClientCtrlMessageType.UPDATE);
                        const smfHeader = cc.smfHeader;
                        smfHeader.pm_corrtag = correlationTag;
                        if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
                            const appdesc = (newValue || "").toString().substr(0, 250);
                            cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTDESC, nullTerminate(appdesc)));
                        } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
                            const error = ClientCtrlMessage.validateClientName(newValue, errorMessage => new OperationError(`Invalid clientName: ` + errorMessage, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                            if (error) throw error;
                            cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTNAME, nullTerminate(newValue)));
                        }
                        return cc;
                    }
                    static validateClientName(strName, exceptionCreator) {
                        const encodeResult = validateAndEncode(DestinationType.TOPIC, strName, exceptionCreator);
                        if (encodeResult.error) return encodeResult.error;
                        if (encodeResult.bytes.length > 161) return exceptionCreator("Client Name too long (max length: 160).");
                        return null;
                    }
                }
                module.exports.ClientCtrlMessage = ClientCtrlMessage;
            },
            "./modules/solclient-smf/lib/message-objects/keep-alive-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const BaseMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js").BaseMessage;
                const SMFHeader = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js").SMFHeader;
                const SMFProtocol = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js").SMFProtocol;
                class KeepAliveMessage extends BaseMessage {
                    constructor() {
                        super(new SMFHeader(SMFProtocol.KEEPALIVEV2, 2));
                        this._smfHeader.smf_uh = 2;
                    }
                }
                module.exports.KeepAliveMessage = KeepAliveMessage;
            },
            "./modules/solclient-smf/lib/message-objects/smf-header.js": module => {
                class SMFHeader {
                    constructor(protocol = 0, ttl = 0) {
                        this._parameters = [];
                        this.smf_version = 3;
                        this.smf_uh = 0;
                        this.smf_protocol = protocol;
                        this.smf_priority = 0;
                        this.smf_ttl = ttl;
                        this.smf_msgLen = 0;
                        this.smf_di = 0;
                        this.smf_tqd = 0;
                        this.smf_elidingEligible = 0;
                        this.smf_dto = 0;
                        this.smf_adf = 0;
                        this.smf_deadMessageQueueEligible = 0;
                        this.pm_userdata = null;
                        this.pm_respcode = 0;
                        this.pm_respstr = null;
                        this.pm_username = null;
                        this.pm_password = null;
                        this.pm_tr_topicname_bytes = null;
                        this.pm_deliverymode = null;
                        this.pm_ad_msgid = void 0;
                        this.pm_ad_prevmsgid = void 0;
                        this.pm_ad_redelflag = 0;
                        this.pm_ad_flowredelflag = 0;
                        this.pm_ad_ttl = void 0;
                        this.pm_ad_ackimm = void 0;
                        this.pm_ad_flowid = 0;
                        this.pm_ad_publisherid = 0;
                        this.pm_ad_publishermsgid = 0;
                        this.pm_content_summary = null;
                        this.pm_corrtag = null;
                        this.pm_topic_offset = 0;
                        this.pm_topic_len = 0;
                        this.pm_queue_offset = 0;
                        this.pm_queue_len = 0;
                        this.pm_msg_priority = null;
                        this.pm_oauth2_access_token = null;
                        this.pm_oidc_id_token = null;
                        this.pm_oauth2_issuer_identifier = null;
                        this.pm_ts_transport_context = null;
                        this.unknownProtoFlag = false;
                        this.messageLength = 0;
                        this.payloadLength = 0;
                        this.headerLength = 0;
                        this.payload = null;
                        this.discardMessage = false;
                    }
                    setMessageSizes(headerLength, payloadLength) {
                        this.headerLength = headerLength;
                        this.payloadLength = payloadLength;
                        this.messageLength = headerLength + payloadLength;
                    }
                    setPayloadSize(payloadLength) {
                        this.payloadLength = payloadLength;
                    }
                }
                module.exports.SMFHeader = SMFHeader;
            },
            "./modules/solclient-smf/lib/message-objects/smf-parameter.js": module => {
                class SMFParameter {
                    constructor(uh, type, value, buffer, begin, end) {
                        this._type = type;
                        this._value = value;
                        this._uh = uh;
                        this._buffer = buffer;
                        this._begin = begin;
                        this._end = end;
                    }
                    getType() {
                        return this._type;
                    }
                    getValue() {
                        if (this._buffer && !this._value) return this._buffer.toString("latin1", this._begin, this._end);
                        return this._value;
                    }
                    getUh() {
                        return this._uh;
                    }
                    getBuffer() {
                        return this._buffer;
                    }
                    getBegin() {
                        return this._begin;
                    }
                    getEnd() {
                        return this._end;
                    }
                    toString() {
                        return `${this._uh}:0x${this._type.toString(16)} = ` + this.getValue();
                    }
                }
                module.exports.SMFParameter = SMFParameter;
            },
            "./modules/solclient-smf/lib/message-objects/smf-uh.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFUH = {
                    IGNORE: 0,
                    REJECT: 2
                };
                module.exports.SMFUH = Enum.new(SMFUH);
            },
            "./modules/solclient-smf/lib/message-objects/smp-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const assert = __webpack_require__("./modules/solclient-eskit/api.js").assert;
                const BaseMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js").BaseMessage;
                const {
                    Destination,
                    DestinationUtil
                } = __webpack_require__("./modules/solclient-destination/api.js");
                const SMFHeader = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js").SMFHeader;
                const SMFProtocol = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js").SMFProtocol;
                const SMFSMPMessageType = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-types.js").SMFSMPMessageType;
                const SMFSMPMessageTypeFlags = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-type-flags.js").SMFSMPMessageTypeFlags;
                class SMPMessage extends BaseMessage {
                    constructor() {
                        super(new SMFHeader(SMFProtocol.SMP, 1));
                        this.msgType = 0;
                        this.encodedUtf8Subscription = null;
                        this.encodedUtf8QueueName = null;
                        this.smpFlags = 0 | SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC;
                        this._encodedQueueName = null;
                        this._encodedClientName = null;
                    }
                    isFlag(flagMask) {
                        return this.smpFlags & flagMask;
                    }
                    setFlag(flagMask, value) {
                        if (value) this.smpFlags |= flagMask; else this.smpFlags &= ~flagMask;
                    }
                    static getSubscriptionMessage(correlationTag, topic, add, requestConfirm) {
                        assert(topic instanceof Destination, "Topics are not UCS-2 strings. Pass a Topic object.");
                        const smp = new SMPMessage();
                        smp.msgType = add ? SMFSMPMessageType.ADDSUBSCRIPTION : SMFSMPMessageType.REMSUBSCRIPTION;
                        smp.encodedUtf8Subscription = topic.getBytes();
                        assert(smp.encodedUtf8Subscription, "Topic had no encoding");
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC, true);
                        if (requestConfirm) smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_RESPREQUIRED, true);
                        smp._smfHeader.pm_corrtag = correlationTag;
                        return smp;
                    }
                    static getQueueSubscriptionMessage(correlationTag, topic, queue, add) {
                        assert(topic instanceof Destination, "Topics are not UCS-2 strings. Pass a Topic object.");
                        const smp = new SMPMessage();
                        smp.msgType = add ? SMFSMPMessageType.ADDQUEUESUBSCRIPTION : SMFSMPMessageType.REMQUEUESUBSCRIPTION;
                        smp.encodedUtf8QueueName = DestinationUtil.encodeBytes(queue.getName());
                        smp.encodedUtf8Subscription = topic.getBytes();
                        assert(smp.encodedUtf8Subscription, "Topic had no encoding");
                        assert(smp.encodedUtf8QueueName, "Queue had no encoding");
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC, true);
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_RESPREQUIRED, true);
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_PERSIST, true);
                        smp._smfHeader.pm_corrtag = correlationTag;
                        return smp;
                    }
                }
                module.exports.SMPMessage = SMPMessage;
            },
            "./modules/solclient-smf/lib/message-objects/transport-smf-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const BaseMessage = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js").BaseMessage;
                class TransportSMFMessage extends BaseMessage {
                    constructor() {
                        super(null, null);
                        this.uh = 0;
                        this.messageType = null;
                        this.sessionId = null;
                        this.routerTag = null;
                        this.payload = null;
                        this.payloadLength = 0;
                        this.tsHeaderLength = 0;
                    }
                }
                module.exports.TransportSMFMessage = TransportSMFMessage;
            },
            "./modules/solclient-smf/lib/smf-adprotocol-message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFAdProtocolMessageType = {
                    OPENPUBFLOW: 0,
                    CLIENTACK: 3,
                    BIND: 4,
                    UNBIND: 5,
                    UNSUBSCRIBE: 6,
                    CLOSEPUBFLOW: 7,
                    CREATE: 8,
                    DELETE: 9,
                    TRANSACTIONCTRL: 11,
                    FLOWCHANGEUPDATE: 12,
                    XACTRL: 14,
                    CLIENTNACK: 15
                };
                module.exports.SMFAdProtocolMessageType = Enum.new(SMFAdProtocolMessageType);
            },
            "./modules/solclient-smf/lib/smf-adprotocol-params.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFAdProtocolParam = {
                    LASTMSGIDSENT: 1,
                    LASTMSGIDACKED: 2,
                    WINDOW: 3,
                    TRANSPORT_PRIORITY: 4,
                    APPLICATION_ACK: 5,
                    FLOWID: 6,
                    QUEUENAME: 7,
                    DTENAME: 8,
                    TOPICNAME: 9,
                    FLOWNAME: 10,
                    EP_DURABLE: 11,
                    ACCESSTYPE: 12,
                    SELECTOR: 13,
                    TRANSPORT_WINDOW: 14,
                    LINGER_OPTION: 15,
                    LASTMSGIDRECEIVED: 16,
                    EP_ALLOTHER_PERMISSION: 17,
                    FLOWTYPE: 18,
                    EP_QUOTA: 19,
                    EP_MAX_MSGSIZE: 20,
                    GRANTED_PERMISSIONS: 21,
                    EP_RESPECTS_TTL: 22,
                    TRANSACTION_CTRL_MESSAGE_TYPE: 23,
                    TRANSACTED_SESSION_ID: 24,
                    TRANSACTED_SESSION_NAME: 25,
                    TRANSACTION_ID: 26,
                    TRANSACTED_SESSION_STATE: 27,
                    TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY: 28,
                    TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK: 29,
                    TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK: 30,
                    NOLOCAL: 31,
                    ACTIVE_FLOW_INDICATION: 32,
                    WANT_FLOW_CHANGE_NOTIFY: 33,
                    EP_BEHAVIOUR: 34,
                    PUBLISHER_ID: 35,
                    APPLICATION_PUB_ACK: 36,
                    NUM_MESSAGES_SPOOLED: 37,
                    CUT_THROUGH: 38,
                    PUBLISHER_FLAGS: 39,
                    APP_MSG_ID_TYPE: 40,
                    QUEUE_ENDPOINT_HASH: 41,
                    MAX_REDELIVERY: 42,
                    PAYLOAD: 43,
                    ENDPOINT_ID: 44,
                    ACK_SEQUENCE_NUMBER: 45,
                    ACK_RECONCILE_REQUEST: 46,
                    START_OF_ACK_RECONCILE: 47,
                    TIMESTAMP: 48,
                    MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW: 49,
                    REPLAY_START_LOCATION: 51,
                    ENDPOINT_ERROR_ID: 52,
                    SPOOLER_UNIQUE_ID: 54,
                    PARTITION_GROUP_ID: 56
                };
                module.exports.SMFAdProtocolParam = Enum.new(SMFAdProtocolParam);
            },
            "./modules/solclient-smf/lib/smf-client-ctrl-message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFClientCtrlMessageType = {
                    LOGIN: 0,
                    UPDATE: 1
                };
                module.exports.SMFClientCtrlMessageType = Enum.new(SMFClientCtrlMessageType);
            },
            "./modules/solclient-smf/lib/smf-client-ctrl-params.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFClientCtrlParam = {
                    SOFTWAREVERSION: 0,
                    SOFTWAREDATE: 1,
                    PLATFORM: 2,
                    USERID: 3,
                    CLIENTDESC: 4,
                    CLIENTNAME: 5,
                    MSGVPNNAME: 6,
                    DELIVERTOONEPRIORITY: 7,
                    P2PTOPIC: 8,
                    ROUTER_CAPABILITIES: 9,
                    VRIDNAME: 10,
                    PHYSICALROUTERNAME: 12,
                    BRIDGE_MSG_VPN_NAME: 13,
                    BRIDGE_ROUTER_NAME: 14,
                    NO_LOCAL: 15,
                    BRIDGE_VERSION: 16,
                    AUTHENTICATION_SCHEME: 17,
                    CONNECTION_TYPE: 18,
                    ROUTER_CAPABILITIES_EXTENDED: 19,
                    REQUIRES_RELEASE_7: 20,
                    SSL_DOWNGRADE: 21,
                    CLIENT_CAPABILITIES: 23,
                    KEEP_ALIVE_INTERVAL: 24
                };
                const SMFClientCtrlAuthType = {
                    CLIENT_CERTIFICATE: "",
                    OAUTH2: "\n"
                };
                module.exports.SMFClientCtrlAuthType = Enum.new(SMFClientCtrlAuthType);
                module.exports.SMFClientCtrlParam = Enum.new(SMFClientCtrlParam);
            },
            "./modules/solclient-smf/lib/smf-parameter-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFParameterType = {
                    PADDING: 0,
                    PUBLISHER_ID: 1,
                    PUBLISHER_MSGID: 2,
                    MESSAGEPRIORITY: 3,
                    USERDATA: 4,
                    USERNAME: 6,
                    PASSWORD: 7,
                    RESPONSE: 8,
                    SUB_ID_LIST: 10,
                    GENERIC_ATTACHMENT: 11,
                    BINARY_ATTACHMENT: 12,
                    DELIVERY_MODE: 16,
                    ASSURED_MESSAGE_ID: 17,
                    ASSURED_PREVMESSAGE_ID: 18,
                    ASSURED_REDELIVERED_FLAG: 19,
                    MESSAGE_CONTENT_SUMMARY: 22,
                    ASSURED_FLOWID: 23,
                    TR_TOPICNAME: 24,
                    AD_FLOWREDELIVERED_FLAG: 25,
                    AD_TIMETOLIVE: 28,
                    AD_TOPICSEQUENCE_NUMBER: 30,
                    EXTENDED_TYPE_STREAM: 31,
                    AD_ACK_MESSAGE_ID: 41,
                    AD_SPOOLER_UNIQUE_ID: 44,
                    AD_REPL_MATE_ACK_MSGID: 45,
                    AD_REDELIVERY_COUNT: 46,
                    LIGHT_CORRELATION: 0,
                    LIGHT_TOPIC_NAME_OFFSET: 1,
                    LIGHT_QUEUE_NAME_OFFSET: 2,
                    LIGHT_ACK_IMMEDIATELY: 3
                };
                const SMFExtendedParameterType = {
                    OAUTH2_ISSUER_IDENTIFIER: 47,
                    OIDC_ID_TOKEN: 48,
                    OAUTH2_ACCESS_TOKEN: 49,
                    PARTITION_KEY_HASH: 53,
                    TS_TRANSPORT_CONTEXT: 54
                };
                module.exports.SMFParameterType = Enum.new(SMFParameterType);
                module.exports.SMFExtendedParameterType = Enum.new(SMFExtendedParameterType);
            },
            "./modules/solclient-smf/lib/smf-protocols.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFProtocol = {
                    CSPF: 1,
                    CSMP: 2,
                    PUBMSG: 3,
                    XMLLINK: 4,
                    WSE: 5,
                    SEMP: 6,
                    SUBCTRL: 7,
                    PUBCTRL: 8,
                    ADCTRL: 9,
                    KEEPALIVE: 10,
                    KEEPALIVEV2: 11,
                    CLIENTCTRL: 12,
                    TRMSG: 13,
                    JNDI: 14,
                    SMP: 15,
                    SMRP: 16,
                    SMF_IN_SMF: 17,
                    SMF_IN_RV: 18,
                    ADCTRL_PASSTHROUGH: 19,
                    TSESSION: 20
                };
                module.exports.SMFProtocol = Enum.new(SMFProtocol);
            },
            "./modules/solclient-smf/lib/smf-smp-message-type-flags.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFSMPMessageTypeFlags = {
                    FLAG_FILTER: 1,
                    FLAG_PERSIST: 2,
                    SMF_SMP_FLAG_TOPIC: 4,
                    SMF_SMP_FLAG_RESPREQUIRED: 8,
                    SMF_SMP_FLAG_DELIVERALWAYS: 16
                };
                module.exports.SMFSMPMessageTypeFlags = Enum.new(SMFSMPMessageTypeFlags);
            },
            "./modules/solclient-smf/lib/smf-smp-message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFSMPMessageType = {
                    ADDSUBSCRIPTION: 0,
                    REMSUBSCRIPTION: 1,
                    ADDQUEUESUBSCRIPTION: 2,
                    REMQUEUESUBSCRIPTION: 3,
                    ADDSUBSCRIPTIONFORCLIENTNAME: 4,
                    REMSUBSCRIPTIONFORCLIENTNAME: 5
                };
                module.exports.SMFSMPMessageType = Enum.new(SMFSMPMessageType);
            },
            "./modules/solclient-smf/lib/smf-transport-session-message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const SMFTransportSessionMessageType = {
                    CREATE: 0,
                    CREATE_RESP: 1,
                    DESTROY: 2,
                    DESTROY_RESP: 3,
                    DATA: 4,
                    DATA_TOKEN: 5,
                    DATA_STREAM_TOKEN: 6
                };
                module.exports.SMFTransportSessionMessageType = Enum.new(SMFTransportSessionMessageType);
            },
            "./modules/solclient-solcache-session/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const CacheCBInfo = __webpack_require__("./modules/solclient-solcache-session/lib/cache-cb-info.js").CacheCBInfo;
                const CacheContext = __webpack_require__("./modules/solclient-solcache-session/lib/cache-context.js").CacheContext;
                const CacheLiveDataAction = __webpack_require__("./modules/solclient-solcache-session/lib/cache-live-data-actions.js").CacheLiveDataAction;
                const CacheRequest = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request.js").CacheRequest;
                const CacheRequestResult = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request-result.js").CacheRequestResult;
                const CacheReturnCode = __webpack_require__("./modules/solclient-solcache-session/lib/cache-return-codes.js").CacheReturnCode;
                const CacheReturnSubcode = __webpack_require__("./modules/solclient-solcache-session/lib/cache-return-subcodes.js").CacheReturnSubcode;
                const CacheSession = __webpack_require__("./modules/solclient-solcache-session/lib/cache-session.js").CacheSession;
                const CacheSessionProperties = __webpack_require__("./modules/solclient-solcache-session/lib/cache-session-properties.js").CacheSessionProperties;
                module.exports.CacheCBInfo = CacheCBInfo;
                module.exports.CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;
                module.exports.CacheLiveDataAction = CacheLiveDataAction;
                module.exports.CacheRequestResult = CacheRequestResult;
                module.exports.CacheReturnCode = CacheReturnCode;
                module.exports.CacheReturnSubcode = CacheReturnSubcode;
                module.exports.CacheRequest = CacheRequest;
                module.exports.CacheSession = CacheSession;
                module.exports.CacheSessionProperties = CacheSessionProperties;
            },
            "./modules/solclient-solcache-session/lib/cache-cb-info.js": module => {
                class CacheCBInfo {
                    constructor(cacheCBFunction, userObject) {
                        this.cacheCBFunction = cacheCBFunction;
                        this.userObject = userObject;
                    }
                    getCallback() {
                        return this.cacheCBFunction;
                    }
                    getUserObject() {
                        return this.userObject;
                    }
                }
                module.exports.CacheCBInfo = CacheCBInfo;
            },
            "./modules/solclient-solcache-session/lib/cache-context.js": module => {
                const CacheContext = {
                    CACHE_REQUEST_PREFIX: "#CRQ",
                    cacheRequestCorrelationId: 0
                };
                module.exports.CacheContext = CacheContext;
            },
            "./modules/solclient-solcache-session/lib/cache-get-result-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const CacheGetResultCode = {
                    INVALID: 0,
                    OK: 1
                };
                module.exports.CacheGetResultCode = Enum.new(CacheGetResultCode);
            },
            "./modules/solclient-solcache-session/lib/cache-get-result.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const CacheGetResultCode = __webpack_require__("./modules/solclient-solcache-session/lib/cache-get-result-codes.js").CacheGetResultCode;
                const DEFAULTS = {
                    messageID: null,
                    version: 0,
                    responseCode: CacheGetResultCode.INVALID,
                    responseString: "",
                    matchTopic: "",
                    sessionID: null,
                    isSuspect: null,
                    hasMore: null,
                    hasTimestamps: null,
                    replyTo: null,
                    messageStream: null,
                    clusterNameStream: null
                };
                class CacheGetResult {
                    constructor(options = DEFAULTS) {
                        Object.assign(this, options);
                    }
                    readFromStream(stream) {
                        this.messageID = stream.getNext().getValue();
                        this.version = stream.getNext().getValue();
                        this.responseCode = stream.getNext().getValue();
                        this.responseString = stream.getNext().getValue();
                        this.matchTopic = stream.getNext().getValue();
                        this.sessionID = stream.getNext().getValue();
                        this.isSuspect = stream.getNext().getValue();
                        this.hasMore = stream.getNext().getValue();
                        this.hasTimestamps = stream.getNext().getValue();
                        if (stream.hasNext()) this.messageStream = stream.getNext().getValue();
                        if (stream.hasNext()) {
                            this.clusterNameStream = this.messageStream;
                            this.messageStream = stream.getNext().getValue();
                        }
                    }
                }
                module.exports.CacheGetResult = CacheGetResult;
            },
            "./modules/solclient-solcache-session/lib/cache-live-data-actions.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const CacheLiveDataAction = {
                    FULFILL: 1,
                    QUEUE: 2,
                    FLOW_THRU: 3
                };
                module.exports.CacheLiveDataAction = Enum.new(CacheLiveDataAction);
            },
            "./modules/solclient-solcache-session/lib/cache-request-result.js": module => {
                class CacheRequestResult {
                    constructor(rc, subcode, topic, error) {
                        this._returnCode = rc;
                        this._subcode = subcode;
                        this._topic = topic;
                        this._error = error;
                    }
                    getReturnCode() {
                        return this._returnCode;
                    }
                    getReturnSubcode() {
                        return this._subcode;
                    }
                    getTopic() {
                        return this._topic;
                    }
                    getError() {
                        return this._error;
                    }
                }
                module.exports.CacheRequestResult = CacheRequestResult;
            },
            "./modules/solclient-solcache-session/lib/cache-request-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const CacheRequestType = {
                    INVALID: 0,
                    BULK_MSG: 1,
                    REGISTER_REQUEST: 2,
                    REGISTER_RESPONSE: 3,
                    HEARTBEAT_REQUEST: 4,
                    HEARTBEAT_RESPONSE: 5,
                    EVENT_NOTIFY: 6,
                    EVENT_ACK: 7,
                    ACTION_REQUEST: 8,
                    ACTION_RESPONSE: 9,
                    GET_REQUEST: 10,
                    GET_RESPONSE: 11,
                    GET_NEXT_REQUEST: 12,
                    GET_NEXT_RESPONSE: 13,
                    SET_REQUEST: 14,
                    SET_RESPONSE: 15,
                    GET_MSG_REQUEST: 16,
                    GET_MSG_RESPONSE: 17,
                    GET_NEXT_MSG_REQUEST: 18,
                    GET_NEXT_MSG_RESPONSE: 19,
                    UNREGISTER_IND: 20,
                    BULK_SET_REQUEST: 21,
                    BULK_SET_RESPONSE: 22,
                    PURGE_MSG_SEQUENCE_REQUEST: 23,
                    PURGE_MSG_SEQUENCE_RESPONSE: 24,
                    GET_MSG_SEQUENCE_REQUEST: 25,
                    GET_NEXT_MSG_SEQUENCE_REQUEST: 26,
                    GET_TOPIC_INFO_REQUEST: 27,
                    GET_TOPIC_INFO_RESPONSE: 28,
                    READY_MARKER: 29,
                    GET_TOPIC_INFO_REQUEST_RANGE: 30,
                    SYNC_READY_MARKER: 31,
                    VACUUM_REQUEST: 32,
                    VACUUM_RESPONSE: 33
                };
                module.exports.CacheRequestType = Enum.new(CacheRequestType);
            },
            "./modules/solclient-solcache-session/lib/cache-request.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const CacheContext = __webpack_require__("./modules/solclient-solcache-session/lib/cache-context.js").CacheContext;
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;
                class CacheRequest {
                    constructor(cacheSession, cacheMessageType, requestID, cbInfo, liveDataAction, topic, cacheName) {
                        this.cacheSession = cacheSession;
                        this.cacheMessageType = cacheMessageType;
                        this.requestID = requestID;
                        this.cbInfo = cbInfo;
                        this.liveDataAction = liveDataAction;
                        this.topic = topic;
                        this.cacheName = cacheName;
                        this.subscriptionWaiting = null;
                        this.replyReceived = false;
                        this.dataReceived = false;
                        this.isSuspect = false;
                        this.correlationID = `` + CACHE_REQUEST_PREFIX + CacheContext.cacheRequestCorrelationId++;
                        this.childRequests = [];
                        this.parentRequest = null;
                        this.queuedLiveData = [];
                        this.liveDataFulfilled = false;
                        this.timeoutHandle = null;
                    }
                    getRootRequest() {
                        if (!this.parentRequest) return this;
                        return this.parentRequest.getRootRequest();
                    }
                    addChild(childIn) {
                        if (!(childIn instanceof CacheRequest)) throw new Error(`Invalid child ` + childIn);
                        if (childIn === this) throw new Error("Constructing circular child reference");
                        const child = childIn;
                        child.parentRequest = this;
                        this.childRequests.push(child);
                    }
                    removeChild(childIn) {
                        if (childIn === this) throw new Error("Attempting to deconstruct invalid circular child reference");
                        const child = childIn;
                        const childIndex = this.childRequests.indexOf(child);
                        if (-1 === childIndex) child;
                        this.childRequests.splice(childIndex, 1);
                        child.parentRequest = null;
                    }
                    collapse() {
                        const parentRequest = this.parentRequest;
                        parentRequest.isSuspect = parentRequest.isSuspect || this.isSuspect;
                        parentRequest.dataReceived = parentRequest.dataReceived || this.dataReceived;
                        parentRequest.removeChild(this);
                    }
                    cancel() {
                        if (this.parentRequest) this.collapse();
                        while (this.childRequests.length) {
                            const child = this.childRequests.shift();
                            if (child.childRequests) child.cancel();
                            this.removeChild(child);
                        }
                        this.clearRequestTimeout();
                    }
                    getRequestID() {
                        return this.requestID;
                    }
                    getCBInfo() {
                        return this.cbInfo;
                    }
                    getTopic() {
                        return this.topic;
                    }
                    getLiveDataAction() {
                        return this.liveDataAction;
                    }
                    startRequestTimeout(cacheSessionTimeoutCB, timeoutMsec) {
                        this.timeoutHandle = setTimeout(() => {
                            cacheSessionTimeoutCB(this);
                        }, timeoutMsec);
                    }
                    clearRequestTimeout() {
                        if (null === this.timeoutHandle || void 0 === this.timeoutHandle) return;
                        clearTimeout(this.timeoutHandle);
                        this.timeoutHandle = null;
                    }
                    toString() {
                        return `CacheRequest[correlationID=${this.correlationID},requestID=${this.requestID},cacheName=${this.cacheName},topic=${this.topic.getName()}]`;
                    }
                }
                CacheRequest.VERSION = 1;
                CacheRequest.DEFAULT_REPLY_SIZE_LIMIT = 1e6;
                CacheRequest.REPLY_SIZE_LIMIT = CacheRequest.DEFAULT_REPLY_SIZE_LIMIT;
                module.exports.CacheRequest = CacheRequest;
            },
            "./modules/solclient-solcache-session/lib/cache-return-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const CacheReturnCode = {
                    OK: 1,
                    FAIL: 2,
                    INCOMPLETE: 3
                };
                module.exports.CacheReturnCode = Enum.new(CacheReturnCode);
            },
            "./modules/solclient-solcache-session/lib/cache-return-subcodes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const CacheReturnSubcode = {
                    REQUEST_COMPLETE: 0,
                    LIVE_DATA_FULFILL: 1,
                    ERROR_RESPONSE: 2,
                    INVALID_SESSION: 3,
                    REQUEST_TIMEOUT: 4,
                    REQUEST_ALREADY_IN_PROGRESS: 5,
                    NO_DATA: 6,
                    SUSPECT_DATA: 7,
                    CACHE_SESSION_DISPOSED: 8,
                    SUBSCRIPTION_ERROR: 9
                };
                module.exports.CacheReturnSubcode = Enum.new(CacheReturnSubcode);
            },
            "./modules/solclient-solcache-session/lib/cache-session-properties.js": module => {
                class CacheSessionProperties {
                    constructor(cacheName, maxAgeSec, maxMessages, timeoutMsec) {
                        this.cacheName = cacheName;
                        this.maxAgeSec = maxAgeSec || 0;
                        this.maxMessages = null === maxMessages || void 0 === maxMessages ? 1 : maxMessages;
                        this.timeoutMsec = timeoutMsec || 1e4;
                        this.includeOtherClusters = true;
                        this.cachePrefix = "#P2P/CACHEINST/";
                    }
                    getCacheName() {
                        return this.cacheName;
                    }
                    setCacheName(value) {
                        this.cacheName = value;
                    }
                    getMaxMessageAgeSec() {
                        return this.maxAgeSec;
                    }
                    setMaxMessageAgeSec(value) {
                        this.maxAgeSec = value;
                    }
                    getMaxMessages() {
                        return this.maxMessages;
                    }
                    setMaxMessages(value) {
                        this.maxMessages = value;
                    }
                    getTimeoutMsec() {
                        return this.timeoutMsec;
                    }
                    setTimeoutMsec(value) {
                        this.timeoutMsec = value;
                    }
                }
                module.exports.CacheSessionProperties = CacheSessionProperties;
            },
            "./modules/solclient-solcache-session/lib/cache-session-subscribe-info.js": module => {
                class CacheSessionSubscribeInfo {
                    constructor(correlationID, topic, cacheSession) {
                        Object.assign(this, {
                            correlationID: correlationID,
                            topic: topic,
                            cacheSession: cacheSession
                        });
                    }
                }
                module.exports.CacheSessionSubscribeInfo = CacheSessionSubscribeInfo;
            },
            "./modules/solclient-solcache-session/lib/cache-session.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
                const SessionLib = __webpack_require__("./modules/solclient-session/api.js");
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const StatType = __webpack_require__("./modules/solclient-stats/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const {
                    LOG_INFO,
                    LOG_WARN
                } = __webpack_require__("./modules/solclient-log/api.js");
                const {
                    SDTField,
                    SDTFieldType,
                    SDTStreamContainer
                } = __webpack_require__("./modules/solclient-sdt/api.js");
                const CacheCBInfo = __webpack_require__("./modules/solclient-solcache-session/lib/cache-cb-info.js").CacheCBInfo;
                const CacheContext = __webpack_require__("./modules/solclient-solcache-session/lib/cache-context.js").CacheContext;
                const CacheGetResult = __webpack_require__("./modules/solclient-solcache-session/lib/cache-get-result.js").CacheGetResult;
                const CacheLiveDataAction = __webpack_require__("./modules/solclient-solcache-session/lib/cache-live-data-actions.js").CacheLiveDataAction;
                const CacheRequest = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request.js").CacheRequest;
                const CacheRequestResult = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request-result.js").CacheRequestResult;
                const CacheRequestType = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request-types.js").CacheRequestType;
                const CacheReturnCode = __webpack_require__("./modules/solclient-solcache-session/lib/cache-return-codes.js").CacheReturnCode;
                const CacheReturnSubcode = __webpack_require__("./modules/solclient-solcache-session/lib/cache-return-subcodes.js").CacheReturnSubcode;
                const CacheSessionProperties = __webpack_require__("./modules/solclient-solcache-session/lib/cache-session-properties.js").CacheSessionProperties;
                const CacheSessionSubscribeInfo = __webpack_require__("./modules/solclient-solcache-session/lib/cache-session-subscribe-info.js").CacheSessionSubscribeInfo;
                const {
                    Destination,
                    Topic
                } = __webpack_require__("./modules/solclient-destination/api.js");
                const CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;
                const noOp = () => void 0;
                class CacheSession {
                    constructor(props, session, privateInterface) {
                        CacheSession._validateProps(props);
                        const properties = new CacheSessionProperties(props.cacheName, props.maxAgeSec, props.maxMessages, props.timeoutMsec);
                        Object.assign(this, {
                            _outstandingRequests: {},
                            _outstandingIDs: {},
                            _disposed: false,
                            _nextMessageCallbackInfo: null,
                            _nextSessionEventCallbackInfo: null,
                            _properties: properties,
                            _session: session,
                            _sessionIF: privateInterface
                        });
                        this._connectToSession(session);
                    }
                    _connectToSession(session) {
                        this._nextSessionEventCallbackInfo = session.getEventCBInfo();
                        this._nextMessageCallbackInfo = session.getMessageCBInfo();
                        session.setMessageCBInfo(new SessionLib.MessageRxCBInfo((_, message) => {
                            this._handleMessage(message);
                        }, this));
                        session.setEventCBInfo(this._createCompoundEventCB(this._nextSessionEventCallbackInfo));
                    }
                    _createCompoundEventCB(nextDelegate) {
                        return new SessionLib.SessionEventCBInfo((session, sessionEvent, userObject, rfuObject) => {
                            this._handleSessionEvent(nextDelegate, session, sessionEvent, userObject, rfuObject);
                        }, null);
                    }
                    _handleSessionEvent(nextDelegate, session, sessionEvent) {
                        const passEvent = this._processSessionEvent(session, sessionEvent);
                        if (!passEvent) return;
                        const cbUserObject = nextDelegate.userObject;
                        if (!cbUserObject) nextDelegate.sessionEventCBFunction(session, sessionEvent); else nextDelegate.sessionEventCBFunction(session, sessionEvent, cbUserObject);
                    }
                    _sendToNextDelegate(message) {
                        const cbUserObject = this._nextMessageCallbackInfo.userObject;
                        if (!cbUserObject) this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message); else this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message, cbUserObject);
                    }
                    _processSessionEvent(session, event) {
                        switch (event.sessionEventCode) {
                          case SessionLib.SessionEventCode.SUBSCRIPTION_ERROR:
                          case SessionLib.SessionEventCode.SUBSCRIPTION_OK:
                            return this._checkSubscriptionStatus(event);

                          case SessionLib.SessionEventCode.DOWN_ERROR:
                            this.dispose();
                            return true;

                          default:
                            event.sessionEventCode;
                            return true;
                        }
                    }
                    _checkSubscriptionStatus(event) {
                        if (null === event.correlationKey || void 0 === event.correlationKey || !(event.correlationKey instanceof CacheSessionSubscribeInfo) || event.correlationKey.cacheSession !== this) return true;
                        const request = this._getOutstandingRequest(event.correlationKey.correlationID);
                        if (!request) {
                            LOG_WARN(`No request found for subscription success on ` + event.correlationKey.topic);
                            return true;
                        }
                        if (event.sessionEventCode === SessionLib.SessionEventCode.SUBSCRIPTION_OK) {
                            this._handleSubscriptionSuccess(request, event.correlationKey.topic);
                            return false;
                        }
                        this._handleSubscriptionError(request, event);
                        return false;
                    }
                    _handleSubscriptionSuccess(requestIn) {
                        const request = requestIn;
                        request.subscriptionWaiting = null;
                        this._startCacheRequest(request);
                    }
                    _handleSubscriptionError(request) {
                        this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.SUBSCRIPTION_ERROR);
                    }
                    _checkRequestCompletion(request) {
                        if (request.childRequests.length) {
                            request.childRequests.length;
                            return;
                        }
                        if (request.subscriptionWaiting) return;
                        if (null !== request.timeoutHandle && !request.replyReceived) return;
                        if (request.parentRequest) {
                            const parent = request.parentRequest;
                            request.cancel();
                            this._unregisterRequest(request);
                            this._checkRequestCompletion(parent);
                            return;
                        }
                        let code;
                        let subcode;
                        if (request.isSuspect) {
                            code = CacheReturnCode.INCOMPLETE;
                            subcode = CacheReturnSubcode.SUSPECT_DATA;
                        } else if (request.dataReceived) {
                            code = CacheReturnCode.OK;
                            if (request.liveDataFulfilled) subcode = CacheReturnSubcode.LIVE_DATA_FULFILL; else subcode = CacheReturnSubcode.REQUEST_COMPLETE;
                        } else if (request.replyReceived) {
                            code = CacheReturnCode.INCOMPLETE;
                            subcode = CacheReturnSubcode.NO_DATA;
                        } else throw new Error("Sanity: should never happen");
                        this._terminateRequest(request, code, subcode);
                    }
                    _sendSeeOther(parentRequest, cacheGetResult) {
                        const clusterName = cacheGetResult.clusterNameStream.getNext().getValue();
                        clusterName;
                        const childRequest = new CacheRequest(this, CacheRequestType.GET_MSG_REQUEST, parentRequest.requestID, new CacheCBInfo(noOp, null), parentRequest.liveDataAction, parentRequest.topic, clusterName);
                        parentRequest.addChild(childRequest);
                        this._registerRequest(childRequest);
                        childRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                        this._startCacheRequest(childRequest, null, null, true);
                    }
                    _sendGetNext(parentRequest, cacheGetResult) {
                        const nextRequest = new CacheRequest(this, CacheRequestType.GET_NEXT_MSG_REQUEST, parentRequest.requestID, new CacheCBInfo(noOp, null), parentRequest.liveDataAction, parentRequest.topic, parentRequest.cacheName);
                        parentRequest.addChild(nextRequest);
                        this._registerRequest(nextRequest);
                        nextRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                        this._startCacheRequest(nextRequest, cacheGetResult.sessionID, cacheGetResult.replyTo);
                    }
                    _handleMessage(message) {
                        const correlationID = message.getCorrelationId();
                        const request = null === correlationID || void 0 === correlationID ? null : this._outstandingRequests[correlationID];
                        if (!request) {
                            if (this._relevantLiveData(message)) this._sendToNextDelegate(message);
                            return;
                        }
                        request;
                        request.clearRequestTimeout();
                        const streamField = message.getSdtContainer();
                        const stream = streamField && streamField.getValue();
                        if (!stream) {
                            LOG_INFO(`Invalid message format for cache response: no SDT container (${streamField}) or stream (${stream})`);
                            this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                        }
                        this._incStat(StatType.RX_REPLY_MSG_RECVED);
                        request.replyReceived = true;
                        if (request.getRootRequest().liveDataFulfilled) {
                            this._incStat(StatType.CACHE_REQUEST_FULFILL_DISCARD_RESPONSE);
                            this._checkRequestCompletion(request);
                            return;
                        }
                        if (!stream) {
                            LOG_INFO("Invalid cache response did not fulfill request. Skipping response processing");
                            return;
                        }
                        try {
                            const result = new CacheGetResult();
                            result.readFromStream(stream);
                            result.replyTo = message.getReplyTo();
                            if (result.responseString) result.responseString;
                            if (7 === result.responseCode || "Invalid Session" == result.responseString) {
                                LOG_INFO(`Cluster response indicates invalid session: ${result.responseString} code: ` + result.responseCode);
                                this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.INVALID_SESSION);
                            }
                            request.isSuspect = request.isSuspect || result.isSuspect;
                            const messages = CacheSession._decodeMessageStream(request, result);
                            this._incStat(StatType.RX_CACHE_MSG, messages.length);
                            if (result.hasMore) this._sendGetNext(request, result);
                            if (result.clusterNameStream) while (result.clusterNameStream.hasNext()) this._sendSeeOther(request, result);
                            if (messages) messages.forEach(m => {
                                this._sendToNextDelegate(m);
                            });
                            this._checkRequestCompletion(request);
                        } catch (exception) {
                            LOG_INFO(`Invalid message format for cache response: ` + exception.stack);
                            this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                        }
                    }
                    _relevantLiveData(message) {
                        if (message.getCorrelationId() && message.getCorrelationId().startsWith(CACHE_REQUEST_PREFIX) && !(this._nextMessageCallbackInfo.userObject instanceof CacheSession)) {
                            LOG_WARN("DROP: Dropping CRQ reply due to no remaining Cache Session processors on message " + "callback chain");
                            this._incStat(StatType.RX_REPLY_MSG_DISCARD);
                            return false;
                        }
                        return Object.keys(this._outstandingRequests).every(checkCID => this._performLiveDataAction(this._outstandingRequests[checkCID], message));
                    }
                    _performLiveDataAction(requestIn, message) {
                        const request = requestIn;
                        request.dataReceived = true;
                        switch (request.liveDataAction) {
                          case CacheLiveDataAction.QUEUE:
                            request.queuedLiveData.push(message);
                            return false;

                          case CacheLiveDataAction.FULFILL:
                            if (!request.liveDataFulfilled) this._fulfillRequest(request);
                            return true;

                          default:
                            return true;
                        }
                    }
                    _fulfillRequest(requestIn) {
                        const request = requestIn;
                        request.liveDataFulfilled = true;
                        this._trackCompletionStats(CacheReturnCode.OK, CacheReturnSubcode.LIVE_DATA_FULFILL);
                        setTimeout(() => {
                            CacheSession._notifyCallback(request, CacheReturnCode.OK, CacheReturnSubcode.LIVE_DATA_FULFILL, request.getTopic(), null);
                        }, 0);
                    }
                    dispose() {
                        const toTerminate = Object.keys(this._outstandingRequests).map(correlationID => this._outstandingRequests[correlationID]).filter(request => request instanceof CacheRequest);
                        toTerminate.forEach(request => {
                            this._terminateRequest(request, CacheReturnCode.INCOMPLETE, CacheReturnSubcode.CACHE_SESSION_DISPOSED);
                        });
                        this._outstandingRequests = [];
                        this._session.setEventCBInfo(this._nextSessionEventCallbackInfo);
                        this._session.setMessageCBInfo(this._nextMessageCallbackInfo);
                        this._disposed = true;
                    }
                    getProperties() {
                        return this._properties;
                    }
                    sendCacheRequest(requestID, topic, subscribe, liveDataAction, cbInfo) {
                        if (5 !== arguments.length) throw new OperationError(`sendCacheRequest() invoked with an illegal argument count of ` + arguments.length);
                        if ("boolean" !== typeof subscribe) throw new OperationError(`Invalid subscribe flag argument, should be a boolean but was ` + typeof subscribe);
                        if ("number" !== typeof requestID || Number.isNaN(requestID)) throw new OperationError("Invalid requestID", ErrorSubcode.PARAMETER_INVALID_TYPE, null);
                        if (this._outstandingIDs[requestID]) throw new OperationError("Request already in progress with this requestID");
                        if (!(topic instanceof Destination)) throw new OperationError("Invalid topic", ErrorSubcode.PARAMETER_INVALID_TYPE, typeof topic);
                        topic.validate();
                        if (!(liveDataAction === CacheLiveDataAction.FLOW_THRU || liveDataAction === CacheLiveDataAction.FULFILL || liveDataAction === CacheLiveDataAction.QUEUE)) throw new OperationError("Invalid live data action", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        if (topic.isWildcarded() && liveDataAction !== CacheLiveDataAction.FLOW_THRU) throw new OperationError("Wildcarded topic not supported for this live data action", ErrorSubcode.PARAMETER_CONFLICT);
                        if (!(cbInfo instanceof CacheCBInfo)) throw new OperationError("Callback info was not an instance of CacheCBInfo");
                        if (this._disposed) {
                            CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL, CacheReturnSubcode.CACHE_SESSION_DISPOSED, topic, "Cache request failed: the cache session is disposed.");
                            return;
                        }
                        if (this._session._disposed) {
                            CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL, CacheReturnSubcode.INVALID_SESSION, topic, "Cache request failed: the session is disposed.");
                            return;
                        }
                        const request = new CacheRequest(this, CacheRequestType.GET_MSG_REQUEST, requestID, cbInfo, liveDataAction, topic, this._properties.cacheName);
                        const matchingRequestKeys = Object.keys(this._outstandingRequests).filter(key => this._outstandingRequests[key].topic.getName() === topic.getName());
                        if (matchingRequestKeys.length) {
                            const conflictKeys = liveDataAction !== CacheLiveDataAction.FLOW_THRU ? matchingRequestKeys : matchingRequestKeys.filter(k => this._outstandingRequests[k].liveDataAction !== CacheLiveDataAction.FLOW_THRU);
                            if (conflictKeys.length) {
                                const conflictRequest = this._outstandingRequests[conflictKeys[0]];
                                LOG_WARN(`Existing request ${conflictRequest} conflicts. Rejecting request ` + request);
                                this._registerRequest(request);
                                this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.REQUEST_ALREADY_IN_PROGRESS);
                                return;
                            }
                        }
                        this._registerRequest(request);
                        request.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                        if (subscribe) {
                            const waitingForSubscribeInfo = new CacheSessionSubscribeInfo(request.correlationID, topic, this);
                            request._subscriptionWaiting = waitingForSubscribeInfo;
                            this._session.subscribe(topic, true, waitingForSubscribeInfo);
                            return;
                        }
                        this._startCacheRequest(request);
                    }
                    _handleCacheRequestFailed(session, sessionEvent, userObject) {
                        this._terminateRequest(userObject.getRequestID(), CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                    }
                    _registerRequest(request) {
                        this._outstandingRequests[request.correlationID] = request;
                        if (!request.parentRequest) this._outstandingIDs[request.requestID] = request;
                    }
                    _getOutstandingRequest(correlationID) {
                        return this._outstandingRequests[correlationID];
                    }
                    _startCacheRequest(request, sessionID, destination, suppressClusters) {
                        const message = new MessageLib.Message();
                        message.setCorrelationId(request.correlationID);
                        if (destination) message.setDestination(destination); else message.setDestination(Topic.createFromName(this._properties.cachePrefix + request.cacheName));
                        message.setReplyTo(Topic.createFromName(this._session.getSessionProperties().p2pInboxInUse));
                        message.setDeliverToOne(request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST);
                        const stream = new SDTStreamContainer();
                        stream.addField(SDTFieldType.UINT32, request.cacheMessageType);
                        stream.addField(SDTFieldType.UINT32, CacheRequest.VERSION);
                        stream.addField(SDTFieldType.STRING, request.topic.getName());
                        stream.addField(SDTFieldType.UINT32, CacheRequest.REPLY_SIZE_LIMIT);
                        if ("number" === typeof sessionID) stream.addField(SDTFieldType.UINT32, sessionID);
                        stream.addField(SDTFieldType.UINT32, this._properties.maxMessages);
                        stream.addField(SDTFieldType.UINT32, this._properties.maxAgeSec);
                        if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) stream.addField(SDTFieldType.BOOL, this._properties.includeOtherClusters && !suppressClusters);
                        stream.addField(SDTFieldType.BOOL, false);
                        if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) stream.addField(SDTFieldType.UINT32, Math.round(this._properties.timeoutMsec / 1e3));
                        message.setSdtContainer(SDTField.create(SDTFieldType.STREAM, stream));
                        try {
                            this._session.send(message);
                            if (!request.parentRequest) this._incStat(StatType.CACHE_REQUEST_SENT);
                        } catch (e) {
                            LOG_INFO(`Failed to send request: ` + e.message);
                            this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE, e);
                        }
                    }
                    _incStat(statType, value) {
                        if (!this._session) return;
                        if (!this._sessionIF) {
                            LOG_INFO("Can't log stat: session statistics not available");
                            return;
                        }
                        this._sessionIF.incStat(statType, value);
                    }
                    _unregisterRequest(request) {
                        delete this._outstandingRequests[request.correlationID];
                        delete this._outstandingIDs[request.requestID];
                    }
                    _trackCompletionStats(returnCode, subcode) {
                        switch (returnCode) {
                          case CacheReturnCode.OK:
                            this._incStat(StatType.CACHE_REQUEST_OK_RESPONSE);
                            if (subcode === CacheReturnSubcode.LIVE_DATA_FULFILL) this._incStat(StatType.CACHE_REQUEST_LIVE_DATA_FULFILL);
                            break;

                          case CacheReturnCode.INCOMPLETE:
                            this._incStat(StatType.CACHE_REQUEST_INCOMPLETE_RESPONSE);
                            break;

                          case CacheReturnCode.FAIL:
                            this._incStat(StatType.CACHE_REQUEST_FAIL_RESPONSE);
                            break;

                          default:
                            throw new Error("Sanity: no return code supplied");
                        }
                    }
                    _terminateRequest(requestIn, returnCode, subcode, error) {
                        const request = requestIn.getRootRequest();
                        if (!this._outstandingRequests[request.correlationID]) return;
                        const cbInfo = request.cbInfo;
                        if (!cbInfo) {
                            LOG_WARN(`No callback info provided for ${request}. Cannot notify`);
                            return;
                        }
                        const callback = cbInfo.getCallback();
                        if (!callback) {
                            LOG_WARN(`No callback provided for ${request}. Cannot notify`);
                            return;
                        }
                        const topic = request.getTopic();
                        if (!topic) LOG_WARN(`No topic provided for ` + request);
                        request.queuedLiveData.forEach(data => this._sendToNextDelegate(data));
                        request.cancel();
                        this._unregisterRequest(request);
                        if (!request.liveDataFulfilled) {
                            this._trackCompletionStats(returnCode, subcode);
                            CacheSession._notifyCallback(request, returnCode, subcode, topic, error);
                        }
                    }
                    static _decodeMessageStream(requestIn, result) {
                        if (!result.messageStream) return [];
                        const messages = [];
                        const request = requestIn;
                        while (result.messageStream.hasNext()) {
                            request.dataReceived = true;
                            const data = result.messageStream.getNext().getValue();
                            const innerMessage = SMFLib.Codec.Decode.decodeCompoundMessage(data, 0);
                            if (!innerMessage) continue;
                            const cacheStatus = result.isSuspect ? MessageLib.MessageCacheStatus.SUSPECT : MessageLib.MessageCacheStatus.CACHED;
                            innerMessage._setCacheStatus(cacheStatus);
                            innerMessage._setCacheRequestID(request.requestID);
                            messages.push(innerMessage);
                        }
                        messages.length;
                        return messages;
                    }
                    static _handleCacheRequestTimeout(cacheRequest) {
                        const context = cacheRequest.cacheSession;
                        if (!context._getOutstandingRequest(cacheRequest.correlationID)) {
                            LOG_INFO(`Timeout for ${cacheRequest} was not unregistered. Ignoring`);
                            return;
                        }
                        LOG_INFO(`Request ${cacheRequest} timed out`);
                        context._terminateRequest(cacheRequest.getRootRequest(), CacheReturnCode.INCOMPLETE, CacheReturnSubcode.REQUEST_TIMEOUT);
                    }
                    static _notifyCallback(request, returnCode, subcode, topic, error) {
                        const cbInfo = request.cbInfo;
                        const callback = cbInfo.getCallback();
                        callback(request.requestID, new CacheRequestResult(returnCode, subcode, topic, error), cbInfo.getUserObject());
                    }
                    static _notifyCallbackError(cbInfo, requestID, returnCode, subcode, topic, error) {
                        const callback = cbInfo.getCallback();
                        callback(requestID, new CacheRequestResult(returnCode, subcode, topic, error), cbInfo.getUserObject());
                    }
                    static _validateProps(props) {
                        if ("string" !== typeof props.cacheName) throw new OperationError("Invalid parameter type for cacheName", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        if (Topic.createFromName(props.cacheName).isWildcarded()) throw new OperationError(`Invalid cacheName '${props.cacheName}'. The cacheName cannot be wildcarded`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        if ("number" !== typeof props.maxAgeSec) throw new OperationError("Invalid parameter type for maxAgeSec", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        if (props.maxAgeSec < 0) throw new OperationError("Invalid value for maxAgeSec; must be >= 0", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        if ("number" !== typeof props.maxMessages) throw new OperationError("Invalid parameter type for maxMessages", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        if (props.maxMessages < 0) throw new OperationError("Invalid value for maxMessages; must be >= 0", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        if ("number" !== typeof props.timeoutMsec) throw new OperationError("Invalid parameter type for timeoutMsec", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        if (props.timeoutMsec < 3e3) throw new OperationError("Invalid value for timeoutMsec; must be >= 3000", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                }
                module.exports.CacheSession = CacheSession;
            },
            "./modules/solclient-stats/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Stats = __webpack_require__("./modules/solclient-stats/lib/stats.js").Stats;
                const StatsByMode = __webpack_require__("./modules/solclient-stats/lib/stat-bymode.js").StatsByMode;
                const StatType = __webpack_require__("./modules/solclient-stats/lib/stat-types.js").StatType;
                module.exports = {
                    Stats: Stats,
                    StatType: StatType,
                    StatsByMode: StatsByMode
                };
            },
            "./modules/solclient-stats/lib/stat-bymode.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const StatType = __webpack_require__("./modules/solclient-stats/lib/stat-types.js").StatType;
                module.exports = {
                    StatsByMode: {
                        STAT_TX_BYMODE_MSGS: [ StatType.TX_DIRECT_MSGS, StatType.TX_PERSISTENT_MSGS, StatType.TX_NONPERSISTENT_MSGS ],
                        STAT_TX_BYMODE_BYTES: [ StatType.TX_DIRECT_BYTES, StatType.TX_PERSISTENT_BYTES, StatType.TX_NONPERSISTENT_BYTES ],
                        STAT_TX_BYMODE_REDELIVERED: [ StatType.TX_DIRECT_MSGS, StatType.TX_PERSISTENT_REDELIVERED, StatType.TX_NONPERSISTENT_REDELIVERED ],
                        STAT_TX_BYMODE_BYTES_REDELIVERED: [ StatType.TX_DIRECT_BYTES, StatType.TX_PERSISTENT_BYTES_REDELIVERED, StatType.TX_NONPERSISTENT_BYTES_REDELIVERED ],
                        STAT_RX_BYMODE_MSGS: [ StatType.RX_DIRECT_MSGS, StatType.RX_PERSISTENT_MSGS, StatType.RX_NONPERSISTENT_MSGS ],
                        STAT_RX_BYMODE_BYTES: [ StatType.RX_DIRECT_BYTES, StatType.RX_PERSISTENT_BYTES, StatType.RX_NONPERSISTENT_BYTES ]
                    }
                };
            },
            "./modules/solclient-stats/lib/stat-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const StatType = {
                    TX_TOTAL_DATA_BYTES: 0,
                    TX_TOTAL_DATA_MSGS: 1,
                    TX_DIRECT_BYTES: 2,
                    TX_DIRECT_MSGS: 3,
                    TX_CONTROL_BYTES: 4,
                    TX_CONTROL_MSGS: 5,
                    TX_REQUEST_SENT: 6,
                    TX_REQUEST_TIMEOUT: 7,
                    RX_TOTAL_DATA_BYTES: 8,
                    RX_TOTAL_DATA_MSGS: 9,
                    RX_DIRECT_BYTES: 10,
                    RX_DIRECT_MSGS: 11,
                    RX_CONTROL_BYTES: 12,
                    RX_CONTROL_MSGS: 13,
                    RX_DISCARD_MSG_INDICATION: 14,
                    RX_REPLY_MSG_RECVED: 15,
                    RX_REPLY_MSG_DISCARD: 16,
                    RX_DISCARD_SMF_UNKNOWN_ELEMENT: 17,
                    CACHE_REQUEST_SENT: 18,
                    CACHE_REQUEST_OK_RESPONSE: 19,
                    CACHE_REQUEST_FAIL_RESPONSE: 20,
                    CACHE_REQUEST_FULFILL_DISCARD_RESPONSE: 21,
                    RX_CACHE_MSG: 22,
                    CACHE_REQUEST_INCOMPLETE_RESPONSE: 23,
                    CACHE_REQUEST_LIVE_DATA_FULFILL: 24,
                    TX_PERSISTENT_BYTES: 25,
                    TX_PERSISTENT_MSGS: 26,
                    TX_NONPERSISTENT_BYTES: 27,
                    TX_NONPERSISTENT_MSGS: 28,
                    TX_PERSISTENT_BYTES_REDELIVERED: 29,
                    TX_PERSISTENT_REDELIVERED: 30,
                    TX_NONPERSISTENT_BYTES_REDELIVERED: 31,
                    TX_NONPERSISTENT_REDELIVERED: 32,
                    TX_ACKS_RXED: 33,
                    TX_WINDOW_CLOSE: 34,
                    TX_ACK_TIMEOUT: 35,
                    RX_PERSISTENT_BYTES: 36,
                    RX_PERSISTENT_MSGS: 37,
                    RX_NONPERSISTENT_BYTES: 38,
                    RX_NONPERSISTENT_MSGS: 39,
                    RX_ACKED: 40,
                    RX_DISCARD_DUPLICATE: 41,
                    RX_DISCARD_NO_MATCHING_CONSUMER: 42,
                    RX_DISCARD_OUT_OF_ORDER: 43,
                    RX_SETTLE_REJECTED: 44,
                    RX_SETTLE_FAILED: 45,
                    RX_SETTLE_ACCEPTED: 46
                };
                module.exports.StatType = Enum.new(StatType);
            },
            "./modules/solclient-stats/lib/stats.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const EventEmitter = __webpack_require__("./modules/solclient-events/api.js").EventEmitter;
                const StatType = __webpack_require__("./modules/solclient-stats/lib/stat-types.js").StatType;
                class Stats extends EventEmitter {
                    constructor(parent) {
                        super();
                        this._parent = parent;
                        this._statsMap = [];
                        StatType.values.forEach(value => {
                            this._statsMap[value] = 0;
                        });
                    }
                    resetStats() {
                        this.emit("reset");
                        this._statsMap = this._statsMap.map(() => 0);
                    }
                    incStat(statType, value = 1) {
                        this._statsMap[statType] += value;
                        if (this._parent) this._parent.incStat(statType, value);
                    }
                    getStat(statType) {
                        return this._statsMap[statType];
                    }
                }
                module.exports.Stats = Stats;
            },
            "./modules/solclient-transport/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SMFClient = __webpack_require__("./modules/solclient-transport/lib/smf-client.js").SMFClient;
                const TransportCapabilities = __webpack_require__("./modules/solclient-transport/lib/transport-capabilities.js").TransportCapabilities;
                const TransportError = __webpack_require__("./modules/solclient-transport/lib/transport-error.js").TransportError;
                const TransportFactory = __webpack_require__("./modules/solclient-transport/lib/transport-factory.js").TransportFactory;
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js").TransportProtocol;
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js").TransportReturnCode;
                const TransportSessionEventCode = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js").TransportSessionEventCode;
                const TransportSessionStates = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js").TransportSessionStates;
                module.exports.SMFClient = SMFClient;
                module.exports.TransportCapabilities = TransportCapabilities;
                module.exports.TransportError = TransportError;
                module.exports.TransportFactory = TransportFactory;
                module.exports.TransportProtocol = TransportProtocol;
                module.exports.TransportReturnCode = TransportReturnCode;
                module.exports.TransportSessionEventCode = TransportSessionEventCode;
                module.exports.TransportSessionStates = TransportSessionStates;
            },
            "./modules/solclient-transport/lib/base-smf-client.js": module => {
                class BaseSMFClient {
                    constructor(rxSmfCB, rxMessageErrorCB, session) {
                        this.reset();
                        this._rxSmfCB = rxSmfCB;
                        this._rxMessageErrorCB = rxMessageErrorCB;
                        this._session = session;
                    }
                    reset() {
                        this._correlationCounter = 0;
                    }
                    nextCorrelationTag() {
                        if (++this._correlationCounter >= BaseSMFClient.SMF_MAX_CORRELATION) this._correlationCounter = 1;
                        return this._correlationCounter ? this._correlationCounter : 0;
                    }
                }
                BaseSMFClient.SMF_MAX_CORRELATION = 16777215;
                module.exports.BaseSMFClient = BaseSMFClient;
            },
            "./modules/solclient-transport/lib/buffer-queue.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const BufferImpl = __webpack_require__("./node_modules/buffer/index.js").Buffer;
                function concatFrom(list, from, length) {
                    const buffer = BufferImpl.allocUnsafe(length);
                    let pos = 0;
                    let i;
                    const buf0 = list[0];
                    pos += buf0.copy(buffer, 0, from, buf0.length);
                    for (i = 1; i < list.length && pos < length; i++) {
                        const buf = list[i];
                        pos += buf.copy(buffer, pos, 0, buf.length);
                    }
                    return buffer;
                }
                function readUInt32BEFrag(bufList, listOffsetParam, byteIndexParam) {
                    let listOffset = listOffsetParam;
                    let byteIndex = byteIndexParam;
                    const bytes = [];
                    let i = 0;
                    for (i = 0; i < 4; i++) {
                        while (bufList[listOffset].length <= byteIndex) {
                            byteIndex -= bufList[listOffset].length;
                            listOffset++;
                            if (listOffset >= bufList.length) return null;
                        }
                        bytes[i] = bufList[listOffset].readUInt8(byteIndex);
                        byteIndex++;
                    }
                    return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
                }
                class BufferQueue {
                    constructor(maxSize) {
                        let _queue = [];
                        const _maxSize = maxSize;
                        let _size = 0;
                        let _offset = 0;
                        this.peekView = function(size) {
                            const result = [];
                            if (_queue.length < 1 || size > _size) return null;
                            if (_queue[0].length >= size + _offset) {
                                result[0] = _queue[0];
                                result[1] = _offset;
                            } else {
                                result[0] = concatFrom(_queue, _offset, size);
                                result[1] = 0;
                            }
                            return result;
                        };
                        this.readUInt8 = function(index) {
                            if (index >= _size) return null;
                            const oIndex = index + _offset;
                            if (oIndex < _queue[0].length) return _queue[0].readUInt8(oIndex);
                            let pos = _queue[0].length;
                            let i = 1;
                            while (pos + _queue[i].length <= oIndex) {
                                pos += _queue[i].length;
                                i++;
                            }
                            return _queue[i].readUInt8(oIndex - pos);
                        };
                        this.readUInt32BE = function(index) {
                            if (index + 3 >= _size) return null;
                            const oIndex = index + _offset;
                            if (oIndex + 3 < _queue[0].length) return _queue[0].readUInt32BE(oIndex);
                            if (oIndex < _queue[0].length) return readUInt32BEFrag(_queue, 0, oIndex);
                            let pos = _queue[0].length;
                            let i = 1;
                            while (pos + _queue[i].length <= oIndex) {
                                pos += _queue[i].length;
                                i++;
                            }
                            if (oIndex - pos + 3 < _queue[i].length) return _queue[i].readUInt32BE(oIndex - pos);
                            return readUInt32BEFrag(_queue, i, oIndex - pos);
                        };
                        this.put = function(dataIn) {
                            const buffer = BufferQueue.adaptData(dataIn);
                            const size = buffer.length;
                            if (0 === size) return true;
                            if (_size + size >= _maxSize) return false;
                            _queue.push(buffer);
                            _size += size;
                            return true;
                        };
                        this.advance = function(size) {
                            if (size < 1) return;
                            if (size >= _size) {
                                this.reset();
                                return;
                            }
                            let done = 0;
                            while (done < size) if (_queue[0].length - _offset <= size - done) {
                                const chunk = _queue[0].length - _offset;
                                _queue.shift();
                                done += chunk;
                                _size -= chunk;
                                _offset = 0;
                            } else {
                                _offset += size - done;
                                _size -= size - done;
                                break;
                            }
                        };
                        this.reset = function() {
                            _queue = [];
                            _size = 0;
                            _offset = 0;
                        };
                        this.remaining = function() {
                            return _size;
                        };
                        this.isEmpty = function() {
                            return 0 === _size;
                        };
                    }
                    static adaptData(data) {
                        if (data instanceof BufferImpl) return data;
                        return BufferImpl.from(data);
                    }
                }
                module.exports.BufferQueue = BufferQueue;
                module.exports.concatFrom = concatFrom;
            },
            "./modules/solclient-transport/lib/buffer-smf-client.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const BaseSMFClient = __webpack_require__("./modules/solclient-transport/lib/base-smf-client.js").BaseSMFClient;
                const BufferQueue = __webpack_require__("./modules/solclient-transport/lib/buffer-queue.js").BufferQueue;
                const {
                    Convert,
                    Hex
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const BufferImpl = __webpack_require__("./node_modules/buffer/index.js").Buffer;
                const stringToUint8Array = Convert.stringToUint8Array;
                const formatHexString = Hex.formatHexString;
                const SMF_LOST_FRAMING_THRESHOLD = 8e7;
                const LOG_ERROR = new LogFormatter("[buffer-smf-client]").LOG_ERROR;
                function logPeekBuffer(buffer) {
                    const bufPair = buffer.peekView(Math.min(buffer.remaining(), 64));
                    LOG_ERROR(`First 64 bytes (or fewer) of incoming buffer: 
` + DebugLib.Debug.formatDumpBytes(bufPair[0].toString("latin1", bufPair[1]), true, 0));
                }
                class BufferSMFClient extends BaseSMFClient {
                    constructor(rxSmfCB, rxMessageErrorCB, session) {
                        super(rxSmfCB, rxMessageErrorCB, session);
                        this._incomingBuffer = new BufferQueue(SMF_LOST_FRAMING_THRESHOLD);
                    }
                    reset() {
                        super.reset();
                        if (this._incomingBuffer) this._incomingBuffer.reset();
                    }
                    rxDataString(data) {
                        this._rxDataCB(BufferImpl.from(stringToUint8Array(data)));
                    }
                    rxDataArrayBuffer(data) {
                        this._rxDataCB(BufferImpl.from(data));
                    }
                    rxDataBuffer(data) {
                        this._rxDataCB(data);
                    }
                    _rxDataCB(data) {
                        if (this._session) this._session.resetKeepAliveCounter();
                        const buffer = this._incomingBuffer;
                        const putSuccess = buffer.put(data);
                        let remaining = buffer.remaining();
                        if (!putSuccess) {
                            logPeekBuffer(buffer);
                            this._rxMessageErrorCB(`Buffer overflow (length: ${remaining})`);
                            this._incomingBuffer.reset();
                        }
                        while (remaining > 12) {
                            const version = 7 & buffer.readUInt8(0);
                            if (3 !== version) {
                                LOG_ERROR(`Invalid smf version in smf header, version=` + version);
                                LOG_ERROR("BufferSMFClient._rxDataCB(): couldn't decode message due to invalid smf header");
                                logPeekBuffer(buffer);
                                this._incomingBuffer.reset();
                                this._rxMessageErrorCB("Error parsing incoming SMF - invalid SMF header detected");
                                return;
                            }
                            const messageLen = buffer.readUInt32BE(8);
                            if (messageLen > buffer.remaining()) break;
                            const msgBuffer = buffer.peekView(messageLen);
                            const incomingMsg = SMFLib.Codec.Decode.decodeCompoundMessage(msgBuffer[0], msgBuffer[1]);
                            if (incomingMsg && incomingMsg.smfHeader) {
                                buffer.advance(incomingMsg.smfHeader.messageLength);
                                this._rxSmfCB(incomingMsg);
                            } else {
                                const sessionId = this._session ? this._session._sessionId : null;
                                const sessionIdHex = sessionId ? formatHexString(sessionId) : "N/A";
                                LOG_ERROR(`BufferSMFClient._rxDataCB(): couldn't decode message (sessionId=${sessionIdHex})`);
                                logPeekBuffer(buffer);
                                this._incomingBuffer.reset();
                                this._rxMessageErrorCB("Error parsing incoming SMF");
                                return;
                            }
                            remaining = buffer.remaining();
                        }
                        if (remaining); else this._incomingBuffer.reset();
                    }
                }
                module.exports.BufferSMFClient = BufferSMFClient;
            },
            "./modules/solclient-transport/lib/smf-client.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const BaseSMFClient = __webpack_require__("./modules/solclient-transport/lib/base-smf-client.js").BaseSMFClient;
                const SMFClient = (() => {
                    return __webpack_require__("./modules/solclient-transport/lib/buffer-smf-client.js").BufferSMFClient;
                })();
                SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG = BaseSMFClient.SMF_MAX_CORRELATION;
                module.exports.SMFClient = SMFClient;
            },
            "./modules/solclient-transport/lib/transport-base.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js").TransportReturnCode;
                class TransportBase {
                    constructor(url, eventCB, client, transportProps, interceptor = null) {
                        this._url = url;
                        this._ssl = TransportBase.useSsl(url);
                        this._client = client;
                        this._eventCB = eventCB;
                        this._props = transportProps;
                        this.setInterceptor(interceptor);
                    }
                    connect() {
                        return TransportReturnCode.OK;
                    }
                    destroy(immediate, msg, subcode) {
                        return TransportReturnCode.OK;
                    }
                    forceFailure(msg) {
                        return TransportReturnCode.OK;
                    }
                    flush(callback) {
                        callback();
                        return TransportReturnCode.OK;
                    }
                    send(message, forceAllowEnqueue = 0) {
                        return TransportReturnCode.OK;
                    }
                    getTransportProtocol() {
                        return this._props.transportProtocol;
                    }
                    getInfoStr() {
                        return null;
                    }
                    getClientStats() {
                        return null;
                    }
                    beginDowngrade(msg, subcode) {
                        return false;
                    }
                    setInterceptor(interceptor) {
                        if (this._interceptor) if (this._interceptor.removed) this._interceptor.removed(this);
                        this._interceptor = interceptor;
                        if (interceptor) if (interceptor.installed) interceptor.installed(this);
                    }
                    toString() {
                        return `` + this.getTransportProtocol() + (this._ssl ? " (SSL)" : "");
                    }
                    static useSsl(url) {
                        const urlParts = (url || "").split("://");
                        if (0 === urlParts.length || TransportBase.validSchemes.indexOf(urlParts[0]) < 0) throw new OperationError(`Invalid url "${url}": Only [${TransportBase.validSchemes.join(", ")}] URL schemes are supported`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        const useSSL = "https" === urlParts[0] || "wss" === urlParts[0] || "tcps" === urlParts[0];
                        return useSSL;
                    }
                }
                TransportBase.validSchemes = [ "http", "https", "ws", "wss", "tcp", "tcps" ];
                module.exports.TransportBase = TransportBase;
            },
            "./modules/solclient-transport/lib/transport-capabilities.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const WebTransportCapabilities = __webpack_require__("./modules/solclient-transport/lib/web/api.js").WebTransportCapabilities;
                const TransportCapabilities = {
                    web: WebTransportCapabilities
                };
                module.exports.TransportCapabilities = TransportCapabilities;
            },
            "./modules/solclient-transport/lib/transport-client-stats.js": module => {
                class TransportClientStats {
                    constructor() {
                        this.bytesWritten = 0;
                        this.msgWritten = 0;
                    }
                }
                module.exports.TransportClientStats = TransportClientStats;
            },
            "./modules/solclient-transport/lib/transport-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const SolaceError = __webpack_require__("./modules/solclient-error/api.js").SolaceError;
                class TransportError extends SolaceError {
                    constructor(message, subcode) {
                        super("TransportError", message);
                        this.subcode = subcode;
                    }
                    toString() {
                        return super.toString() + `, subcode=` + this.subcode;
                    }
                }
                module.exports.TransportError = TransportError;
            },
            "./modules/solclient-transport/lib/transport-factory.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const {
                    TcpRawTransport,
                    CompressedTransport,
                    TlsOnlyTransport,
                    TcpTlsTransport
                } = false ? 0 : {};
                const WebTransport = __webpack_require__("./modules/solclient-transport/lib/web/api.js").WebTransport;
                const TransportFactory = {
                    createTransport(host, eventCB, client, props, getId) {
                        const url = host;
                        Object.assign(props, {
                            connectTimeoutInMsecs: 1e5
                        });
                        if (TcpRawTransport && url.trim().startsWith("tcp")) {
                            if (!url.trim().startsWith("tcps")) {
                                if (0 === props.compressionLevel) return new TcpRawTransport(url, eventCB, client, props);
                                const compressingLayer = new CompressedTransport(eventCB, client, props);
                                const plaintextTransport = new TcpRawTransport(url, compressingLayer.eventCB.bind(compressingLayer), compressingLayer, props);
                                compressingLayer.setClientStats(plaintextTransport.getClientStats());
                                plaintextTransport.setClientStats(null);
                                compressingLayer.setUnderlyingTransport(plaintextTransport);
                                return compressingLayer;
                            }
                            if ("PLAIN_TEXT" !== props.sslConnectionDowngradeTo) return new TcpTlsTransport(url, eventCB, client, props);
                            const tlsLayer = new TlsOnlyTransport(url, eventCB, client, props);
                            const plaintextTransport = new TcpRawTransport(url, tlsLayer.eventCB.bind(tlsLayer), tlsLayer, props);
                            tlsLayer.setClientStats(plaintextTransport.getClientStats());
                            plaintextTransport.setClientStats(null);
                            tlsLayer.setUnderlyingTransport(plaintextTransport);
                            return tlsLayer;
                        }
                        return new WebTransport(url, eventCB, client, props, getId);
                    },
                    startCompression(uncompressedTransport) {
                        const eventCB = uncompressedTransport._eventCB;
                        const client = uncompressedTransport._client;
                        const props = uncompressedTransport._props;
                        const compressingLayer = new CompressedTransport(eventCB, client, props);
                        uncompressedTransport.rehome(compressingLayer.eventCB.bind(compressingLayer), compressingLayer);
                        compressingLayer.setClientStats(uncompressedTransport.getClientStats());
                        uncompressedTransport.setClientStats(null);
                        compressingLayer.setUnderlyingTransport(uncompressedTransport);
                        compressingLayer.connect();
                        return compressingLayer;
                    },
                    severTls(encryptedTransport, compress, callback) {
                        if (!compress) encryptedTransport.tlsShutdown(callback); else {
                            const precallback = plaintextTransport => callback(this.startCompression(plaintextTransport));
                            encryptedTransport.tlsShutdown(precallback);
                        }
                    }
                };
                module.exports.TransportFactory = TransportFactory;
            },
            "./modules/solclient-transport/lib/transport-protocol-handler.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const WebTransportsLib = __webpack_require__("./modules/solclient-transport/lib/web/api.js");
                const Lazy = __webpack_require__("./modules/solclient-eskit/api.js").Lazy;
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const TransportBase = __webpack_require__("./modules/solclient-transport/lib/transport-base.js").TransportBase;
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js").TransportProtocol;
                const lazyValue = Lazy.lazyValue;
                const lutTransportProtocols = lazyValue(() => {
                    const protocols = {
                        [TransportProtocol.HTTP_BASE64]: WebTransportsLib.StateBase64,
                        [TransportProtocol.HTTP_BINARY]: WebTransportsLib.StateBinary,
                        [TransportProtocol.HTTP_BINARY_STREAMING]: WebTransportsLib.StateStreamingAndBinary,
                        [TransportProtocol.WS_BINARY]: WebTransportsLib.StateWebSocketBinary
                    };
                    return protocols;
                });
                class TransportProtocolHandler {
                    constructor(url, webTransportProtocolList) {
                        const useSSL = TransportBase.useSsl(url);
                        let transport = null;
                        let downgradeTransport = null;
                        webTransportProtocolList.slice().reverse().forEach(el => {
                            const TransportConstructor = lutTransportProtocols.value[el];
                            transport = new TransportConstructor(useSSL, this.switchState.bind(this), downgradeTransport);
                            downgradeTransport = transport;
                        });
                        this._transport = transport;
                        this._transport.onEnter();
                    }
                    getTransportProtocol() {
                        return this._transport.getTransportProtocol();
                    }
                    completeDowngrade(err) {
                        return this._transport.completeDowngrade(err);
                    }
                    canCompleteDowngrade() {
                        return null !== this._transport.getNextState();
                    }
                    toString() {
                        return this._transport.toString();
                    }
                    switchState(newState, reason) {
                        this._transport;
                        this._transport = newState;
                        newState.onEnter();
                    }
                }
                module.exports.TransportProtocolHandler = TransportProtocolHandler;
            },
            "./modules/solclient-transport/lib/transport-protocols.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const TransportProtocol = {
                    HTTP_BASE64: "HTTP_BASE64",
                    HTTP_BINARY: "HTTP_BINARY",
                    HTTP_BINARY_STREAMING: "HTTP_BINARY_STREAMING",
                    WS_BINARY: "WS_BINARY"
                };
                module.exports.TransportProtocol = Enum.new(TransportProtocol);
            },
            "./modules/solclient-transport/lib/transport-return-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const TransportReturnCode = {
                    OK: 0,
                    FAIL: 1,
                    NO_SPACE: 2,
                    DATA_DECODE_ERROR: 3,
                    INVALID_STATE_FOR_OPERATION: 4,
                    CONNECTION_ERROR: 5
                };
                module.exports.TransportReturnCode = Enum.new(TransportReturnCode);
                module.exports.TransportReturnCode._setCanonical({
                    OK: TransportReturnCode.OK,
                    FAIL: TransportReturnCode.FAIL,
                    NO_SPACE: TransportReturnCode.NO_SPACE,
                    DATA_DECODE_ERROR: TransportReturnCode.DATA_DECODE_ERROR,
                    INVALID_STATE_FOR_OPERATION: TransportReturnCode.INVALID_STATE_FOR_OPERATION,
                    CONNECTION_ERROR: TransportReturnCode.CONNECTION_ERROR
                });
            },
            "./modules/solclient-transport/lib/transport-session-event-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const TransportSessionEventCode = {
                    UP_NOTICE: 1,
                    DESTROYED_NOTICE: 2,
                    CAN_ACCEPT_DATA: 4,
                    DATA_DECODE_ERROR: 5,
                    PARSE_FAILURE: 6,
                    CONNECT_TIMEOUT: 7,
                    SEND_ERROR: 8,
                    DOWNGRADE_FAILED: 10,
                    DOWNGRADE_SUCCEEDED: 11
                };
                module.exports.TransportSessionEventCode = Enum.new(TransportSessionEventCode);
            },
            "./modules/solclient-transport/lib/transport-session-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/api.js").ErrorSubcode;
                const Hex = __webpack_require__("./modules/solclient-convert/api.js").Hex;
                const TransportSessionEventCode = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js").TransportSessionEventCode;
                const formatHexString = Hex.formatHexString;
                class TransportSessionEvent {
                    constructor(tsEventCode, infoStr, responseCode, subcode, sessionId) {
                        this._transportEventCode = tsEventCode;
                        this._infoStr = infoStr;
                        this._responseCode = responseCode;
                        this._errorSubcode = subcode;
                        this._sid = sessionId;
                    }
                    getTransportEventCode() {
                        return this._transportEventCode;
                    }
                    get transportEventCode() {
                        return this._transportEventCode;
                    }
                    getInfoStr() {
                        return this.infoStr;
                    }
                    get infoStr() {
                        return this._infoStr;
                    }
                    getResponseCode() {
                        return this.responseCode;
                    }
                    get responseCode() {
                        return this._responseCode;
                    }
                    getSubcode() {
                        return this.errorSubcode;
                    }
                    get errorSubcode() {
                        return this._errorSubcode;
                    }
                    getSessionId() {
                        return this.sessionId;
                    }
                    get sessionId() {
                        return this._sid;
                    }
                    ["inspect"]() {
                        return {
                            transportEventCode: TransportSessionEventCode.describe(this.transportEventCode),
                            infoStr: this.infoStr,
                            responseCode: this.responseCode,
                            errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                            sid: this.sid && formatHexString(this.sid) || "N/A"
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.TransportSessionEvent = TransportSessionEvent;
            },
            "./modules/solclient-transport/lib/transport-session-states.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const TransportSessionState = {
                    DOWN: 0,
                    WAITING_FOR_CREATE: 1,
                    SESSION_UP: 2,
                    WAITING_FOR_DESTROY: 4,
                    CONNECTION_FAILED: 5
                };
                module.exports.TransportSessionState = Enum.new(TransportSessionState);
            },
            "./modules/solclient-transport/lib/tsh-state.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LOG_INFO,
                    LOG_WARN
                } = __webpack_require__("./modules/solclient-log/api.js");
                const Process = __webpack_require__("./modules/solclient-util/api.js").Process;
                class TSHState {
                    constructor(useSsl, tpProtocol, exitCallback, nextState) {
                        this._ssl = !!useSsl;
                        this._transportProtocol = tpProtocol;
                        this._exitCallback = exitCallback;
                        this._nextState = nextState;
                        this._unsupportedRuntimeMessage = this._transportProtocol + ` not supported by this runtime: ` + Process.userAgent;
                    }
                    getNextState() {
                        return this._nextState;
                    }
                    setNextState(nextState) {
                        this._nextState = nextState;
                    }
                    getTransportProtocol() {
                        return this._transportProtocol;
                    }
                    getUseSsl() {
                        return this._ssl;
                    }
                    validateLegal() {
                        return true;
                    }
                    onEnter() {
                        if (!this.validateLegal()) if (this._nextState && this._exitCallback) this._exitCallback(this._nextState, this._unsupportedRuntimeMessage); else LOG_WARN(this._unsupportedRuntimeMessage + `, no next state.`);
                    }
                    completeDowngrade(err) {
                        if (this._nextState && this._exitCallback) {
                            LOG_INFO(`Connect failed (${err}), try next state.`);
                            this._exitCallback(this._nextState, "Connect failed");
                            return true;
                        }
                        LOG_WARN(`Connect failed (${err}), no next state.`);
                        return false;
                    }
                    toString() {
                        return this._transportProtocol + (this._ssl ? " (SSL)" : "");
                    }
                }
                module.exports.TSHState = TSHState;
            },
            "./modules/solclient-transport/lib/web/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const HTTPLib = __webpack_require__("./modules/solclient-transport/lib/web/http/api.js");
                const StateBase64 = __webpack_require__("./modules/solclient-transport/lib/web/state-base64.js").StateBase64;
                const StateBinary = __webpack_require__("./modules/solclient-transport/lib/web/state-binary.js").StateBinary;
                const StateStreamingAndBinary = __webpack_require__("./modules/solclient-transport/lib/web/state-streaming-and-binary.js").StateStreamingAndBinary;
                const StateWebSocketBinary = __webpack_require__("./modules/solclient-transport/lib/web/state-websocket-binary.js").StateWebSocketBinary;
                const WebTransport = __webpack_require__("./modules/solclient-transport/lib/web/web-transport.js").WebTransport;
                const WebTransportCapabilities = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-capabilities.js").WebTransportCapabilities;
                const {
                    HTTPConnection,
                    HTTPTransportSession
                } = HTTPLib;
                module.exports.HTTPConnection = HTTPConnection;
                module.exports.HTTPTransportSession = HTTPTransportSession;
                module.exports.StateBase64 = StateBase64;
                module.exports.StateBinary = StateBinary;
                module.exports.StateStreamingAndBinary = StateStreamingAndBinary;
                module.exports.StateWebSocketBinary = StateWebSocketBinary;
                module.exports.WebTransport = WebTransport;
                module.exports.WebTransportCapabilities = WebTransportCapabilities;
            },
            "./modules/solclient-transport/lib/web/http/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const HTTPConnection = __webpack_require__("./modules/solclient-transport/lib/web/http/http-connection.js").HTTPConnection;
                const HTTPTransportSession = __webpack_require__("./modules/solclient-transport/lib/web/http/http-transport-session.js").HTTPTransportSession;
                if (true) {
                    module.exports.HTTPConnection = HTTPConnection;
                    module.exports.HTTPTransportSession = HTTPTransportSession;
                }
            },
            "./modules/solclient-transport/lib/web/http/http-connection.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
                const {
                    Convert,
                    Base64
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const {
                    LOG_INFO,
                    LOG_WARN,
                    LOG_ERROR
                } = __webpack_require__("./modules/solclient-log/api.js");
                const {
                    sendXhrBinary,
                    sendXhrText
                } = __webpack_require__("./modules/solclient-transport/lib/web/http/send-xhr.js");
                const {
                    StringBuffer,
                    TimingBucket
                } = __webpack_require__("./modules/solclient-util/api.js");
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js").TransportReturnCode;
                const XHRFactory = __webpack_require__("./modules/solclient-transport/lib/web/http/xhr-factory.js").XHRFactory;
                const arrayBufferToString = Convert.arrayBufferToString;
                const SOL_CONNECTION_DEBUG = false;
                function prependOrigin(url) {
                    if (!url.match(/^(http|ws)(s?):/i) && window.location && window.location.origin) return window.location.origin + ("/" !== url.charAt(0) ? "/" : "") + url;
                    return url;
                }
                function getTs() {
                    return new Date().getTime();
                }
                class Stats {
                    constructor() {
                        this.WaitedToken = new TimingBucket("WaitedToken", 100);
                        this.HadToken = new TimingBucket("HadToken", 100);
                        this.ReturnedToken = new TimingBucket("ReturnedToken", 100);
                    }
                    toString() {
                        let s = "";
                        [ this.WaitedToken, this.HadToken, this.ReturnedToken ].forEach(b => {
                            if (b && b.bucketCount() > 0) s += b.name + ` >> ${b}
`;
                        });
                        return s;
                    }
                }
                class HTTPConnection {
                    constructor(url, base64Enc, streamProgressEvents, rxDataCb, connectionErrorCb, contentType, connectionClose) {
                        this.Options = {
                            url: prependOrigin(url),
                            contentType: contentType,
                            base64Enc: base64Enc,
                            streamProgressEvents: streamProgressEvents,
                            connectionClose: connectionClose
                        };
                        this._streamProgressBytes = 0;
                        this._xhr = null;
                        this._rxDataCb = rxDataCb;
                        this._connErrorCb = connectionErrorCb;
                        this._reqActive = false;
                        this._REQCOUNTER = 0;
                        this._REQBASE = Math.floor(1e3 * Math.random());
                        this._xhr = XHRFactory.create();
                        this._handleAbortedReq = !HTTPConnection.browserSupportsXhrBinary();
                        this.stats = new Stats();
                    }
                    recStat(s) {
                        if (!SOL_CONNECTION_DEBUG) return;
                        const stats = this.stats;
                        if ("GotToken" === s) {
                            stats.LastGotToken = getTs();
                            if (stats.LastSendMsg) {
                                const waitedTok = stats.LastGotToken - stats.LastSendMsg;
                                stats.WaitedToken.log(waitedTok);
                                if (waitedTok > 100) LOG_WARN(`Abnormally long waitToken, last request: ${this._REQBASE}_` + this._REQCOUNTER);
                            }
                        }
                        if ("SendMsg" === s) {
                            stats.LastSendMsg = getTs();
                            const hadToken = stats.LastSendMsg - stats.LastGotToken;
                            stats.HadToken.log(hadToken);
                        }
                        if ("GotData" === s) stats.LastGotData = getTs();
                        if ("ReturnToken" === s) {
                            stats.LastReturnToken = getTs();
                            if (stats.LastGotData) {
                                const returnedToken = stats.LastReturnToken - stats.LastGotData;
                                stats.ReturnedToken.log(returnedToken);
                            }
                        }
                    }
                    send(data, attempt = 0, maxRetry = 1) {
                        if (attempt > 0) {
                            this._xhr.abort();
                            this._xhr = XHRFactory.create();
                        }
                        this._xhr.open("POST", this.Options.url, true);
                        this._streamProgressBytes = 0;
                        this._xhr.onreadystatechange = () => this.xhrStateChange(data, attempt, maxRetry);
                        this._reqActive = true;
                        if (SOL_CONNECTION_DEBUG) {
                            this._REQCOUNTER++;
                            this._xhr.setRequestHeader("sol-request-track", this._REQBASE + `_` + this._REQCOUNTER);
                        }
                        if (this.Options.base64Enc) sendXhrText(this._xhr, data, this.Options.contentType, this.Options.connectionClose); else sendXhrBinary(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
                        this.recStat("SendMsg");
                    }
                    xhrStateChange(sentdata, attempt, maxRetry) {
                        const readyState = this._xhr.readyState;
                        const RS_LOADING = this._xhr.LOADING;
                        const RS_DONE = this._xhr.DONE;
                        if (!(this.Options.streamProgressEvents && readyState === RS_LOADING || readyState === RS_DONE)) return;
                        if (!this._reqActive) return;
                        let status = null;
                        if (this._handleAbortedReq) try {
                            status = this._xhr.status;
                        } catch (e) {
                            LOG_INFO(`Error trying to access status in XHR due to request aborted: ` + e.message);
                            return;
                        } else status = this._xhr.status;
                        if (200 === status || 304 === status) {
                            let data = null;
                            if (this._xhr.responseType && "arraybuffer" === this._xhr.responseType) data = arrayBufferToString(this._xhr.response); else data = this._xhr.responseText;
                            data = data.substring(this._streamProgressBytes, data.length);
                            this._streamProgressBytes += data.length;
                            if (0 === data.length && readyState === RS_LOADING) return;
                            if (this.Options.base64Enc) try {
                                data = Base64.decode(data);
                            } catch (e) {
                                LOG_ERROR(`Data decode error on: ` + data);
                                LOG_ERROR(`Data decode error is: ` + e.message);
                                this._rxDataCb(TransportReturnCode.DATA_DECODE_ERROR, data);
                                return;
                            } else {
                                const decodedData = [];
                                const dataLength = data.length;
                                for (let i = 0; i < dataLength; i++) decodedData.push(String.fromCharCode(255 & data.charCodeAt(i)));
                                data = decodedData.join("");
                            }
                            if (readyState === RS_DONE) this._reqActive = false;
                            this._rxDataCb(TransportReturnCode.OK, data);
                            if (readyState === RS_DONE && data.length > 0) this._rxDataCb(TransportReturnCode.OK, "");
                            return;
                        }
                        const statusText = this._xhr.statusText;
                        let responseText = "";
                        if (this._xhr.responseType && "arraybuffer" === this._xhr.responseType) responseText = arrayBufferToString(this._xhr.response); else responseText = this._xhr.responseText || "";
                        const responseTextLen = responseText.length;
                        this.Options.url;
                        const sentdataLen = sentdata ? sentdata.length : 0;
                        const formatDumpBytes = DebugLib.Debug.formatDumpBytes;
                        const responseTextDump = formatDumpBytes(responseText.substr(0, Math.min(responseTextLen, 64)), true, 0);
                        formatDumpBytes((sentdata || "").substr(0, Math.min(sentdataLen, 256)), true, 0);
                        if (false);
                        const nextMaxRetry = maxRetry;
                        if (this._reqActive && 400 !== status && 0 === responseText.length && (0 === attempt || attempt < nextMaxRetry)) {
                            LOG_INFO(`XHR failed while request active, will retry send, retry=` + (attempt + 1));
                            this.send(sentdata, attempt + 1, nextMaxRetry);
                        } else {
                            this._reqActive = false;
                            this._connErrorCb(status, new StringBuffer(`HTTP request failed(status=${status} statusText=${statusText}, `, `responseText length=${responseTextLen}, responseText[0..64]=
`, responseTextDump, `XHR errorCode=${this._xhr._error ? this._xhr._error.code : ""})`).toString());
                        }
                    }
                    isUsingBase64() {
                        return this.Options.base64Enc;
                    }
                    abort() {
                        this._reqActive = false;
                        if (this._xhr && this._xhr.abort) this._xhr.abort();
                    }
                    static browserSupportsXhrBinary() {
                        return sendXhrBinary !== sendXhrText;
                    }
                    static browserSupportsStreamingResponse() {
                        const xhr = XHRFactory.create();
                        const check = xhr && null === xhr.onprogress;
                        LOG_INFO(`http browserStreamingCheck - if XMLHTTPRequest supported and XMLHTTPRequest support onprogress: ` + check);
                        return check;
                    }
                }
                module.exports.HTTPConnection = HTTPConnection;
            },
            "./modules/solclient-transport/lib/web/http/http-transport-session.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
                const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const {
                    Convert,
                    Hex
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const HTTPConnection = __webpack_require__("./modules/solclient-transport/lib/web/http/http-connection.js").HTTPConnection;
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const SMFClient = __webpack_require__("./modules/solclient-transport/lib/smf-client.js").SMFClient;
                const TransportError = __webpack_require__("./modules/solclient-transport/lib/transport-error.js").TransportError;
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js").TransportProtocol;
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js").TransportReturnCode;
                const TransportSessionEvent = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js").TransportSessionEvent;
                const TransportSessionEventCode = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js").TransportSessionEventCode;
                const TransportSessionState = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js").TransportSessionState;
                const WebTransportSessionBase = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-session-base.js").WebTransportSessionBase;
                const {
                    int32ToStr,
                    strToByteArray,
                    strToHexArray
                } = Convert;
                const formatHexString = Hex.formatHexString;
                const {
                    LOG_ERROR,
                    LOG_INFO
                } = new LogFormatter("[http-transport-session]");
                const PacketReadState = {
                    READING_HEADER: 0,
                    STREAMING: 1
                };
                const BufferImpl = __webpack_require__("./node_modules/buffer/index.js").Buffer;
                const MSIE_TRANSPORT_PADDING = 257;
                function adaptURL(url) {
                    const v = url.match(/(ws|http)(s?:\/\/.+)/);
                    return `http` + v[2];
                }
                class HTTPTransportSession extends WebTransportSessionBase {
                    constructor(baseUrl, eventCB, client, props) {
                        super(baseUrl, eventCB, client, props);
                        this._haveToken = true;
                        this._confMaxWebPayload = props.maxWebPayload;
                        this._maxPayloadBytes = 0;
                        this._destroyTimer = null;
                        this._destroyTimeout = props.connectTimeoutInMsecs;
                        this._createUrl = adaptURL(baseUrl);
                        this._routerUrl = this._createUrl;
                        this._rxChannelClient = null;
                        this._httpSendConn = null;
                        this._httpReceiveConn = null;
                        this._smfDataTokenTSHeader = null;
                        this._routerTag = "";
                        this._sid = null;
                        if (null === props.transportProtocol || void 0 === props.transportProtocol) throw new OperationError("transportProtocol is not set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        this._transportProtocol = props.transportProtocol;
                        this._useBinaryTransport = false;
                        this._useStreamingTransport = false;
                        this._streamingTransportPadding = 0;
                        this._useBinaryTransport = props.transportProtocol !== TransportProtocol.HTTP_BASE64;
                        this._useStreamingTransport = props.transportProtocol === TransportProtocol.HTTP_BINARY_STREAMING;
                        this._incomingBuffer = "";
                        this._packetReadState = PacketReadState.READING_HEADER;
                        const agent = navigator.userAgent || "";
                        if (agent.match(/trident/i) || agent.match(/msie/i)) this._streamingTransportPadding = MSIE_TRANSPORT_PADDING;
                        if (null === props.transportContentType || void 0 === props.transportContentType) throw new OperationError("transportContentType is not set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        this._contentType = props.transportContentType;
                    }
                    connectTimerExpiry() {
                        LOG_INFO("HTTP transport connect timeout");
                        this.destroyCleanup("HTTP transport connect timeout", ErrorSubcode.TIMEOUT);
                    }
                    get sessionIdHex() {
                        return this._sid ? formatHexString(this._sid) : "";
                    }
                    updateMaxWebPayload() {
                        const trLessEncapSMF = this._confMaxWebPayload - 22;
                        this._maxPayloadBytes = this._useBinaryTransport ? trLessEncapSMF : Math.floor(.75 * trLessEncapSMF);
                    }
                    connect() {
                        if (this._state !== TransportSessionState.DOWN) return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                        return this.connectInternal();
                    }
                    connectInternal() {
                        this._connError = null;
                        try {
                            this._createConn = new HTTPConnection(this._createUrl, !this._useBinaryTransport, false, (rc, data) => this.handleCreateResponse(rc, data), (rc, data) => this.handleCreateConnFailure(rc, data), this._contentType);
                        } catch (e) {
                            LOG_INFO(`Failed to create connection to router: ` + e.message);
                            this._connError = e;
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        if (Check.nothing(this._createConn)) {
                            LOG_INFO("Failed to create connection to router");
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        const createMsg = SMFLib.Codec.Transport.genTsCreateHeader();
                        if (this._state === TransportSessionState.WAITING_FOR_CREATE); else {
                            this.createConnectTimeout();
                            this._state = TransportSessionState.WAITING_FOR_CREATE;
                        }
                        try {
                            this._createConn.send(createMsg);
                        } catch (connError) {
                            LOG_INFO(`Error connecting: ` + connError.message);
                            connError.stack;
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this.cancelConnectTimeout();
                            if (connError instanceof TransportError) this._connError = connError; else this._connError = new TransportError(`Could not create HTTP transport session: ` + connError.message, connError.subcode || ErrorSubcode.CONNECTION_ERROR);
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        return TransportReturnCode.OK;
                    }
                    destroy(msg, subcode) {
                        this._state;
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY || this._state === TransportSessionState.DOWN) return TransportReturnCode.OK;
                        if (this._state === TransportSessionState.CONNECTION_FAILED || this._state === TransportSessionState.WAITING_FOR_CREATE) {
                            LOG_INFO("The connection is in unreliable state, close transport");
                            this.destroyCleanup(msg, subcode, true);
                            return TransportReturnCode.OK;
                        }
                        LOG_INFO("Destroy transport session immediately");
                        this._state = TransportSessionState.WAITING_FOR_DESTROY;
                        if (null !== this._httpSendConn) {
                            LOG_INFO("Destroy transport session: abort sendConn");
                            this._httpSendConn.abort();
                        }
                        if (null !== this._httpReceiveConn) {
                            LOG_INFO("Destroy transport session: abort receiveConn");
                            this._httpReceiveConn.abort();
                        }
                        this._destroyTimer = setTimeout(() => {
                            this.destroyTimerExpiry();
                        }, this._destroyTimeout);
                        this._httpSendConn = new HTTPConnection(this._routerUrl, !this._useBinaryTransport, false, (rc, data) => this.handleRxDataToken(rc, data), (rc, data) => this.handleSendFailure(rc, data), this._contentType, true);
                        const destroyMsg = SMFLib.Codec.Transport.genTsDestroyHeader(this._sid);
                        strToHexArray(destroyMsg);
                        this._httpSendConn.send(destroyMsg);
                        return TransportReturnCode.OK;
                    }
                    send(dataIn, forceAllowEnqueue = false) {
                        let data = dataIn;
                        if (this._state !== TransportSessionState.SESSION_UP) return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                        if (this._queuedData.length > 0 || !this._haveToken) return this.enqueueData(data, forceAllowEnqueue);
                        let remainder = null;
                        if (data.length > this._maxPayloadBytes) {
                            remainder = data.substr(this._maxPayloadBytes);
                            data = data.substr(0, this._maxPayloadBytes);
                            if (!this.allowEnqueue(remainder.length)) return this.enqueueFailNoSpace();
                        }
                        this._haveToken = false;
                        const transportPacketLen = this._smfDataTSHeaderParts[0].length + 4 + this._smfDataTSHeaderParts[1].length + data.length;
                        this._httpSendConn.send(this._smfDataTSHeaderParts[0] + int32ToStr(transportPacketLen) + this._smfDataTSHeaderParts[1] + data);
                        this._clientstats.bytesWritten += data.length;
                        if (remainder) return this.enqueueData(remainder, null);
                        this._clientstats.msgWritten++;
                        return TransportReturnCode.OK;
                    }
                    enqueueData(data, forceAllowEnqueue = false) {
                        const dataLen = data.length;
                        if (forceAllowEnqueue || this.allowEnqueue(dataLen)) {
                            this._queuedDataSize += dataLen;
                            this._queuedData.push(data);
                        } else return this.enqueueFailNoSpace();
                        return TransportReturnCode.OK;
                    }
                    initPreformattedHeaders(sid) {
                        this._smfDataTSHeaderParts = SMFLib.Codec.Transport.genTsDataMsgHeaderParts(sid);
                        if (this._useStreamingTransport) this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataStreamTokenMsg(sid, this._streamingTransportPadding); else this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataTokenMsg(sid);
                    }
                    flush(callback) {
                        if (this._queuedDataSize) this._flushCallback = callback; else callback();
                    }
                    sendQueuedData() {
                        if (0 === this._queuedDataSize) return;
                        this._haveToken = false;
                        const data = this.getQueuedDataToSend();
                        const transportPacketLen = this._smfDataTSHeaderParts[0].length + 4 + this._smfDataTSHeaderParts[1].length + data.length;
                        this._httpSendConn.send(this._smfDataTSHeaderParts[0] + int32ToStr(transportPacketLen) + this._smfDataTSHeaderParts[1] + data);
                        this._clientstats.bytesWritten += data.length;
                        if (this._canSendNeeded) {
                            this._canSendNeeded = false;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sid));
                        }
                        if (this._flushCallback) {
                            const cb = this._flushCallback;
                            this._flushCallback = null;
                            cb();
                        }
                    }
                    handleCreateResponse(tsRc, response) {
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY || this._state === TransportSessionState.DOWN) return;
                        this.updateMaxWebPayload();
                        if (tsRc !== TransportReturnCode.OK) {
                            LOG_INFO(`Received create response with return code ` + TransportReturnCode.describe(tsRc));
                            if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) this.destroyCleanup("Received data decode error on create session response", ErrorSubcode.DATA_DECODE_ERROR); else this.destroyCleanup("Failed to handle create session response", ErrorSubcode.CONNECTION_ERROR);
                            return;
                        }
                        if (0 === response.length) return;
                        const parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(BufferImpl.from(response, "latin1"), 0);
                        if (!parsedResponse) {
                            LOG_ERROR("Could not parse create response as SMF. Destroying transport");
                            this.destroyCleanup("Failed to parse create response message", ErrorSubcode.CONNECTION_ERROR);
                            return;
                        }
                        const smfresponse = parsedResponse.getResponse();
                        if (200 !== smfresponse.responseCode) {
                            this.destroyCleanup(`Transport create request failed (${smfresponse.responseCode}, ${smfresponse.responseString})`, ErrorSubcode.CONNECTION_ERROR);
                            return;
                        }
                        this.cancelConnectTimeout();
                        this._createConn.abort();
                        this._createConn = null;
                        this._state = TransportSessionState.SESSION_UP;
                        this._sid = parsedResponse.sessionId;
                        this._routerTag = parsedResponse.routerTag;
                        this._routerUrl = this._createUrl.replace(/\?.*/, "");
                        if ("" !== this._routerTag) this._routerUrl = this._routerUrl + this._routerTag;
                        this.initPreformattedHeaders(this._sid);
                        const useBase64 = !this._useBinaryTransport;
                        const useStreaming = this._useStreamingTransport;
                        this._httpSendConn = new HTTPConnection(this._routerUrl, useBase64, false, (rc, data) => this.handleRxDataToken(rc, data), (rc, data) => this.handleSendFailure(rc, data), this._contentType);
                        if (this._useStreamingTransport) this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming, (rc, data) => this.handleRxStreaming(rc, data), (rc, data) => this.handleSendFailure(rc, data), this._contentType, true); else {
                            this._rxChannelClient = new SMFClient(rxData => this.handleSmfMessage(rxData), rxError => this.handleSmfParseError(rxError), null);
                            this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming, (rc, data) => this.handleRxData(rc, data), (rc, data) => this.handleSendFailure(rc, data), this._contentType);
                        }
                        this._httpReceiveConn.send(this._smfDataTokenTSHeader);
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, smfresponse.responseString, smfresponse.responseCode, 0, parsedResponse.sessionId));
                    }
                    handleDestroyResponse(response) {
                        this.cancelDestroyTimeout();
                        const innerResponse = response.getResponse();
                        const responseString = innerResponse ? innerResponse.responseString : "";
                        this.destroyCleanup(`${responseString} handled Destroy Response addressed to session ${formatHexString(response.sessionId)}, on session ` + formatHexString(this._sid), 0);
                    }
                    handleSmfMessage(tsmsg) {
                        const smfHeader = tsmsg.smfHeader;
                        if (smfHeader.smf_protocol !== SMFLib.SMFProtocol.TSESSION) {
                            this.handleSmfParseError(`Unexpected Message Prototcol (${smfHeader.smf_protocol}) on ReceiveData connection`);
                            return;
                        }
                        const data = tsmsg.payload;
                        const TotalPayloadToRead = tsmsg.payloadLength;
                        switch (tsmsg.messageType) {
                          case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
                            this.handleDestroyResponse(tsmsg);
                            return;

                          case SMFLib.SMFTransportSessionMessageType.DATA:
                            if (tsmsg.sessionId !== this._sid) {
                                const smfErrResponse = tsmsg.getResponse();
                                const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                                const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                                strToByteArray(this._sid), strToByteArray(tsmsg.sessionId), 
                                responseErrStr;
                                this._state = TransportSessionState.CONNECTION_FAILED;
                                this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in data message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(tsmsg.sessionId)}, ` + responseErrStr, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                                return;
                            }
                            if (TotalPayloadToRead > 0) this._client.rxDataBuffer(data);
                            break;

                          default:
                            this.handleSmfParseError(`Unexpected message type (${tsmsg.messageType}) on ReceiveData connection`);
                        }
                    }
                    handleSmfParseError() {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR, "Received data decode error", null, ErrorSubcode.DATA_DECODE_ERROR, this._sid));
                    }
                    handleRxData(tsRc, data) {
                        if (null === this._httpReceiveConn || null === this._rxChannelClient) {
                            if (this._state === TransportSessionState.DOWN) LOG_INFO("Transport session is down, ignore data from receive connection"); else LOG_ERROR(`Transport session is not in working state, state: ` + this._state);
                            return;
                        }
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0);
                            return;
                        }
                        this._httpReceiveConn.recStat("GotData");
                        if (tsRc !== TransportReturnCode.OK) {
                            this.handleRxError(tsRc, data);
                            return;
                        }
                        if (0 === data.length) this._httpReceiveConn.send(this._smfDataTokenTSHeader); else this._rxChannelClient.rxDataString(data);
                    }
                    handleRxStreaming(tsRc, data) {
                        if (null === this._httpReceiveConn) {
                            if (this._state === TransportSessionState.DOWN); else LOG_ERROR(`Transport session is not in working state, state: ` + this._state);
                            return;
                        }
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0);
                            return;
                        }
                        this._httpReceiveConn.recStat("GotData");
                        if (tsRc !== TransportReturnCode.OK) {
                            this.handleRxError(tsRc, data);
                            return;
                        }
                        if (0 === data.length) {
                            this._packetReadState = PacketReadState.READING_HEADER;
                            this._httpReceiveConn.send(this._smfDataTokenTSHeader);
                            return;
                        }
                        if (this._packetReadState === PacketReadState.STREAMING) {
                            this._client.rxDataString(data);
                            return;
                        }
                        this._incomingBuffer += data;
                        const smfheader = SMFLib.Codec.ParseSMF.parseSMFAt(BufferImpl.from(this._incomingBuffer, "latin1"), 0, true);
                        if (smfheader) {
                            const tsmsg = SMFLib.Codec.Transport.parseTsSmfHdrAt(BufferImpl.from(this._incomingBuffer, "latin1"), smfheader.headerLength, smfheader);
                            if (!tsmsg) return;
                            switch (tsmsg.messageType) {
                              case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
                                this.handleDestroyResponse(tsmsg);
                                return;

                              case SMFLib.SMFTransportSessionMessageType.DATA:
                                if (tsmsg.sessionId !== this._sid) {
                                    const smfErrResponse = tsmsg.getResponse();
                                    const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                                    const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                                    strToByteArray(this._sid), strToByteArray(tsmsg.sessionId), 
                                    responseErrStr;
                                    strToByteArray(data.substr(0, 64));
                                    this._state = TransportSessionState.CONNECTION_FAILED;
                                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in data message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(tsmsg.sessionId)}, ` + responseErrStr, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                                    return;
                                }
                                this._packetReadState = PacketReadState.STREAMING;
                                if (this._incomingBuffer.length > smfheader.headerLength + tsmsg.tsHeaderLength) this._client.rxDataString(this._incomingBuffer.substr(smfheader.headerLength + tsmsg.tsHeaderLength));
                                this._incomingBuffer = "";
                                return;

                              default:
                                throw new TransportError(`Unexpected message type (${tsmsg.messageType}) on ReceiveData connection`, 0);
                            }
                        } else if (SMFLib.Codec.ParseSMF.isSMFHeaderAvailable(BufferImpl.from(this._incomingBuffer, "latin1"), 0) && !SMFLib.Codec.ParseSMF.isSMFHeaderValid(BufferImpl.from(this._incomingBuffer, "latin1"), 0)) {
                            LOG_ERROR(`Couldn't decode message due to invalid smf header, dump first 64 bytes (or fewer) of buffer content:
` + DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substring(0, 64), true, 0));
                            const errorInfo = "Error parsing incoming message - invalid SMF header detected";
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, errorInfo, null, ErrorSubcode.PROTOCOL_ERROR, null));
                        }
                    }
                    handleRxDataToken(tsRc, data) {
                        if (tsRc !== TransportReturnCode.OK) {
                            this.handleRxError(tsRc, data);
                            return;
                        }
                        if (0 === data.length) return;
                        const parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(BufferImpl.from(data, "latin1"), 0);
                        if (!parsedResponse) {
                            if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
                                this._state = TransportSessionState.CONNECTION_FAILED;
                                this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, "Failed to parse received data message", null, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                            } else this.destroyCleanup("Failed to parse received data message", ErrorSubcode.PROTOCOL_ERROR);
                            return;
                        }
                        if (parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DESTROY_RESP) {
                            this.handleDestroyResponse(parsedResponse);
                            return;
                        }
                        if (parsedResponse.sessionId !== this._sid) {
                            const smfErrResponse = parsedResponse.getResponse();
                            const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                            const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                            strToByteArray(this._sid), strToByteArray(parsedResponse.sessionId), 
                            responseErrStr;
                            strToByteArray(data.substr(0, 64));
                            if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
                                this._state = TransportSessionState.CONNECTION_FAILED;
                                this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in response message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(parsedResponse.sessionId)}, ` + responseErrStr, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                            } else this.destroyCleanup("Session ID mismatch in response message", ErrorSubcode.PROTOCOL_ERROR);
                            return;
                        }
                        if (parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DATA_TOKEN || parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DATA_STREAM_TOKEN) {
                            this._haveToken = true;
                            this._httpSendConn.recStat("GotToken");
                            this.sendQueuedData();
                        } else throw new TransportError(`Unexpected message type (${parsedResponse.messageType}) on SendData connection`, 0);
                    }
                    handleRxError(tsRc) {
                        LOG_INFO(`handleRxError, transport return code ` + TransportReturnCode.name(tsRc));
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR, "Received data decode error", null, ErrorSubcode.DATA_DECODE_ERROR, this._sid)); else this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, "Connection error", ErrorSubcode.CONNECTION_ERROR, this._sid));
                    }
                    handleSendFailure(status, msg) {
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            LOG_INFO(`Connection destroy failure (${msg}) while in state ` + this._state);
                            this.destroyCleanup(`Connection destroy failure: ` + msg, ErrorSubcode.CONNECTION_ERROR);
                        } else {
                            LOG_INFO(`Connection failure (${msg}) while in state ` + this._state);
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error: ` + msg, status, ErrorSubcode.CONNECTION_ERROR, this._sid));
                        }
                    }
                    handleCreateConnFailure(status, msg) {
                        if (this._state === TransportSessionState.DOWN) return;
                        LOG_INFO(`Connection create failure (${msg}) while in state ` + this._state);
                        this.destroyCleanup(`Connection create failure: ` + msg, ErrorSubcode.CONNECTION_ERROR);
                    }
                    destroyTimerExpiry() {
                        this.destroyCleanup("Destroy request timeout", ErrorSubcode.CONNECTION_ERROR);
                    }
                    cancelDestroyTimeout() {
                        if (this._destroyTimer) {
                            clearTimeout(this._destroyTimer);
                            this._destroyTimer = null;
                        }
                    }
                    destroyCleanup(infoStr, subcode, asyncSendEvent) {
                        if (this._createConn) this._createConn.abort();
                        if (this._httpSendConn) this._httpSendConn.abort();
                        if (this._httpReceiveConn) this._httpReceiveConn.abort();
                        this._createUrl = null;
                        this._routerUrl = null;
                        this._createConn = null;
                        this._httpSendConn = null;
                        this._httpReceiveConn = null;
                        this._smfDataTokenTSHeader = null;
                        this._rxChannelClient = null;
                        this._routerTag = "";
                        this._queuedData = [];
                        this._queuedDataSize = 0;
                        this._canSendNeeded = false;
                        this.cancelDestroyTimeout();
                        this.cancelConnectTimeout();
                        this._state = TransportSessionState.DOWN;
                        const finalize = () => {
                            if (this._eventCB) this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, infoStr || "Session is destroyed", null, subcode || 0, this._sid));
                            this._client = null;
                            this._eventCB = null;
                        };
                        if (asyncSendEvent) setTimeout(finalize, 0); else finalize();
                    }
                    getInfoStr() {
                        const str = `HTTPTransportSession; sid=${formatHexString(this._sid)}; routerTag=` + this._routerTag;
                        return str;
                    }
                }
                module.exports.HTTPTransportSession = HTTPTransportSession;
            },
            "./modules/solclient-transport/lib/web/http/send-xhr.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Base64,
                    Convert
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const XHRFactory = __webpack_require__("./modules/solclient-transport/lib/web/http/xhr-factory.js").XHRFactory;
                const base64Encode = Base64.encode;
                const stringToUint8Array = Convert.stringToUint8Array;
                function sendXhrBinaryMSIE10(xhr, data, contentType) {
                    xhr.responseType = "arraybuffer";
                    xhr.overrideMimeType(contentType + `; charset=x-user-defined`);
                    xhr.setRequestHeader("Content-Type", contentType + `; charset=x-user-defined`);
                    xhr.send(stringToUint8Array(data));
                }
                function sendXhrBinaryXHR2(xhr, data, contentType) {
                    xhr.overrideMimeType(contentType + `; charset=x-user-defined`);
                    xhr.setRequestHeader("Content-Type", contentType + `; charset=x-user-defined`);
                    xhr.send(stringToUint8Array(data).buffer);
                }
                function sendXhrText(xhr, data, contentType, connClose) {
                    xhr.setRequestHeader("Content-Type", contentType + `; charset=x-user-defined`);
                    xhr.send(null === data || void 0 === data ? data : base64Encode(data), connClose);
                }
                const sendXhrBinary = (() => {
                    if ("undefined" !== typeof window && window.Uint8Array && window.Blob) {
                        const xhr = XHRFactory.create(true);
                        if (xhr.responseType) return sendXhrBinaryMSIE10;
                        return sendXhrBinaryXHR2;
                    }
                    return sendXhrText;
                })();
                module.exports.sendXhrBinary = sendXhrBinary;
                module.exports.sendXhrText = sendXhrText;
            },
            "./modules/solclient-transport/lib/web/http/xhr-factory.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/api.js").ErrorSubcode;
                const TransportError = __webpack_require__("./modules/solclient-transport/lib/transport-error.js").TransportError;
                const XHRFactory = {
                    create(allowFail = false) {
                        const xhr = "undefined" !== typeof XMLHttpRequest ? new XMLHttpRequest() : null;
                        if (!allowFail && !xhr) throw new TransportError("Failed to create an XMLHTTPRequest", ErrorSubcode.CREATE_XHR_FAILED);
                        return xhr;
                    }
                };
                module.exports.XHRFactory = XHRFactory;
            },
            "./modules/solclient-transport/lib/web/state-base64.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js").TransportProtocol;
                const TSHState = __webpack_require__("./modules/solclient-transport/lib/tsh-state.js").TSHState;
                class StateBase64 extends TSHState {
                    constructor(useSsl, exitCb, nextState) {
                        super(useSsl, TransportProtocol.HTTP_BASE64, exitCb, nextState);
                    }
                }
                module.exports.StateBase64 = StateBase64;
            },
            "./modules/solclient-transport/lib/web/state-binary.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js").TransportProtocol;
                const TSHState = __webpack_require__("./modules/solclient-transport/lib/tsh-state.js").TSHState;
                const WebTransportCapabilities = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-capabilities.js").WebTransportCapabilities;
                class StateBinary extends TSHState {
                    constructor(useSsl, exitCb, nextState) {
                        super(useSsl, TransportProtocol.HTTP_BINARY, exitCb, nextState);
                    }
                    validateLegal() {
                        return WebTransportCapabilities.xhrBinary();
                    }
                }
                module.exports.StateBinary = StateBinary;
            },
            "./modules/solclient-transport/lib/web/state-streaming-and-binary.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js").TransportProtocol;
                const TSHState = __webpack_require__("./modules/solclient-transport/lib/tsh-state.js").TSHState;
                const WebTransportCapabilities = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-capabilities.js").WebTransportCapabilities;
                class StateStreamingAndBinary extends TSHState {
                    constructor(useSsl, exitCb, nextState) {
                        super(useSsl, TransportProtocol.HTTP_BINARY_STREAMING, exitCb, nextState);
                    }
                    validateLegal() {
                        return WebTransportCapabilities.streaming() && WebTransportCapabilities.xhrBinary();
                    }
                }
                module.exports.StateStreamingAndBinary = StateStreamingAndBinary;
            },
            "./modules/solclient-transport/lib/web/state-websocket-binary.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js").TransportProtocol;
                const TSHState = __webpack_require__("./modules/solclient-transport/lib/tsh-state.js").TSHState;
                const WebTransportCapabilities = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-capabilities.js").WebTransportCapabilities;
                class StateWebSocketBinary extends TSHState {
                    constructor(useSsl, exitCb, nextState) {
                        super(useSsl, TransportProtocol.WS_BINARY, exitCb, nextState);
                    }
                    validateLegal() {
                        return WebTransportCapabilities.webSocket();
                    }
                }
                module.exports.StateWebSocketBinary = StateWebSocketBinary;
            },
            "./modules/solclient-transport/lib/web/web-transport-capabilities.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const HTTPLib = __webpack_require__("./modules/solclient-transport/lib/web/http/api.js");
                const WebSocketTransportSession = __webpack_require__("./modules/solclient-transport/lib/web/websocket-transport-session.js").WebSocketTransportSession;
                const HTTPConnection = HTTPLib.HTTPConnection;
                const WebTransportCapabilities = {
                    webSocket() {
                        return WebSocketTransportSession.browserSupportsBinaryWebSockets();
                    },
                    xhrBinary() {
                        return HTTPConnection.browserSupportsXhrBinary();
                    },
                    streaming() {
                        return HTTPConnection.browserSupportsStreamingResponse();
                    }
                };
                module.exports.WebTransportCapabilities = WebTransportCapabilities;
            },
            "./modules/solclient-transport/lib/web/web-transport-events.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const WebTransportEvent = {
                    CONNECT: "Connect",
                    DESTROY: "Destroy",
                    DOWNGRADE: "Downgrade",
                    DESTROYED_NOTICE: "DestroyedNotice",
                    CONNECT_TIMEOUT: "ConnectTimeout",
                    UP_NOTICE: "UpNotice",
                    SEND_ERROR: "SendError"
                };
                module.exports.WebTransportEvent = Enum.new(WebTransportEvent);
            },
            "./modules/solclient-transport/lib/web/web-transport-fsm.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/api.js").ErrorSubcode;
                const {
                    FsmEvent,
                    State,
                    StateMachine
                } = __webpack_require__("./modules/solclient-fsm/api.js");
                const LogFormatter = __webpack_require__("./modules/solclient-log/api.js").LogFormatter;
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js").TransportReturnCode;
                const TransportSessionEvent = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js").TransportSessionEvent;
                const TransportSessionEventCode = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js").TransportSessionEventCode;
                const WebTransportEvent = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-events.js").WebTransportEvent;
                const WebTransportState = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-states.js").WebTransportState;
                const LOG_INFO = new LogFormatter().LOG_INFO;
                class WebTransportFSM extends StateMachine {
                    constructor(transportIn, getId) {
                        super({
                            name: "WebTransportFSM"
                        });
                        const transport = transportIn;
                        const fsm = this;
                        const logger = new LogFormatter();
                        logger.formatter = function(...args) {
                            return [ `[web-transport-fsm=${getId()}]`, ...args ];
                        };
                        this.log = logger.wrap(this.log, this);
                        this.transport = transport;
                        this.initial(function() {
                            return this.transitionTo(this.WebTransportDown, context => {
                                context.getStateMachine().getName();
                            });
                        });
                        this.unhandledEventReaction(function(wEvent) {
                            wEvent.getName(), this.getCurrentState().getName();
                            return this;
                        });
                        this.WebTransportDown = new State({
                            name: WebTransportState.DOWN,
                            parentContext: this
                        }).reaction(WebTransportEvent.CONNECT, function() {
                            return this.transitionTo(fsm.WebTransportConnecting);
                        }).reaction(WebTransportEvent.DESTROY, function(wEvent) {
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        });
                        this.WebTransportConnecting = new State({
                            name: WebTransportState.CONNECTING,
                            parentContext: this
                        }).entry(() => {
                            try {
                                const rc = transport.connectInternal();
                                if (rc !== TransportReturnCode.OK) {
                                    const connError = transport.getConnError();
                                    const wEvent = new FsmEvent({
                                        name: WebTransportEvent.DESTROY
                                    });
                                    wEvent._destroyMsg = connError ? connError.message : "Error occurred while establishing transport";
                                    wEvent._subcode = connError ? connError.subcode : null;
                                    wEvent._eventReason = connError;
                                    return this.processEvent(wEvent);
                                }
                            } catch (e) {
                                LOG_INFO(`transport.connectInternal threw: ` + e.message);
                                const wEvent = new FsmEvent({
                                    name: WebTransportEvent.DESTROY
                                });
                                wEvent._destroyMsg = e.message;
                                wEvent._subcode = e.subcode ? e.subcode : ErrorSubcode.CONNECTION_ERROR;
                                wEvent._eventReason = e;
                                return this.processEvent(wEvent);
                            }
                            return;
                        }).reaction(WebTransportEvent.SEND_ERROR, wEvent => {
                            transport.notifyEvent(wEvent._transportEvent);
                            return fsm.attemptDowngrade(wEvent._transportEvent);
                        }).reaction(WebTransportEvent.CONNECT_TIMEOUT, e => fsm.attemptDowngrade(e._transportEvent)).reaction(WebTransportEvent.DESTROYED_NOTICE, wEvent => {
                            transport.notifyEvent(wEvent._transportEvent);
                            return this.transitionTo(fsm.WebTransportDown);
                        }).reaction(WebTransportEvent.UP_NOTICE, function(wEvent) {
                            transport.notifyEvent(wEvent._transportEvent);
                            return this.transitionTo(fsm.WebTransportUp);
                        }).reaction(WebTransportEvent.DESTROY, function(wEvent) {
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        });
                        this.WebTransportDowngrading = new State({
                            name: WebTransportState.DOWNGRADING,
                            parentContext: this
                        }).reaction(WebTransportEvent.DESTROYED_NOTICE, function(wEvent) {
                            LOG_INFO("Web transport: request downgrade");
                            if (!transport.completeDowngrade()) {
                                LOG_INFO("Web transport: connection error, no downgrade");
                                transport.notifyEvent(wEvent._transportEvent);
                                fsm.notifyDowngradeFailed();
                                return this.transitionTo(fsm.WebTransportDown);
                            }
                            return this.transitionTo(fsm.WebTransportConnecting);
                        }).reaction(WebTransportEvent.DESTROY, function(wEvent) {
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        });
                        this.WebTransportUp = new State({
                            name: WebTransportState.UP,
                            parentContext: this
                        }).reaction(WebTransportEvent.DOWNGRADE, wEvent => fsm.attemptDowngrade(new TransportSessionEvent(wEvent._downgradeMsg, wEvent._subcode))).reaction(WebTransportEvent.DESTROYED_NOTICE, function(wEvent) {
                            transport.notifyEvent(wEvent._transportEvent);
                            return this.transitionTo(fsm.WebTransportDown);
                        }).reaction(WebTransportEvent.DESTROY, function(wEvent) {
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        }).reaction(WebTransportEvent.SEND_ERROR, function(wEvent) {
                            transport.notifyEvent(wEvent._transportEvent);
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        });
                        this.WebTransportDestroying = new State({
                            name: WebTransportState.DESTROYING,
                            parentContext: this
                        }).reaction(WebTransportEvent.DESTROYED_NOTICE, function(wEvent) {
                            transport.notifyEvent(wEvent._transportEvent);
                            return this.transitionTo(fsm.WebTransportDown);
                        });
                    }
                    attemptDowngrade(tsEvent) {
                        const {
                            infoStr,
                            errorSubcode
                        } = tsEvent;
                        if (!this.transport.beginDowngrade(infoStr, errorSubcode)) {
                            this.transport.destroyInternal(infoStr, errorSubcode);
                            this.transport.notifyEvent(tsEvent);
                            return this.transitionTo(this.WebTransportDestroying);
                        }
                        return this.transitionTo(this.WebTransportDowngrading);
                    }
                    notifyDowngradeFailed() {
                        this.transport.notifyEvent(new TransportSessionEvent(TransportSessionEventCode.DOWNGRADE_FAILED, "Downgrade failed"));
                    }
                }
                module.exports.WebTransportFSM = WebTransportFSM;
            },
            "./modules/solclient-transport/lib/web/web-transport-session-base.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {} = __webpack_require__("./modules/solclient-log/api.js");
                const TransportBase = __webpack_require__("./modules/solclient-transport/lib/transport-base.js").TransportBase;
                const TransportClientStats = __webpack_require__("./modules/solclient-transport/lib/transport-client-stats.js").TransportClientStats;
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js").TransportReturnCode;
                const TransportSessionState = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js").TransportSessionState;
                const MAX_BUFFERED_AMOUNT_QUERY_INTERVAL_MS = 4e3;
                class WebTransportSessionBase extends TransportBase {
                    constructor(url, eventCB, client, props) {
                        super(url, eventCB, client, props);
                        this._connectTimeout = props.transportDowngradeTimeoutInMsecs;
                        this._connectTimer = null;
                        this._clientstats = new TransportClientStats();
                        this._sendBufferMaxSize = props.sendBufferMaxSize;
                        this._maxPayloadBytes = props.maxWebPayload;
                        this._queuedData = [];
                        this._queuedDataSize = 0;
                        this._canSendNeeded = false;
                        this._state = TransportSessionState.DOWN;
                        this._connError = null;
                    }
                    getClientStats() {
                        return this._clientstats;
                    }
                    createConnectTimeout() {
                        if (this._connectTimeout > 0) this._connectTimer = setTimeout(() => {
                            this.connectTimerExpiry();
                        }, this._connectTimeout);
                    }
                    cancelConnectTimeout() {
                        if (this._connectTimer) {
                            clearTimeout(this._connectTimer);
                            this._connectTimer = null;
                        }
                    }
                    connectTimerExpiry() {
                        return;
                    }
                    allowEnqueue(datalen) {
                        return 0 === this._queuedDataSize || datalen + this._queuedDataSize <= this._sendBufferMaxSize;
                    }
                    enqueueFailNoSpace() {
                        this._canSendNeeded = true;
                        return TransportReturnCode.NO_SPACE;
                    }
                    flush(callback) {
                        callback();
                    }
                    getQueuedDataToSend() {
                        let data = "";
                        let bytesAllowed = this._maxPayloadBytes;
                        bytesAllowed, this.getBufferedAmount && this.getBufferedAmount();
                        if (this.getBufferedAmount) {
                            bytesAllowed = this._maxPayloadBytes - this.getBufferedAmount();
                            if (bytesAllowed <= 0) {
                                bytesAllowed, this._maxPayloadBytes, this.getBufferedAmount();
                                if (true && this._bufferedAmountQueryIntervalInMsecs * this._bufferedAmountQueryIntervalDelayMultiplier <= MAX_BUFFERED_AMOUNT_QUERY_INTERVAL_MS) this._bufferedAmountQueryIntervalDelayMultiplier *= 2;
                                return data;
                            }
                            if (true) this._bufferedAmountQueryIntervalDelayMultiplier = 1;
                        }
                        if (this._queuedDataSize > bytesAllowed) {
                            let payloadSize = bytesAllowed;
                            while (payloadSize && this._queuedDataSize) {
                                const elem = this._queuedData[0];
                                const elemLength = elem.length;
                                if (elemLength > payloadSize) {
                                    data += elem.substr(0, payloadSize);
                                    this._queuedData[0] = elem.substr(payloadSize);
                                    this._queuedDataSize -= payloadSize;
                                    payloadSize = 0;
                                } else {
                                    data += this._queuedData.shift();
                                    payloadSize -= elemLength;
                                    this._queuedDataSize -= elemLength;
                                    this._clientstats.msgWritten++;
                                }
                            }
                        } else {
                            data = this._queuedData.join("");
                            this._clientstats.msgWritten += this._queuedData.length;
                            this._queuedData = [];
                            this._queuedDataSize = 0;
                        }
                        data.length;
                        return data;
                    }
                }
                module.exports.WebTransportSessionBase = WebTransportSessionBase;
            },
            "./modules/solclient-transport/lib/web/web-transport-states.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Enum = __webpack_require__("./modules/solclient-eskit/api.js").Enum;
                const WebTransportState = {
                    DOWN: "WebTransportDown",
                    CONNECTING: "WebTransportConnecting",
                    DOWNGRADING: "WebTransportDowngrading",
                    DESTROYING: "WebTransportDestroying",
                    UP: "WebTransportUp"
                };
                module.exports.WebTransportState = Enum.new(WebTransportState);
            },
            "./modules/solclient-transport/lib/web/web-transport.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const HTTPTransportSession = __webpack_require__("./modules/solclient-transport/lib/web/http/api.js").HTTPTransportSession;
                const {
                    LOG_INFO,
                    LOG_ERROR
                } = __webpack_require__("./modules/solclient-log/api.js");
                const FsmEvent = __webpack_require__("./modules/solclient-fsm/api.js").FsmEvent;
                const TransportBase = __webpack_require__("./modules/solclient-transport/lib/transport-base.js").TransportBase;
                const TransportProtocol = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js").TransportProtocol;
                const TransportProtocolHandler = __webpack_require__("./modules/solclient-transport/lib/transport-protocol-handler.js").TransportProtocolHandler;
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js").TransportReturnCode;
                const TransportSessionEventCode = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js").TransportSessionEventCode;
                const WebSocketTransportSession = __webpack_require__("./modules/solclient-transport/lib/web/websocket-transport-session.js").WebSocketTransportSession;
                const WebTransportEvent = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-events.js").WebTransportEvent;
                const WebTransportFSM = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-fsm.js").WebTransportFSM;
                class WebTransport extends TransportBase {
                    constructor(url, eventCB, client, props, getId) {
                        super(url, eventCB, client, props);
                        props.webTransportProtocolList;
                        this._transportHandler = new TransportProtocolHandler(url, props.webTransportProtocolList);
                        this._webTransportFsm = new WebTransportFSM(this, getId);
                        this._webTransportFsm.start();
                    }
                    notifyEvent(event) {
                        this._eventCB(event);
                    }
                    handleDestroyed() {
                        this._transportSession = null;
                    }
                    handleTransportEvent(transportEvent) {
                        LOG_INFO(`Web transport receive transport event: ` + transportEvent);
                        let wEvent;
                        switch (transportEvent.getTransportEventCode()) {
                          case TransportSessionEventCode.UP_NOTICE:
                            wEvent = new FsmEvent({
                                name: WebTransportEvent.UP_NOTICE
                            });
                            wEvent._transportEvent = transportEvent;
                            this._webTransportFsm.processEvent(wEvent);
                            break;

                          case TransportSessionEventCode.DESTROYED_NOTICE:
                            this.handleDestroyed();
                            wEvent = new FsmEvent({
                                name: WebTransportEvent.DESTROYED_NOTICE
                            });
                            wEvent._transportEvent = transportEvent;
                            this._webTransportFsm.processEvent(wEvent);
                            break;

                          case TransportSessionEventCode.SEND_ERROR:
                            wEvent = new FsmEvent({
                                name: WebTransportEvent.SEND_ERROR
                            });
                            wEvent._transportEvent = transportEvent;
                            this._webTransportFsm.processEvent(wEvent);
                            break;

                          case TransportSessionEventCode.CONNECT_TIMEOUT:
                            wEvent = new FsmEvent({
                                name: WebTransportEvent.CONNECT_TIMEOUT
                            });
                            wEvent._transportEvent = transportEvent;
                            this._webTransportFsm.processEvent(wEvent);
                            break;

                          case TransportSessionEventCode.DOWNGRADE_FAILED:
                            this._lastDowngradeSucceeded = false;
                            break;

                          case TransportSessionEventCode.DOWNGRADE_SUCCEEDED:
                            this._lastDowngradeSucceeded = true;
                            break;

                          default:
                            this._eventCB(transportEvent);
                        }
                    }
                    connect() {
                        const wEvent = new FsmEvent({
                            name: WebTransportEvent.CONNECT
                        });
                        this._webTransportFsm.processEvent(wEvent);
                        return TransportReturnCode.OK;
                    }
                    connectInternal() {
                        this._transportSession = null;
                        const tpProtocol = this._transportHandler.getTransportProtocol();
                        this._props.transportProtocol = tpProtocol;
                        switch (tpProtocol) {
                          case TransportProtocol.HTTP_BASE64:
                          case TransportProtocol.HTTP_BINARY:
                          case TransportProtocol.HTTP_BINARY_STREAMING:
                            this._transportSession = new HTTPTransportSession(this._url, evt => this.handleTransportEvent(evt), this._client, this._props);
                            break;

                          case TransportProtocol.WS_BINARY:
                            this._transportSession = new WebSocketTransportSession(this._url, evt => this.handleTransportEvent(evt), this._client, this._props);
                            break;

                          default:
                            LOG_ERROR(`Web transport unrecognized TransportProtocol: ` + tpProtocol);
                            throw new OperationError(`No transport session provider for scheme: ` + tpProtocol, ErrorSubcode.CONNECTION_ERROR, tpProtocol);
                        }
                        LOG_INFO(`Connect Transport ` + tpProtocol);
                        return this._transportSession.connect();
                    }
                    destroy(msg, subcode) {
                        const wEvent = new FsmEvent({
                            name: WebTransportEvent.DESTROY
                        });
                        wEvent._destroyMsg = msg;
                        wEvent._subcode = subcode;
                        this._webTransportFsm.processEvent(wEvent);
                        return TransportReturnCode.OK;
                    }
                    forceFailure(msg) {
                        const errorMsg = void 0 !== msg && null !== msg ? msg : "";
                        errorMsg;
                        if (this._transportSession) this._transportSession._socket._sender._socket.destroy(new Error(errorMsg));
                        return TransportReturnCode.OK;
                    }
                    beginDowngrade(msg, subcode) {
                        if (this._transportHandler.canCompleteDowngrade()) {
                            this.destroyInternal(msg, subcode);
                            return true;
                        }
                        return false;
                    }
                    completeDowngrade() {
                        if (!this._transportHandler.canCompleteDowngrade()) return false;
                        return this._transportHandler.completeDowngrade();
                    }
                    destroyInternal(msg, subcode) {
                        if (this._transportSession) this._transportSession.destroy(msg, subcode);
                    }
                    flush(callback) {
                        return this._transportSession.flush(callback);
                    }
                    getConnError() {
                        if (this._transportSession) return this._transportSession._connError;
                        return null;
                    }
                    getInfoStr() {
                        if (this._transportSession) return this._transportSession.getInfoStr();
                        return "Not connected.";
                    }
                    getTransportProtocol() {
                        return this._transportHandler.getTransportProtocol();
                    }
                    getClientStats() {
                        if (this._transportSession) return this._transportSession.getClientStats();
                        return null;
                    }
                    requestDowngrade(msg, subcode) {
                        this._lastDowngradeSucceeded = void 0;
                        const wEvent = new FsmEvent({
                            name: WebTransportEvent.DOWNGRADE
                        });
                        wEvent._downgradeMsg = msg;
                        wEvent._subcode = subcode;
                        this._webTransportFsm.processEvent(wEvent);
                        return this._lastDowngradeSucceeded;
                    }
                    send(message, forceAllowEnqueue) {
                        return this._transportSession.send(message, forceAllowEnqueue);
                    }
                }
                module.exports.WebTransport = WebTransport;
            },
            "./modules/solclient-transport/lib/web/websocket-close-codes.js": module => {
                module.exports.WebSocketCloseCodes = {
                    0: {
                        name: "Unknown code",
                        description: "No status code was returned by the operation"
                    },
                    1e3: {
                        name: "Normal Closure",
                        description: "The connection closed normally"
                    },
                    1001: {
                        name: "Going Away",
                        description: "The endpoint is going away due to a server failure or client navigation"
                    },
                    1002: {
                        name: "Protocol Error",
                        description: "A WebSocket protocol error occurred"
                    },
                    1003: {
                        name: "Unsupported Data",
                        description: "The endpoint cannot handle the specified data type"
                    },
                    1004: {
                        name: "Reserved",
                        description: ""
                    },
                    1005: {
                        name: "No Status Recvd",
                        description: "Expected a status code but none was provided"
                    },
                    1006: {
                        name: "Abnormal Closure",
                        description: "No close frame was received before remote hangup"
                    },
                    1007: {
                        name: "Invalid Frame Payload Data",
                        description: "A message contained data inconsistent with its encoding"
                    },
                    1008: {
                        name: "Policy Violation",
                        description: "A message violated endpoint policy"
                    },
                    1009: {
                        name: "Message Too Big",
                        description: "A data frame was too large"
                    },
                    1010: {
                        name: "Missing Extension",
                        description: "The endpoint did not negotiate an expected extension"
                    },
                    1011: {
                        name: "Internal Error",
                        description: "The server encountered an unexpected condition that prevented it from fulfilling the request"
                    },
                    1012: {
                        name: "Service Restart",
                        description: "The server is restarting"
                    },
                    1013: {
                        name: "Try Again Later",
                        description: "The server is terminating the connection due to a temporary condition"
                    },
                    1014: {
                        name: "Bad Gateway",
                        description: "A gateway or proxy received an invalid response from the upstream server"
                    },
                    1015: {
                        name: "TLS Handshake",
                        description: "The connection was closed due to a failure to perform a TLS handshake"
                    }
                };
            },
            "./modules/solclient-transport/lib/web/websocket-transport-session.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LOG_INFO,
                    LOG_WARN,
                    LOG_ERROR
                } = __webpack_require__("./modules/solclient-log/api.js");
                const ArrayUtils = __webpack_require__("./modules/solclient-util/api.js").ArrayUtils;
                const {
                    Convert,
                    Hex
                } = __webpack_require__("./modules/solclient-convert/api.js");
                const ErrorSubcode = __webpack_require__("./modules/solclient-error/api.js").ErrorSubcode;
                const mixin = __webpack_require__("./modules/solclient-eskit/api.js").mixin;
                const TransportError = __webpack_require__("./modules/solclient-transport/lib/transport-error.js").TransportError;
                const TransportReturnCode = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js").TransportReturnCode;
                const TransportSessionEvent = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js").TransportSessionEvent;
                const TransportSessionEventCode = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js").TransportSessionEventCode;
                const TransportSessionState = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js").TransportSessionState;
                const WebSocketCloseCodes = __webpack_require__("./modules/solclient-transport/lib/web/websocket-close-codes.js").WebSocketCloseCodes;
                const WebTransportSessionBase = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-session-base.js").WebTransportSessionBase;
                __webpack_require__("?77a7");
                __webpack_require__("?37c5");
                const stringToArrayBuffer = Convert.stringToArrayBuffer;
                const formatHexString = Hex.formatHexString;
                const includes = ArrayUtils.includes;
                const globalContext = "undefined" === typeof window ? __webpack_require__.g : window;
                let MyWebSocket = globalContext.WebSocket;
                if (false);
                function adaptURL(url) {
                    const v = url.match(/(ws|http)(s?:\/\/.+)/);
                    return `ws` + v[2];
                }
                class WebSocketTransportSession extends WebTransportSessionBase {
                    constructor(url, eventCB, client, props) {
                        super(url, eventCB, client, props);
                        this._url = adaptURL(url);
                        this._socket = null;
                        this._sessionId = new Date().getTime();
                        if (true) {
                            this._bufferedAmountQueryIntervalInMsecs = props.bufferedAmountQueryIntervalInMsecs;
                            this._bufferedAmountQueryTimer = null;
                            this._bufferedAmountQueryIntervalDelayMultiplier = 1;
                        }
                    }
                    onOpen() {
                        this.cancelConnectTimeout();
                        this._state = TransportSessionState.SESSION_UP;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, "Connected", 0, null, this._sessionId));
                    }
                    onClose(originalSocket, event) {
                        if (originalSocket !== this._socket) return;
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) return;
                        const msgBuf = [];
                        const code = WebSocketCloseCodes[event.code] || WebSocketCloseCodes[0];
                        msgBuf.push(`${event.code} ${code.name} (${code.description})`);
                        if (void 0 !== event.wasClean) msgBuf.push(`clean closure: ` + event.wasClean);
                        if (event.reason) msgBuf.push(`reason: ` + event.reason);
                        const msg = msgBuf.join(", ");
                        msg;
                        event.type, event.wasClean, event.code, event.reason;
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        this.destroy(`Connection closed: ` + msg, ErrorSubcode.COMMUNICATION_ERROR);
                    }
                    onDrain() {
                        this.maybeEmitCanSend();
                        this.maybeEmitFlush();
                    }
                    onBufferedAmountPoll() {
                        if (0 === this.getBufferedAmount()) this.onDrain(); else if (this.scheduleQuery) this.scheduleQuery();
                    }
                    onError(originalSocket, event) {
                        LOG_INFO(`Websocket Transport Session onError for socket ${originalSocket} while socket is ` + this._socket);
                        if (originalSocket !== this._socket) {
                            LOG_INFO("Websocket Transport Session stray onError for previous socket, ignoring.");
                            return;
                        }
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            LOG_INFO("WebSocket transport is being destroyed, ignore error");
                            return;
                        }
                        const msg = event.message ? `: ` + event.message : "";
                        LOG_INFO(`WebSocket transport connection error ${msg} while in state ` + this._state);
                        if (this._state === TransportSessionState.WAITING_FOR_CONNECT) {
                            this.cancelConnectTimeout();
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this.destroy(`Connection failed: ` + msg, ErrorSubcode.CONNECTION_ERROR);
                        } else this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error` + msg, null, ErrorSubcode.CONNECTION_ERROR, null));
                    }
                    onMessage(event) {
                        if (this._client) this._client.rxDataArrayBuffer(event.data);
                    }
                    connectTimerExpiry() {
                        LOG_INFO("WebSocket transport connect timeout");
                        this.state = TransportSessionState.CONNECTION_FAILED;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CONNECT_TIMEOUT, "Connection timed out", null, ErrorSubcode.TIMEOUT));
                    }
                    connect() {
                        if (this._state !== TransportSessionState.DOWN) {
                            LOG_ERROR(`Invalid state for operation: ` + TransportSessionState.nameOf(this._state));
                            return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                        }
                        if (!this._url) {
                            LOG_WARN("Cannot connect to null URL");
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        if (this._socket) this.onError("Socket already connected");
                        LOG_INFO("Establishing WebSocket transport session");
                        try {
                            this.createConnectTimeout();
                            this._state = TransportSessionState.WAITING_FOR_CREATE;
                            if (false);
                            LOG_INFO("Constructing socket");
                            if (true) this._socket = new MyWebSocket(this._url, "smf.solacesystems.com");
                            this._socket.binaryType = "arraybuffer";
                            this._socket.onopen = this.onOpen.bind(this);
                            this._socket.onmessage = this.onMessage.bind(this);
                            this._socket.onclose = this.onClose.bind(this, this._socket);
                            this._socket.onerror = this.onError.bind(this, this._socket);
                        } catch (error) {
                            LOG_INFO(`Error connecting: ` + error.message);
                            error.stack;
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this.cancelConnectTimeout();
                            if (error instanceof TransportError) this._connError = error; else throw new TransportError(`Could not create WebSocket: ` + error.message, error.subcode || ErrorSubcode.CONNECTION_ERROR);
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        LOG_INFO("WebSocket is connecting");
                        return TransportReturnCode.OK;
                    }
                    send(data, force = false) {
                        if (this._state !== TransportSessionState.SESSION_UP) return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                        const dataLen = data.length;
                        const bufferAllow = this._sendBufferMaxSize - this.getBufferedAmount() >= 0;
                        if (!(force || bufferAllow)) {
                            this._canSendNeeded = true;
                            if (this.scheduleQuery) this.scheduleQuery();
                            return TransportReturnCode.NO_SPACE;
                        }
                        const maxPayloadBytes = this._maxPayloadBytes;
                        const ab = stringToArrayBuffer(data);
                        if (dataLen > maxPayloadBytes) for (let i = 0; i < dataLen; i += maxPayloadBytes) this._socket.send(ab.slice(i, i + maxPayloadBytes)); else this._socket.send(ab);
                        this._clientstats.bytesWritten += dataLen;
                        ++this._clientstats.msgWritten;
                        return TransportReturnCode.OK;
                    }
                    getBufferedAmount() {
                        return this._socket ? this._socket["bufferedAmount"] : 0;
                    }
                    flush(callback) {
                        this._flushCallback = callback;
                        this.maybeEmitFlush();
                    }
                    maybeEmitCanSend() {
                        if (this._canSendNeeded && this.getBufferedAmount() < this._sendBufferMaxSize) {
                            this._canSendNeeded = false;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sessionId));
                        }
                    }
                    maybeEmitFlush() {
                        if (!this._flushCallback) return;
                        if (true && this.getBufferedAmount() > 0) {
                            if (!this._bufferedAmountQueryTimer) this.scheduleQuery();
                            return;
                        }
                        const cb = this._flushCallback;
                        this._flushCallback = null;
                        cb();
                    }
                    destroy(message, subcode) {
                        if (this._state !== TransportSessionState.DOWN) {
                            LOG_INFO(`Destroy WebSocket transport: ` + message);
                            this._state = TransportSessionState.WAITING_FOR_DESTROY;
                            if (this._socket) {
                                this._socket.close();
                                this._socket.onopen = null;
                                this._socket.onmessage = null;
                                this._socket.onclose = null;
                                this._socket.onerror = function() {};
                                this._socket = null;
                            }
                            if (this._connectTimer) {
                                clearTimeout(this._connectTimer);
                                this._connectTimer = void 0;
                            }
                            if (true) {
                                this.cancelQuery();
                                this._bufferedAmountQueryIntervalDelayMultiplier = 1;
                            }
                            this._canSendNeeded = false;
                            this._state = TransportSessionState.DOWN;
                            this._client = null;
                        }
                        if (this._eventCB) {
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, message || "Session is destroyed", null, subcode || 0, this._sessionId));
                            this._eventCB = null;
                        }
                        return TransportReturnCode.OK;
                    }
                    getInfoStr() {
                        const str = `WebSocketTransportSession; sid=` + formatHexString(this._sessionId);
                        return str;
                    }
                    static browserSupportsBinaryWebSockets() {
                        const exists = [ "function", "object" ];
                        if (!includes(exists, typeof MyWebSocket) || !includes(exists, typeof ArrayBuffer) || !includes(exists, typeof Uint8Array)) {
                            LOG_INFO("websocket browserSupportBinaryCheck: false - some required classes not supported");
                            return false;
                        }
                        if ("binaryType" in MyWebSocket.prototype) {
                            LOG_INFO("websocket browserSupportBinaryCheck: true - WebSocket supports binaryType");
                            return true;
                        }
                        LOG_INFO("websocket browserSupportBinaryCheck: false - WebSocket does not support binaryType");
                        return false;
                    }
                }
                if (true) mixin(WebSocketTransportSession, class {
                    scheduleQuery() {
                        const bufferedAmount = this.getBufferedAmount();
                        if (bufferedAmount > 0 && this._bufferedAmountQueryIntervalInMsecs > 0) {
                            this.cancelQuery();
                            if (this._bufferedAmountQueryIntervalDelayMultiplier > 1) this._bufferedAmountQueryIntervalInMsecs, 
                            this._bufferedAmountQueryIntervalDelayMultiplier;
                            const timeout = this._bufferedAmountQueryIntervalInMsecs * this._bufferedAmountQueryIntervalDelayMultiplier;
                            this._bufferedAmountQueryTimer = setTimeout(() => {
                                this.cancelQuery();
                                try {
                                    this.onBufferedAmountPoll();
                                } catch (e) {
                                    LOG_ERROR(`Error occurred in onBufferedAmountPoll: ` + e.message);
                                    e.stack;
                                }
                            }, timeout);
                        }
                    }
                    cancelQuery() {
                        if (this._bufferedAmountQueryTimer) {
                            clearTimeout(this._bufferedAmountQueryTimer);
                            this._bufferedAmountQueryTimer = null;
                        }
                    }
                });
                module.exports.WebSocketTransportSession = WebSocketTransportSession;
            },
            "./modules/solclient-util/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const APIProperties = __webpack_require__("./modules/solclient-util/lib/api-properties.js").APIProperties;
                const APIPropertiesValidators = __webpack_require__("./modules/solclient-util/lib/api-properties-validators.js").APIPropertiesValidators;
                const ArrayUtils = __webpack_require__("./modules/solclient-util/lib/array-utils.js").ArrayUtils;
                const parseURL = __webpack_require__("./modules/solclient-util/lib/url.js").parseURL;
                const Process = __webpack_require__("./modules/solclient-util/lib/process.js").Process;
                const StringBuffer = __webpack_require__("./modules/solclient-util/lib/string-buffer.js").StringBuffer;
                const StringUtils = __webpack_require__("./modules/solclient-util/lib/string-utils.js").StringUtils;
                const TimingBucket = __webpack_require__("./modules/solclient-util/lib/timing-bucket.js").TimingBucket;
                const UUID = __webpack_require__("./modules/solclient-util/lib/uuid.js").UUID;
                const Version = __webpack_require__("./modules/solclient-util/lib/version.js").Version;
                const clone = __webpack_require__("./modules/solclient-util/lib/clone.js");
                module.exports = {
                    clone: clone,
                    parseURL: parseURL,
                    APIProperties: APIProperties,
                    APIPropertiesValidators: APIPropertiesValidators,
                    ArrayUtils: ArrayUtils,
                    Process: Process,
                    StringBuffer: StringBuffer,
                    StringUtils: StringUtils,
                    TimingBucket: TimingBucket,
                    UUID: UUID,
                    Version: Version
                };
            },
            "./modules/solclient-util/lib/api-properties-validators.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Check = __webpack_require__("./modules/solclient-validate/api.js").Check;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const APIPropertiesValidators = {
                    validateInstance(typeDesc, instance, name, ...args) {
                        args.forEach(check => {
                            const validator = check.shift();
                            const validatorArgs = [ typeDesc, instance, name, ...check ];
                            validator(...validatorArgs);
                        });
                    },
                    valInstance(typeDesc, instance, name, typeInstance, typeInstanceDesc) {
                        if (!Check.instanceOf(instance[name], typeInstance)) throw new OperationError(typeDesc + ` validation: Property '${name}' must be instance of ` + typeInstanceDesc);
                    },
                    valNotEmpty(typeDesc, instance, name) {
                        if (Check.none(instance[name]) || "" === instance[name]) throw new OperationError(typeDesc + ` validation: Property '${name}' cannot be empty.`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    },
                    valLength(typeDesc, instance, name, max) {
                        if (Check.string(instance[name]) && instance[name].length > max) throw new OperationError(typeDesc + ` validation: Property '${name}' exceeded max length ` + max, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    },
                    valRange(typeDesc, instance, name, min, max) {
                        if (Check.number(instance[name]) && (instance[name] < min || instance[name] > max)) throw new OperationError(typeDesc + ` validation: Property '${name}' out of range [${min}; ${max}].`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    },
                    valString(typeDesc, instance, name) {
                        if (!Check.string(instance[name])) throw new OperationError(typeDesc + ` validation: Property '${name}' must be type string; was ` + typeof instance[name], ErrorSubcode.PARAMETER_INVALID_TYPE);
                    },
                    valNumber(typeDesc, instance, name) {
                        if (!Check.number(instance[name])) throw new OperationError(typeDesc + ` validation: Property '${name}' must be type number; was ` + typeof instance[name], ErrorSubcode.PARAMETER_INVALID_TYPE);
                    },
                    valBoolean(typeDesc, instance, name) {
                        const val = instance[name];
                        if (!Check.boolean(val)) throw new OperationError(typeDesc + ` validation: Property '${name}' must be type boolean; was ` + typeof val, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    },
                    valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull = false) {
                        const val = instance[key];
                        if (allowNull && (null === val || void 0 === val)) return;
                        if (enumInstance.values.indexOf(val) >= 0) return;
                        throw new OperationError(`${typeDesc} validation: Property '${key}'=${val} must be a member of ` + enumName, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    },
                    valStringOrArray(typeDesc, instance, name) {
                        const val = instance[name];
                        if ("string" !== typeof val && !Array.isArray(val)) throw new OperationError(typeDesc + ` validation: Property '${name}' must be a string or array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    },
                    valArrayIsMember(typeDesc, instance, name, enumInstance, enumName, allowUndefined, allowEmpty, allowDuplicate) {
                        const val = instance[name];
                        if (void 0 === val || null === val) {
                            if (allowUndefined) return;
                            throw new OperationError(typeDesc + ` validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (!Array.isArray(instance[name])) throw new OperationError(typeDesc + ` validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        if (!allowEmpty && 0 === instance[name].length) throw new OperationError(typeDesc + ` validation: Property '${name}' cannot be empty`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        instance[name].forEach((ele, index) => {
                            if (!enumInstance.values.includes(ele)) throw new OperationError(typeDesc + ` validation: Property '${name}' must be an array of ` + enumName, ErrorSubcode.PARAMETER_INVALID_TYPE);
                            if (!allowDuplicate) if (instance[name].indexOf(ele, index + 1) >= 0) throw new OperationError(typeDesc + ` validation: Property '${name}' cannot have duplicate element value`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        });
                    },
                    valArrayOfString(typeDesc, instance, name) {
                        const val = instance[name];
                        if (Check.something(val)) {
                            if (!Array.isArray(val)) throw new OperationError(typeDesc + ` validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                            val.forEach(ele => {
                                if ("string" !== typeof ele) throw new OperationError(typeDesc + ` validation: Property '${name}' must be an array of string`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                            });
                        }
                    },
                    valTopicString(typedesc, instance, name) {
                        const {
                            DestinationUtil,
                            DestinationType
                        } = __webpack_require__("./modules/solclient-destination/api.js");
                        module.exports.APIPropertiesValidators.valString(typedesc, instance, name);
                        const val = instance[name];
                        const result = DestinationUtil.validateAndEncode(DestinationType.TOPIC, val);
                        if (result.error) throw new OperationError(typedesc + ` validation: Property '${name}' must be ` + `a valid topic string: ` + result.error, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    },
                    valTopicStringOrEmpty(typedesc, instance, name) {
                        const val = instance[name];
                        if (val && val.length) module.exports.APIPropertiesValidators.valTopicString(typedesc, instance, name);
                    }
                };
                module.exports.APIPropertiesValidators = APIPropertiesValidators;
            },
            "./modules/solclient-util/lib/api-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
                var util_inspect = __webpack_require__("./node_modules/browser-util-inspect/index.js");
                const cloneObj = __webpack_require__("./modules/solclient-util/lib/clone.js");
                const CLONE_CIRCULAR = false;
                const CLONE_DEPTH = 1;
                class APIProperties {
                    constructor(...options) {
                        Object.assign(this, ...options);
                    }
                    toString() {
                        return util_inspect(this);
                    }
                    clone() {
                        return cloneObj(this, CLONE_CIRCULAR, CLONE_DEPTH);
                    }
                }
                module.exports.APIProperties = APIProperties;
            },
            "./modules/solclient-util/lib/array-utils.js": module => {
                function flatten(array) {
                    return array.reduce((acc, el) => acc.concat(Array.isArray(el) ? flatten(el) : el), []);
                }
                function includes(array, el) {
                    return array.some(v => v === el);
                }
                module.exports.ArrayUtils = {
                    flatten: flatten,
                    includes: includes
                };
            },
            "./modules/solclient-util/lib/browser-url-polyfill.js": module => {
                module.exports = function(scope) {
                    let hasWorkingUrl = false;
                    if (!scope.forceJURL) try {
                        const u = new URL("b", "http://a");
                        u.pathname = "c%20d";
                        hasWorkingUrl = "http://a/c%20d" === u.href;
                    } catch (e) {}
                    if (hasWorkingUrl) return;
                    const relative = Object.create(null);
                    relative["ftp"] = 21;
                    relative["file"] = 0;
                    relative["gopher"] = 70;
                    relative["http"] = 80;
                    relative["https"] = 443;
                    relative["ws"] = 80;
                    relative["wss"] = 443;
                    const relativePathDotMapping = Object.create(null);
                    relativePathDotMapping["%2e"] = ".";
                    relativePathDotMapping[".%2e"] = "..";
                    relativePathDotMapping["%2e."] = "..";
                    relativePathDotMapping["%2e%2e"] = "..";
                    function clear() {
                        this._scheme = "";
                        this._schemeData = "";
                        this._username = "";
                        this._password = null;
                        this._host = "";
                        this._port = "";
                        this._path = [];
                        this._query = "";
                        this._fragment = "";
                        this._isInvalid = false;
                        this._isRelative = false;
                    }
                    function isRelativeScheme(scheme) {
                        return void 0 !== relative[scheme];
                    }
                    function invalid() {
                        clear.call(this);
                        this._isInvalid = true;
                    }
                    function IDNAToASCII(h) {
                        if ("" === h) invalid.call(this);
                        return h.toLowerCase();
                    }
                    function percentEscape(c) {
                        const unicode = c.charCodeAt(0);
                        if (unicode > 32 && unicode < 127 && -1 === [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode)) return c;
                        return encodeURIComponent(c);
                    }
                    function percentEscapeQuery(c) {
                        const unicode = c.charCodeAt(0);
                        if (unicode > 32 && unicode < 127 && -1 === [ 34, 35, 60, 62, 96 ].indexOf(unicode)) return c;
                        return encodeURIComponent(c);
                    }
                    let EOF;
                    const ALPHA = /[a-zA-Z]/;
                    const ALPHANUMERIC = /[a-zA-Z0-9+\-.]/;
                    function parse(input, stateOverride, base) {
                        const errors = [];
                        function err(message) {
                            errors.push(message);
                        }
                        let state = stateOverride || "scheme start";
                        let cursor = 0;
                        let buffer = "";
                        let seenAt = false;
                        let seenBracket = false;
                        loop: while ((input[cursor - 1] !== EOF || 0 === cursor) && !this._isInvalid) {
                            const c = input[cursor];
                            switch (state) {
                              case "scheme start":
                                if (c && ALPHA.test(c)) {
                                    buffer += c.toLowerCase();
                                    state = "scheme";
                                } else if (!stateOverride) {
                                    buffer = "";
                                    state = "no scheme";
                                    continue;
                                } else {
                                    err("Invalid scheme.");
                                    break loop;
                                }
                                break;

                              case "scheme":
                                if (c && ALPHANUMERIC.test(c)) buffer += c.toLowerCase(); else if (":" === c) {
                                    this._scheme = buffer;
                                    buffer = "";
                                    if (stateOverride) break loop;
                                    if (isRelativeScheme(this._scheme)) this._isRelative = true;
                                    if ("file" === this._scheme) state = "relative"; else if (this._isRelative && base && base._scheme === this._scheme) state = "relative or authority"; else if (this._isRelative) state = "authority first slash"; else state = "scheme data";
                                } else if (!stateOverride) {
                                    buffer = "";
                                    cursor = 0;
                                    state = "no scheme";
                                    continue;
                                } else if (EOF === c) break loop; else {
                                    err(`Code point not allowed in scheme: ` + c);
                                    break loop;
                                }
                                break;

                              case "scheme data":
                                if ("?" === c) {
                                    this._query = "?";
                                    state = "query";
                                } else if ("#" === c) {
                                    this._fragment = "#";
                                    state = "fragment";
                                } else if (EOF !== c && "\t" !== c && "\n" !== c && "\r" !== c) this._schemeData += percentEscape(c);
                                break;

                              case "no scheme":
                                if (!base || !isRelativeScheme(base._scheme)) {
                                    err("Missing scheme.");
                                    invalid.call(this);
                                } else {
                                    state = "relative";
                                    continue;
                                }
                                break;

                              case "relative or authority":
                                if ("/" === c && "/" === input[cursor + 1]) state = "authority ignore slashes"; else {
                                    err(`Expected /, got: ` + c);
                                    state = "relative";
                                    continue;
                                }
                                break;

                              case "relative":
                                this._isRelative = true;
                                if ("file" !== this._scheme) this._scheme = base._scheme;
                                if (EOF === c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = base._query;
                                    this._username = base._username;
                                    this._password = base._password;
                                    break loop;
                                } else if ("/" === c || "\\" === c) {
                                    if ("\\" === c) err("\\ is an invalid code point.");
                                    state = "relative slash";
                                } else if ("?" === c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = "?";
                                    this._username = base._username;
                                    this._password = base._password;
                                    state = "query";
                                } else if ("#" === c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = base._query;
                                    this._fragment = "#";
                                    this._username = base._username;
                                    this._password = base._password;
                                    state = "fragment";
                                } else {
                                    const nextC = input[cursor + 1];
                                    const nextNextC = input[cursor + 2];
                                    if ("file" !== this._scheme || !ALPHA.test(c) || ":" !== nextC && "|" !== nextC || EOF !== nextNextC && "/" !== nextNextC && "\\" !== nextNextC && "?" !== nextNextC && "#" !== nextNextC) {
                                        this._host = base._host;
                                        this._port = base._port;
                                        this._username = base._username;
                                        this._password = base._password;
                                        this._path = base._path.slice();
                                        this._path.pop();
                                    }
                                    state = "relative path";
                                    continue;
                                }
                                break;

                              case "relative slash":
                                if ("/" === c || "\\" === c) {
                                    if ("\\" === c) err("\\ is an invalid code point.");
                                    if ("file" === this._scheme) state = "file host"; else state = "authority ignore slashes";
                                } else {
                                    if ("file" !== this._scheme) {
                                        this._host = base._host;
                                        this._port = base._port;
                                        this._username = base._username;
                                        this._password = base._password;
                                    }
                                    state = "relative path";
                                    continue;
                                }
                                break;

                              case "authority first slash":
                                if ("/" === c) state = "authority second slash"; else {
                                    err(`Expected '/', got: ` + c);
                                    state = "authority ignore slashes";
                                    continue;
                                }
                                break;

                              case "authority second slash":
                                state = "authority ignore slashes";
                                if ("/" !== c) {
                                    err(`Expected '/', got: ` + c);
                                    continue;
                                }
                                break;

                              case "authority ignore slashes":
                                if ("/" !== c && "\\" !== c) {
                                    state = "authority";
                                    continue;
                                } else err(`Expected authority, got: ` + c);
                                break;

                              case "authority":
                                if ("@" === c) {
                                    if (seenAt) {
                                        err("@ already seen.");
                                        buffer += "%40";
                                    }
                                    seenAt = true;
                                    for (let i = 0; i < buffer.length; i++) {
                                        const cp = buffer[i];
                                        if ("\t" === cp || "\n" === cp || "\r" === cp) {
                                            err("Invalid whitespace in authority.");
                                            continue;
                                        }
                                        if (":" === cp && null === this._password) {
                                            this._password = "";
                                            continue;
                                        }
                                        const tempC = percentEscape(cp);
                                        if (null !== this._password) this._password += tempC; else this._username += tempC;
                                    }
                                    buffer = "";
                                } else if (EOF === c || "/" === c || "\\" === c || "?" === c || "#" === c) {
                                    cursor -= buffer.length;
                                    buffer = "";
                                    state = "host";
                                    continue;
                                } else buffer += c;
                                break;

                              case "file host":
                                if (EOF === c || "/" === c || "\\" === c || "?" === c || "#" === c) {
                                    if (2 === buffer.length && ALPHA.test(buffer[0]) && (":" === buffer[1] || "|" === buffer[1])) state = "relative path"; else if (0 === buffer.length) state = "relative path start"; else {
                                        this._host = IDNAToASCII.call(this, buffer);
                                        buffer = "";
                                        state = "relative path start";
                                    }
                                    continue;
                                } else if ("\t" === c || "\n" === c || "\r" === c) err("Invalid whitespace in file host."); else buffer += c;
                                break;

                              case "host":
                              case "hostname":
                                if (":" === c && !seenBracket) {
                                    this._host = IDNAToASCII.call(this, buffer);
                                    buffer = "";
                                    state = "port";
                                    if ("hostname" === stateOverride) break loop;
                                } else if (EOF === c || "/" === c || "\\" === c || "?" === c || "#" === c) {
                                    this._host = IDNAToASCII.call(this, buffer);
                                    buffer = "";
                                    state = "relative path start";
                                    if (stateOverride) break loop;
                                    continue;
                                } else if ("\t" !== c && "\n" !== c && "\r" !== c) {
                                    if ("[" === c) seenBracket = true; else if ("]" === c) seenBracket = false;
                                    buffer += c;
                                } else err(`Invalid code point in host/hostname: ` + c);
                                break;

                              case "port":
                                if (/[0-9]/.test(c)) buffer += c; else if (EOF === c || "/" === c || "\\" === c || "?" === c || "#" === c || stateOverride) {
                                    if ("" !== buffer) {
                                        const temp = parseInt(buffer, 10);
                                        if (temp !== relative[this._scheme]) this._port = `` + temp;
                                        buffer = "";
                                    }
                                    if (stateOverride) break loop;
                                    state = "relative path start";
                                    continue;
                                } else if ("\t" === c || "\n" === c || "\r" === c) err(`Invalid code point in port: ` + c); else invalid.call(this);
                                break;

                              case "relative path start":
                                if ("\\" === c) err("'\\' not allowed in path.");
                                state = "relative path";
                                if ("/" !== c && "\\" !== c) continue;
                                break;

                              case "relative path":
                                if (EOF === c || "/" === c || "\\" === c || !stateOverride && ("?" === c || "#" === c)) {
                                    if ("\\" === c) err("\\ not allowed in relative path.");
                                    const tmp = relativePathDotMapping[buffer.toLowerCase()];
                                    if (tmp) buffer = tmp;
                                    if (".." === buffer) {
                                        this._path.pop();
                                        if ("/" !== c && "\\" !== c) this._path.push("");
                                    } else if ("." === buffer && "/" !== c && "\\" !== c) this._path.push(""); else if ("." !== buffer) {
                                        if ("file" === this._scheme && 0 === this._path.length && 2 === buffer.length && ALPHA.test(buffer[0]) && "|" === buffer[1]) buffer = buffer[0] + `:`;
                                        this._path.push(buffer);
                                    }
                                    buffer = "";
                                    if ("?" === c) {
                                        this._query = "?";
                                        state = "query";
                                    } else if ("#" === c) {
                                        this._fragment = "#";
                                        state = "fragment";
                                    }
                                } else if ("\t" !== c && "\n" !== c && "\r" !== c) buffer += percentEscape(c);
                                break;

                              case "query":
                                if (!stateOverride && "#" === c) {
                                    this._fragment = "#";
                                    state = "fragment";
                                } else if (EOF !== c && "\t" !== c && "\n" !== c && "\r" !== c) this._query += percentEscapeQuery(c);
                                break;

                              case "fragment":
                                if (EOF !== c && "\t" !== c && "\n" !== c && "\r" !== c) this._fragment += c;
                                break;

                              default:
                            }
                            cursor++;
                        }
                    }
                    function PolyfillURL(url, base) {
                        if (void 0 !== base && !(base instanceof PolyfillURL)) base = new PolyfillURL(String(base));
                        url = String(url);
                        this._url = url;
                        clear.call(this);
                        const input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
                        parse.call(this, input, null, base);
                    }
                    PolyfillURL.prototype = {
                        toString() {
                            return this.href;
                        },
                        get href() {
                            if (this._isInvalid) return this._url;
                            let authority = "";
                            if ("" !== this._username || null !== this._password) authority = this._username + (null !== this._password ? `:` + this._password : "") + `@`;
                            return this.protocol + (this._isRelative ? `//` + authority + this.host : "") + this.pathname + this._query + this._fragment;
                        },
                        set href(href) {
                            clear.call(this);
                            parse.call(this, href);
                        },
                        get protocol() {
                            return this._scheme + `:`;
                        },
                        set protocol(protocol) {
                            if (this._isInvalid) return;
                            parse.call(this, protocol + `:`, "scheme start");
                        },
                        get host() {
                            if (this._isInvalid) return "";
                            if (this._port) return this._host + `:` + this._port;
                            return this._host;
                        },
                        set host(host) {
                            if (this._isInvalid || !this._isRelative) return;
                            parse.call(this, host, "host");
                        },
                        get hostname() {
                            return this._host;
                        },
                        set hostname(hostname) {
                            if (this._isInvalid || !this._isRelative) return;
                            parse.call(this, hostname, "hostname");
                        },
                        get port() {
                            return this._port;
                        },
                        set port(port) {
                            if (this._isInvalid || !this._isRelative) return;
                            parse.call(this, port, "port");
                        },
                        get pathname() {
                            if (this._isInvalid) return "";
                            if (this._isRelative) return `/` + this._path.join("/");
                            return this._schemeData;
                        },
                        set pathname(pathname) {
                            if (this._isInvalid || !this._isRelative) return;
                            this._path = [];
                            parse.call(this, pathname, "relative path start");
                        },
                        get search() {
                            return this._isInvalid || !this._query || "?" === this._query ? "" : this._query;
                        },
                        set search(search) {
                            if (this._isInvalid || !this._isRelative) return;
                            this._query = "?";
                            if ("?" === search[0]) search = search.slice(1);
                            parse.call(this, search, "query");
                        },
                        get hash() {
                            return this._isInvalid || !this._fragment || "#" === this._fragment ? "" : this._fragment;
                        },
                        set hash(hash) {
                            if (this._isInvalid) return;
                            this._fragment = "#";
                            if ("#" === hash[0]) hash = hash.slice(1);
                            parse.call(this, hash, "fragment");
                        },
                        get origin() {
                            if (this._isInvalid || !this._scheme) return "";
                            switch (this._scheme) {
                              case "data":
                              case "file":
                              case "javascript":
                              case "mailto":
                                return "null";

                              default:
                            }
                            const host = this.host;
                            if (!host) return "";
                            return this._scheme + `://` + host;
                        }
                    };
                    const OriginalURL = scope.URL;
                    if (OriginalURL) {
                        PolyfillURL.createObjectURL = function(...args) {
                            return OriginalURL.createObjectURL(...args);
                        };
                        PolyfillURL.revokeObjectURL = function(url) {
                            OriginalURL.revokeObjectURL(url);
                        };
                    }
                    scope.URL = PolyfillURL;
                };
            },
            "./modules/solclient-util/lib/clone.js": (module, __unused_webpack_exports, __webpack_require__) => {
                "use strict";
                var Buffer = __webpack_require__("./node_modules/buffer/index.js")["Buffer"];
                const clone = function() {
                    function _instanceof(obj, type) {
                        return null != type && obj instanceof type;
                    }
                    let nativeMap;
                    try {
                        nativeMap = Map;
                    } catch (_) {
                        nativeMap = function() {};
                    }
                    let nativeSet;
                    try {
                        nativeSet = Set;
                    } catch (_) {
                        nativeSet = function() {};
                    }
                    let nativePromise;
                    try {
                        nativePromise = Promise;
                    } catch (_) {
                        nativePromise = function() {};
                    }
                    function clone(parent, circular, depth, prototype, includeNonEnumerable) {
                        if ("object" === typeof circular) {
                            depth = circular.depth;
                            prototype = circular.prototype;
                            includeNonEnumerable = circular.includeNonEnumerable;
                            circular = circular.circular;
                        }
                        const allParents = [];
                        const allChildren = [];
                        const useBuffer = "undefined" != typeof Buffer;
                        if ("undefined" == typeof circular) circular = true;
                        if ("undefined" == typeof depth) depth = 1 / 0;
                        function _clone(parent, depth) {
                            if (null === parent) return null;
                            if (0 === depth) return parent;
                            let child;
                            let proto;
                            if ("object" != typeof parent) return parent;
                            if (_instanceof(parent, nativeMap)) child = new nativeMap(); else if (_instanceof(parent, nativeSet)) child = new nativeSet(); else if (_instanceof(parent, nativePromise)) child = new nativePromise(function(resolve, reject) {
                                parent.then(function(value) {
                                    resolve(_clone(value, depth - 1));
                                }, function(err) {
                                    reject(_clone(err, depth - 1));
                                });
                            }); else if (clone.__isArray(parent)) child = []; else if (clone.__isRegExp(parent)) {
                                child = new RegExp(parent.source, __getRegExpFlags(parent));
                                if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                            } else if (clone.__isDate(parent)) child = new Date(parent.getTime()); else if (useBuffer && Buffer.isBuffer(parent)) {
                                if (Buffer.allocUnsafe) child = Buffer.allocUnsafe(parent.length); else child = new Buffer(parent.length);
                                parent.copy(child);
                                return child;
                            } else if (_instanceof(parent, Error)) child = Object.create(parent); else if ("undefined" == typeof prototype) {
                                proto = Object.getPrototypeOf(parent);
                                child = Object.create(proto);
                            } else {
                                child = Object.create(prototype);
                                proto = prototype;
                            }
                            if (circular) {
                                const index = allParents.indexOf(parent);
                                if (-1 != index) return allChildren[index];
                                allParents.push(parent);
                                allChildren.push(child);
                            }
                            if (_instanceof(parent, nativeMap)) {
                                let keyChild, valueChild;
                                parent.forEach(function(value, key) {
                                    keyChild = _clone(key, depth - 1);
                                    valueChild = _clone(value, depth - 1);
                                    child.set(keyChild, valueChild);
                                });
                            }
                            if (_instanceof(parent, nativeSet)) {
                                let entryChild;
                                parent.forEach(function(value) {
                                    entryChild = _clone(value, depth - 1);
                                    child.add(entryChild);
                                });
                            }
                            for (var i in parent) {
                                let attrs;
                                if (proto) attrs = Object.getOwnPropertyDescriptor(proto, i);
                                if (attrs && null == attrs.set) continue;
                                child[i] = _clone(parent[i], depth - 1);
                            }
                            if (Object.getOwnPropertySymbols) {
                                const symbols = Object.getOwnPropertySymbols(parent);
                                for (let i = 0; i < symbols.length; i++) {
                                    let symbol = symbols[i];
                                    let descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) continue;
                                    child[symbol] = _clone(parent[symbol], depth - 1);
                                    if (!descriptor.enumerable) Object.defineProperty(child, symbol, {
                                        enumerable: false
                                    });
                                }
                            }
                            if (includeNonEnumerable) {
                                const allPropertyNames = Object.getOwnPropertyNames(parent);
                                for (let i = 0; i < allPropertyNames.length; i++) {
                                    let propertyName = allPropertyNames[i];
                                    let descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                                    if (descriptor && descriptor.enumerable) continue;
                                    child[propertyName] = _clone(parent[propertyName], depth - 1);
                                    Object.defineProperty(child, propertyName, {
                                        enumerable: false
                                    });
                                }
                            }
                            return child;
                        }
                        return _clone(parent, depth);
                    }
                    clone.clonePrototype = function(parent) {
                        if (null === parent) return null;
                        let emptyCloneFunc = function() {};
                        emptyCloneFunc.prototype = parent;
                        return new emptyCloneFunc();
                    };
                    function __objToStr(obj) {
                        return Object.prototype.toString.call(obj);
                    }
                    clone.__objToStr = __objToStr;
                    function __isDate(obj) {
                        return "object" === typeof obj && "[object Date]" === __objToStr(obj);
                    }
                    clone.__isDate = __isDate;
                    function __isArray(obj) {
                        return "object" === typeof obj && "[object Array]" === __objToStr(obj);
                    }
                    clone.__isArray = __isArray;
                    function __isRegExp(obj) {
                        return "object" === typeof obj && "[object RegExp]" === __objToStr(obj);
                    }
                    clone.__isRegExp = __isRegExp;
                    function __getRegExpFlags(regExpOptions) {
                        let flags = "";
                        if (regExpOptions.global) flags += "g";
                        if (regExpOptions.ignoreCase) flags += "i";
                        if (regExpOptions.multiline) flags += "m";
                        return flags;
                    }
                    clone.__getRegExpFlags = __getRegExpFlags;
                    return clone;
                }();
                module.exports = clone;
            },
            "./modules/solclient-util/lib/process.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const WINDOWS_VERSION_MAP = {
                    6.4: "10.0",
                    6.3: "8.1",
                    6.2: "8",
                    6.1: "7",
                    "6.0": "Vista",
                    5.2: "Server 2003",
                    5.1: "XP",
                    5.01: "2000 SP1",
                    "5.0": "2000",
                    "4.0": "4.0"
                };
                const context = "undefined" !== typeof window ? window : __webpack_require__.g;
                const DEFAULT = {};
                context.process;
                const BROWSER_PROCESS = {
                    product: "solclientjs",
                    platform: "unknown",
                    agent: "Gecko"
                };
                function getBrowserAgentInfo() {
                    const navObj = "undefined" !== typeof navigator ? navigator : null;
                    if (!navObj) return null;
                    const agentStr = navigator.userAgent;
                    const browsers = [ [ "edge", /Edge\/([0-9._]+)/ ], [ "chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9.]+)(:?\s|$)/ ], [ "firefox", /Firefox\/([0-9.]+)(?:\s|$)/ ], [ "opera", /Opera\/([0-9.]+)(?:\s|$)/ ], [ "opera", /OPR\/([0-9.]+)(:?\s|$)$/ ], [ "ie", /Trident\/7\.0.*rv:([0-9.]+).*\).*Gecko$/ ], [ "ie", /MSIE\s([0-9.]+);.*Trident\/[4-8].0/ ], [ "ie", /MSIE\s(7\.0)/ ], [ "bb10", /BB10;\sTouch.*Version\/([0-9.]+)/ ], [ "android", /Android\s([0-9.]+)/ ], [ "ios", /Version\/([0-9._]+).*Mobile.*Safari.*/ ], [ "safari", /Version\/([0-9._]+).*Safari/ ] ];
                    const agentInfo = {
                        browser: {
                            name: "unknown",
                            version: "0.0.0"
                        },
                        platform: {
                            os: "unknown",
                            arch: "unknown",
                            version: "unknown"
                        }
                    };
                    const agentHas = (...strs) => strs.some(str => agentStr.indexOf(str) >= 0);
                    const firstValue = (...vals) => vals.filter(Boolean).shift();
                    Object.assign(agentInfo, browsers.map(([ key, rule ]) => {
                        if (!rule.test(agentStr)) return false;
                        const match = rule.exec(agentStr);
                        const versionStrs = match && match[1].split(/[._]/).slice(0, 3);
                        const version = versionStrs.map(str => parseInt(str, 10));
                        while (version.length < 3) version.push(0);
                        return {
                            browser: {
                                name: key,
                                version: version.join(".")
                            }
                        };
                    }).filter(Boolean).shift());
                    const os = firstValue(agentHas("Windows Phone") && "WindowsPhone", agentHas("Windows") && "Windows", agentHas("Linux") && "Linux", agentHas("like Mac OS X") && "iOS", agentHas("OS X") && "OSX", agentHas("Android", "Adr") && "Android", agentHas("BB10", "RIM Tablet OS", "BlackBerry") && "BlackBerry");
                    const versionTests = {
                        Windows: () => firstValue(agentHas("Win16") && "3.1.1", agentHas("Windows CE") && "CE", agentHas("Windows 95") && "4.00.950", agentHas("Windows 98; Win 9x 4.90") && "4.90", agentHas("Windows 98") && "4.10", (() => {
                            const parenParts = agentStr.match(/\(.+?\)/);
                            const versionPart = parenParts[0];
                            if (!versionPart) return false;
                            const versionMatch = str => versionPart.indexOf(str) >= 0;
                            return firstValue(...Object.keys(WINDOWS_VERSION_MAP).map(k => versionMatch(k) && WINDOWS_VERSION_MAP[k]));
                        })()),
                        OSX: () => agentStr.match(/OS X ((\d+[._])+\d+)\b/)[1],
                        Linux: () => "",
                        iOS: () => agentStr.match(/OS ((\d+[._])+\d+) like Mac OS X/)[1],
                        Android: () => agentStr.match(/(?:Android|Adr) ((\d+[._])+\d_)/)[1],
                        BlackBerry: () => agentStr.match(/(?:Version\/|RIM Tablet OS )((\d+\.)+\d+)/)[1]
                    };
                    const versionTest = versionTests[os];
                    agentInfo.platform.os = os || "Unknown";
                    agentInfo.platform.version = (versionTest && versionTest() || "0.0.0").replace(/_/g, ".");
                    return agentInfo;
                }
                try {
                    if (true && context.navigator) {
                        const safeEncode = str => str.replace(/[^a-zA-Z0-9_/.]/g, "-");
                        Object.assign(BROWSER_PROCESS, {
                            platform: context.navigator.platform,
                            agent: context.navigator.product,
                            description: safeEncode(context.navigator.userAgent),
                            navigator: context.navigator
                        });
                        const browserAgentInfo = getBrowserAgentInfo();
                        if (browserAgentInfo) {
                            BROWSER_PROCESS.agent = safeEncode(browserAgentInfo.browser.name + `-` + browserAgentInfo.browser.version);
                            BROWSER_PROCESS.platform = BROWSER_PROCESS.agent + `-` + safeEncode(browserAgentInfo.platform.os + `-` + browserAgentInfo.platform.version);
                        }
                    }
                    if (false);
                } catch (ex) {}
                const Process = Object.assign({}, DEFAULT, true ? BROWSER_PROCESS : 0, false ? 0 : {});
                module.exports.Process = Process;
            },
            "./modules/solclient-util/lib/string-buffer.js": module => {
                class StringBuffer {
                    constructor(...args) {
                        this.clear();
                        this.append(...args);
                    }
                    append(...args) {
                        [ ...args ].forEach(arg => {
                            this.buffer[this.index++] = String(arg);
                        });
                        return this;
                    }
                    clear() {
                        this.buffer = [];
                        this.index = 0;
                    }
                    toString() {
                        return this.buffer.join("");
                    }
                }
                module.exports.StringBuffer = StringBuffer;
            },
            "./modules/solclient-util/lib/string-utils.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const StringBuffer = __webpack_require__("./modules/solclient-util/lib/string-buffer.js").StringBuffer;
                const PAD_LEFT = 0;
                const PAD_RIGHT = 1;
                const LUT_PRINTABLE = (() => {
                    const tmp = [];
                    for (let c = 0; c < 256; ++c) tmp[c] = c < 33 || c > 126 ? "." : String.fromCharCode(c);
                    return tmp;
                })();
                function padLeftRight(str, minLen, padSide, padChar = " ") {
                    if ("string" !== typeof str) return str;
                    if (str.length >= minLen) return str;
                    const buf = new StringBuffer();
                    for (let i = 0; i < minLen - str.length; i++) buf.append(padChar.charAt(0));
                    switch (padSide) {
                      case PAD_LEFT:
                        return `` + buf + str;

                      case PAD_RIGHT:
                        return `` + str + buf;

                      default:
                        return str;
                    }
                }
                function leastSpaces(length, line) {
                    if (!line.length) return length;
                    const spaces = line.match(/^\s*/)[0].length;
                    return spaces < length ? spaces : length;
                }
                function capitalizeWord(str) {
                    return `` + str.charAt(0).toUpperCase() + str.substr(1);
                }
                function isEmptyFun(str) {
                    return void 0 === str || null === str || 0 === str.length;
                }
                const StringUtils = {};
                StringUtils.capitalize = function(str) {
                    if (!(str && str.length)) return str;
                    return str.split(" ").map(capitalizeWord).join(" ");
                };
                StringUtils.isEmpty = isEmptyFun;
                StringUtils.notEmpty = function(str) {
                    return !isEmptyFun(str);
                };
                StringUtils.toSafeChars = function(str) {
                    return str.replace(/[^a-zA-Z0-9_/.]/g, "");
                };
                StringUtils.padLeft = function(str, minLen, padChar) {
                    return padLeftRight(str, minLen, PAD_LEFT, padChar);
                };
                StringUtils.padRight = function(str, minLen, padChar) {
                    return padLeftRight(str, minLen, PAD_RIGHT, padChar);
                };
                StringUtils.nullTerminate = function(str) {
                    if (null === str || void 0 === str) throw new Error("non str in nullTerminate");
                    const lastChar = str.charCodeAt(str.length - 1);
                    if (0 === lastChar) return str;
                    return str + String.fromCharCode(0);
                };
                StringUtils.stripNullTerminate = function(str) {
                    if (null === str || void 0 === str) throw new Error("null str in stripNullTerminate");
                    const lastChar = str.charCodeAt(str.length - 1);
                    if (0 === lastChar) return str.substr(0, str.length - 1);
                    return str;
                };
                StringUtils.hexdump = function(s) {
                    const output = new StringBuffer();
                    const printable = new StringBuffer();
                    const spacer = pos => 8 === pos || 16 === pos ? "  " : " ";
                    let linelen = 0;
                    for (let i = 0, sLength = s.length; i < sLength; i++) {
                        const ccode = s.charCodeAt(i);
                        output.append(padLeftRight(ccode.toString(16), 2, PAD_LEFT));
                        printable.append(LUT_PRINTABLE[ccode] || ".");
                        output.append(spacer(++linelen));
                        if (i === s.length - 1) while (linelen < 16) output.append(`  ` + spacer(++linelen));
                        if (16 === linelen) {
                            output.append(printable.join(""));
                            output.append("\n");
                            linelen = 0;
                            printable.clear();
                        }
                    }
                    return output.toString();
                };
                StringUtils.heredoc = function(literals, ...substitutions) {
                    const subst = [ ...substitutions, "" ];
                    const lines = literals.map(k => k + subst.shift()).join("").split(/\r?\n/);
                    const spaces = 1 === lines.length ? 0 : lines.reduce(leastSpaces, 1 / 0);
                    while ("" === lines[0]) lines.shift();
                    return lines.map(line => line.substring(spaces)).join("\n");
                };
                module.exports.StringUtils = StringUtils;
            },
            "./modules/solclient-util/lib/timing-bucket.js": module => {
                class TimingBucket {
                    constructor(name, interval) {
                        this.name = name;
                        this.interval = interval;
                        this.buckets = [];
                    }
                    get bucketCount() {
                        let c = 0;
                        for (let i = 0, n = this.buckets.length; i < n; ++i) c += this.buckets[i] || 0;
                        return c;
                    }
                    log(v) {
                        if (void 0 === v || isNaN(v)) return;
                        const normalized = Math.floor(v / this.interval) * this.interval;
                        this.buckets[normalized] = this.buckets[normalized] || 0;
                        this.buckets[normalized]++;
                    }
                    toString() {
                        const cont = [];
                        this.buckets.forEach(i => {
                            cont.push(i + `: ` + this.buckets[i]);
                        });
                        return `{${cont.join(", ")}}`;
                    }
                }
                module.exports.TimingBucket = TimingBucket;
            },
            "./modules/solclient-util/lib/url.js": function(module, __unused_webpack_exports, __webpack_require__) {
                let parseURL;
                if (false); else {
                    const scope = "undefined" !== typeof window ? window : this;
                    __webpack_require__("./modules/solclient-util/lib/browser-url-polyfill.js")(scope);
                    parseURL = function(...args) {
                        return new URL(...args);
                    };
                }
                module.exports.parseURL = parseURL;
            },
            "./modules/solclient-util/lib/uuid.js": module => {
                function generateUUID() {
                    let d = new Date().getTime();
                    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
                        const r = (d + 16 * Math.random()) % 16 | 0;
                        d = Math.floor(d / 16);
                        return ("x" === c ? r : 3 & r | 8).toString(16);
                    });
                }
                module.exports.UUID = {
                    generateUUID: generateUUID
                };
            },
            "./modules/solclient-util/lib/version.js": module => {
                const VERSION = "10.18.0" || 0;
                const DATE = {
                    TARGET_NAME: "browser",
                    TARGET_BROWSER: true,
                    TARGET_NODE: false,
                    MODE_NAME: "RELEASE",
                    MODE_RELEASE: true,
                    MODE_DEBUG: false,
                    TEST: false,
                    VERSION: "10.18.0"
                }.DATE ? new Date(Date.parse({
                    TARGET_NAME: "browser",
                    TARGET_BROWSER: true,
                    TARGET_NODE: false,
                    MODE_NAME: "RELEASE",
                    MODE_RELEASE: true,
                    MODE_DEBUG: false,
                    TEST: false,
                    VERSION: "10.18.0"
                }.DATE)) : new Date();
                const MODE = "RELEASE";
                const TARGET = {
                    name: "browser",
                    node: false,
                    browser: true
                };
                const FORMATTED_DATE = (() => {
                    const pad = n => n < 10 ? `0` + n : n;
                    const d = DATE;
                    const YYYY = d.getFullYear();
                    const MM = pad(d.getMonth() + 1);
                    const DD = pad(d.getDate());
                    const hh = pad(d.getHours());
                    const mm = pad(d.getMinutes());
                    return `${YYYY}/${MM}/${DD} ${hh}:` + mm;
                })();
                const SUMMARY = [ "SolclientJS", "10.18.0", MODE, FORMATTED_DATE ].join(", ");
                const Version = {
                    version: VERSION,
                    date: DATE,
                    formattedDate: FORMATTED_DATE,
                    target: TARGET,
                    mode: MODE,
                    debug: false,
                    release: true,
                    summary: SUMMARY,
                    toString() {
                        return SUMMARY;
                    }
                };
                module.exports.Version = Version;
            },
            "./modules/solclient-validate/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Check = __webpack_require__("./modules/solclient-validate/lib/check.js").Check;
                const Parameter = __webpack_require__("./modules/solclient-validate/lib/parameter.js").Parameter;
                module.exports.Check = Check;
                module.exports.Parameter = Parameter;
            },
            "./modules/solclient-validate/lib/base-checks.js": module => {
                const EPSILON = 1e6;
                function flatten(arr) {
                    return arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
                }
                const BaseChecks = (() => {
                    const result = {
                        nothing(value) {
                            return void 0 === value || null === value;
                        },
                        anything(value) {
                            return !BaseChecks.nothing(value);
                        },
                        undefined(value) {
                            return "undefined" === typeof value;
                        },
                        defined(value) {
                            return !BaseChecks.undefined(value);
                        },
                        array(value) {
                            return BaseChecks.anything(value) && Array.isArray(value);
                        },
                        object(value) {
                            return !BaseChecks.array(value) && null !== value && ("object" === typeof value || value instanceof Object);
                        },
                        instanceOf(val, type) {
                            return BaseChecks.object(val) && val instanceof type;
                        },
                        type(val, type) {
                            return typeof val === type;
                        },
                        instanceOfAny(val, ...types) {
                            return BaseChecks.array(types) && flatten(types).some(type => BaseChecks.instanceOf(val, type));
                        },
                        empty(val) {
                            if (BaseChecks.nothing(val)) return true;
                            if (BaseChecks.object(val)) if (0 === Object.keys(val).length) return true;
                            if (0 === val.length) return true;
                            return false;
                        },
                        truthy(val, fn) {
                            return !!fn(val);
                        },
                        rangeGe(val, rangeMinInclusive) {
                            return val >= rangeMinInclusive;
                        },
                        rangeGt(val, rangeMin) {
                            return val > rangeMin;
                        },
                        rangeLe(val, rangeMaxInclusive) {
                            return val <= rangeMaxInclusive;
                        },
                        rangeLt(val, rangeMax) {
                            return val < rangeMax;
                        },
                        rangeCompare(val, operator, operand, ...args) {
                            switch (operator) {
                              case "=":
                              case "==":
                              case "===":
                                return val === operand;

                              case "~=":
                              case "=~":
                                {
                                    const epsilon = args[0] || EPSILON;
                                    return Math.abs(val - operand) < epsilon;
                                }

                              case "<":
                                return val < operand;

                              case "<=":
                                return val <= operand;

                              case ">":
                                return val > operand;

                              case ">=":
                                return val >= operand;

                              default:
                                throw new Error(`Illegal operator for rangeCompare: ` + operator);
                            }
                        },
                        NaN(val) {
                            return Number.isNaN(val);
                        },
                        included(val, obj) {
                            if (BaseChecks.nothing(obj)) return false;
                            if (obj.includes) return obj.includes(val);
                            if (Array.isArray(obj)) return obj.indexOf(val) >= 0;
                            if (BaseChecks.object(obj)) {
                                const keys = Object.keys(obj);
                                return BaseChecks.included(val, keys);
                            }
                            return false;
                        },
                        equal(val, expected) {
                            return val === expected;
                        },
                        member(val, obj) {
                            return BaseChecks.anything(obj) && (BaseChecks.array(obj) ? BaseChecks.included(val, obj) : Object.keys(obj).some(k => obj[k] === val));
                        },
                        boolean(v) {
                            return BaseChecks.type(v, "boolean");
                        },
                        number(v) {
                            return BaseChecks.type(v, "number");
                        },
                        string(v) {
                            return BaseChecks.type(v, "string");
                        },
                        function(v) {
                            return BaseChecks.type(v, "function");
                        }
                    };
                    result.none = result.nothing;
                    result.something = result.anything;
                    Object.keys(result).forEach(key => {
                        result[key].orNull = function(val, ...args) {
                            return null === val || result[key](val, ...args);
                        };
                        result[key].orUndefined = function(val, ...args) {
                            return void 0 === val || result[key](val, ...args);
                        };
                        result[key].orNothing = function(val, ...args) {
                            return result.nothing(val) || result[key](val, ...args);
                        };
                    });
                    return result;
                })();
                module.exports.BaseChecks = BaseChecks;
            },
            "./modules/solclient-validate/lib/check.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const BaseChecks = __webpack_require__("./modules/solclient-validate/lib/base-checks.js").BaseChecks;
                function thenGen(doOp) {
                    return {
                        then: doOp ? f => f() : (_, elseFn) => elseFn()
                    };
                }
                const Check = (() => {
                    const result = Object.assign({}, BaseChecks);
                    result.when = condition => thenGen(condition);
                    result.unless = condition => thenGen(!condition);
                    return result;
                })();
                module.exports.Check = Check;
            },
            "./modules/solclient-validate/lib/parameter.js": (module, __unused_webpack_exports, __webpack_require__) => {
                const Check = __webpack_require__("./modules/solclient-validate/lib/check.js").Check;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__("./modules/solclient-error/api.js");
                const NO_OBJ = {};
                function objectValues(object) {
                    return Object.keys(object).map(k => object[k]);
                }
                function subcodeSummary(subcode, expected = null, got = NO_OBJ) {
                    const expectedStr = expected ? `; expected: ` + expected : "";
                    const gotStr = got !== NO_OBJ ? `; got: ` + got : "";
                    switch (subcode) {
                      case ErrorSubcode.PARAMETER_INVALID_TYPE:
                        return `Parameter type was invalid` + expectedStr + gotStr;

                      default:
                        return ErrorSubcode.nameOf(subcode).toLowerCase().replace(/_/, " ") + expectedStr;
                    }
                }
                function validateError(name, subcode, message) {
                    throw new OperationError(`Parameter ${name} failed validation`, subcode, message);
                }
                function validate(name, subcode, message, check, value, ...validatorArgs) {
                    if (!check(value, ...validatorArgs)) return validateError(name, subcode, message);
                    return value;
                }
                const typename = x => x && x.constructor && x.constructor.name || typeof x;
                const Parameter = {};
                Parameter.isArray = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "array", value)) {
                    return validate(name, subcode, message, Check.isArray, value);
                };
                Parameter.isBoolean = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "boolean", value)) {
                    return validate(name, subcode, message, Check.boolean, value);
                };
                Parameter.isBooleanOrNothing = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "boolean or nothing", value)) {
                    return validate(name, subcode, message, Check.boolean.orNothing, value);
                };
                Parameter.isEnumMember = function(name, value, memberOfEnum, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of [${memberOfEnum.names.join(", ")}]`, value)) {
                    return validate(name, subcode, message, Check.member, value, memberOfEnum);
                };
                Parameter.isEnumMemberOrNothing = function(name, value, memberOfEnum, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of [${memberOfEnum.names.join(", ")}]`, value)) {
                    return validate(name, subcode, message, Check.member.orNothing, value, memberOfEnum);
                };
                Parameter.isFunction = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "function", value)) {
                    return validate(name, subcode, message, Check.function, value);
                };
                Parameter.isFunctionOrNothing = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "function or nothing", value)) {
                    return validate(name, subcode, message, Check.function.orNothing, value);
                };
                Parameter.isInstanceOf = function(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, instanceOf.name, typename(value))) {
                    return validate(name, subcode, message, Check.instanceOf, value, instanceOf);
                };
                Parameter.isInstanceOfOrNothing = function(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, instanceOf.name + ` or nothing`, typename(value))) {
                    return validate(name, subcode, message, Check.instanceOf.orNothing, value, instanceOf);
                };
                Parameter.isInstanceOfOrNull = function(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, instanceOf.name + ` or null`, typename(value))) {
                    return validate(name, subcode, message, Check.instanceOf.orNull, value, instanceOf);
                };
                Parameter.isInstanceOfOrUndefined = function(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, instanceOf.name + ` or undefined`, typename(value))) {
                    return validate(name, subcode, message, Check.instanceOf.orUndefined, value, instanceOf);
                };
                Parameter.isMember = function(name, value, memberOf, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of ${memberOf.name}.[${objectValues(memberOf).join(", ")}]`, value)) {
                    return validate(name, subcode, message, Check.member, value, memberOf);
                };
                Parameter.isNumber = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number", value)) {
                    return validate(name, subcode, message, Check.number, value);
                };
                Parameter.isNumberOrNothing = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number or nothing", value)) {
                    return validate(name, subcode, message, Check.number.orNothing, value);
                };
                Parameter.isNumberOrNull = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number or null", value)) {
                    return validate(name, subcode, message, Check.number.orNull, value);
                };
                Parameter.isRangeCompare = function(name, value, operator, operand, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, operator + ` ` + operand, value)) {
                    return validate(name, subcode, message, Check.rangeCompare, value, operator, operand);
                };
                Parameter.isRangeCompareOrNothing = function(name, value, operator, operand, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `${operator} ${operand} or nothing`, value)) {
                    return validate(name, subcode, message, Check.rangeCompare.orNothing, value, operator, operand);
                };
                Parameter.isStringOrNull = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string or null", value)) {
                    return validate(name, subcode, message, Check.string.orNull, value);
                };
                Parameter.isString = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string", value)) {
                    return validate(name, subcode, message, Check.string, value);
                };
                Parameter.isStringOrNothing = function(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string or nothing", value)) {
                    return validate(name, subcode, message, Check.string.orNothing, value);
                };
                Parameter.isValue = function(name, value, expected, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `must be ` + value)) {
                    return validate(name, subcode, message, Check.equal, value, expected);
                };
                module.exports.Parameter = Parameter;
            },
            "./node_modules/base64-js/index.js": (__unused_webpack_module, exports) => {
                "use strict";
                exports.byteLength = byteLength;
                exports.toByteArray = toByteArray;
                exports.fromByteArray = fromByteArray;
                var lookup = [];
                var revLookup = [];
                var Arr = "undefined" !== typeof Uint8Array ? Uint8Array : Array;
                var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                for (var i = 0, len = code.length; i < len; ++i) {
                    lookup[i] = code[i];
                    revLookup[code.charCodeAt(i)] = i;
                }
                revLookup["-".charCodeAt(0)] = 62;
                revLookup["_".charCodeAt(0)] = 63;
                function getLens(b64) {
                    var len = b64.length;
                    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                    b64 = b64.indexOf("=");
                    if (-1 === b64) b64 = len;
                    len = b64 === len ? 0 : 4 - b64 % 4;
                    return [ b64, len ];
                }
                function byteLength(b64) {
                    b64 = getLens(b64);
                    var validLen = b64[0];
                    b64 = b64[1];
                    return 3 * (validLen + b64) / 4 - b64;
                }
                function _byteLength(b64, validLen, placeHoldersLen) {
                    return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen;
                }
                function toByteArray(b64) {
                    var tmp;
                    var lens = getLens(b64);
                    var validLen = lens[0];
                    lens = lens[1];
                    var arr = new Arr(_byteLength(b64, validLen, lens));
                    var curByte = 0;
                    var len = lens > 0 ? validLen - 4 : validLen;
                    var i;
                    for (i = 0; i < len; i += 4) {
                        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
                        arr[curByte++] = tmp >> 16 & 255;
                        arr[curByte++] = tmp >> 8 & 255;
                        arr[curByte++] = 255 & tmp;
                    }
                    if (2 === lens) {
                        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
                        arr[curByte++] = 255 & tmp;
                    }
                    if (1 === lens) {
                        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
                        arr[curByte++] = tmp >> 8 & 255;
                        arr[curByte++] = 255 & tmp;
                    }
                    return arr;
                }
                function tripletToBase64(num) {
                    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[63 & num];
                }
                function encodeChunk(uint8, start, end) {
                    var tmp;
                    var output = [];
                    for (var i = start; i < end; i += 3) {
                        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (255 & uint8[i + 2]);
                        output.push(tripletToBase64(tmp));
                    }
                    return output.join("");
                }
                function fromByteArray(uint8) {
                    var tmp;
                    var len = uint8.length;
                    var extraBytes = len % 3;
                    var parts = [];
                    var maxChunkLength = 16383;
                    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
                    if (1 === extraBytes) {
                        tmp = uint8[len - 1];
                        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
                    } else if (2 === extraBytes) {
                        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
                    }
                    return parts.join("");
                }
            },
            "./node_modules/browser-util-inspect/index.js": module => {
                module.exports = inspect;
                function inspect(obj, opts) {
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) ctx.showHidden = opts; else if (opts) _extend(ctx, opts);
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                inspect.colors = {
                    bold: [ 1, 22 ],
                    italic: [ 3, 23 ],
                    underline: [ 4, 24 ],
                    inverse: [ 7, 27 ],
                    white: [ 37, 39 ],
                    grey: [ 90, 39 ],
                    black: [ 30, 39 ],
                    blue: [ 34, 39 ],
                    cyan: [ 36, 39 ],
                    green: [ 32, 39 ],
                    magenta: [ 35, 39 ],
                    red: [ 31, 39 ],
                    yellow: [ 33, 39 ]
                };
                inspect.styles = {
                    special: "cyan",
                    number: "yellow",
                    boolean: "yellow",
                    undefined: "grey",
                    null: "bold",
                    string: "green",
                    date: "magenta",
                    regexp: "red"
                };
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function isBoolean(arg) {
                    return "boolean" === typeof arg;
                }
                function isUndefined(arg) {
                    return void 0 === arg;
                }
                function stylizeWithColor(str, styleType) {
                    styleType = inspect.styles[styleType];
                    if (styleType) return "[" + inspect.colors[styleType][0] + "m" + str + "[" + inspect.colors[styleType][1] + "m"; else return str;
                }
                function isFunction(arg) {
                    return "function" === typeof arg;
                }
                function isString(arg) {
                    return "string" === typeof arg;
                }
                function isNumber(arg) {
                    return "number" === typeof arg;
                }
                function isNull(arg) {
                    return null === arg;
                }
                function hasOwn(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                function isRegExp(re) {
                    return isObject(re) && "[object RegExp]" === objectToString(re);
                }
                function isObject(arg) {
                    return "object" === typeof arg && null !== arg;
                }
                function isError(e) {
                    return isObject(e) && ("[object Error]" === objectToString(e) || e instanceof Error);
                }
                function isDate(d) {
                    return isObject(d) && "[object Date]" === objectToString(d);
                }
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for (var i = 0, l = value.length; i < l; ++i) if (hasOwn(value, String(i))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true)); else output.push("");
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                    });
                    return output;
                }
                function formatError(value) {
                    return "[" + Error.prototype.toString.call(value) + "]";
                }
                function formatValue(ctx, value, recurseTimes) {
                    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) ret = formatValue(ctx, ret, recurseTimes);
                        return ret;
                    }
                    ret = formatPrimitive(ctx, value);
                    if (ret) return ret;
                    ret = Object.keys(value);
                    var visibleKeys = arrayToHash(ret);
                    try {
                        if (ctx.showHidden && Object.getOwnPropertyNames) ret = Object.getOwnPropertyNames(value);
                    } catch (e) {}
                    if (isError(value) && (ret.indexOf("message") >= 0 || ret.indexOf("description") >= 0)) return formatError(value);
                    if (0 === ret.length) {
                        if (isFunction(value)) {
                            var name = value.name ? ": " + value.name : "";
                            return ctx.stylize("[Function" + name + "]", "special");
                        }
                        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
                        if (isError(value)) return formatError(value);
                    }
                    var name = "", array = false, braces = [ "{", "}" ];
                    if (Array.isArray(value)) {
                        array = true;
                        braces = [ "[", "]" ];
                    }
                    if (isFunction(value)) {
                        var n = value.name ? ": " + value.name : "";
                        name = " [Function" + n + "]";
                    }
                    if (isRegExp(value)) name = " " + RegExp.prototype.toString.call(value);
                    if (isDate(value)) name = " " + Date.prototype.toUTCString.call(value);
                    if (isError(value)) name = " " + formatError(value);
                    if (0 === ret.length && (!array || 0 == value.length)) return braces[0] + name + braces[1];
                    if (recurseTimes < 0) if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp"); else return ctx.stylize("[Object]", "special");
                    ctx.seen.push(value);
                    var output;
                    if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, ret); else output = ret.map(function(key) {
                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                    });
                    ctx.seen.pop();
                    return reduceToSingleString(output, name, braces);
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = {
                        value: void 0
                    };
                    try {
                        desc.value = value[key];
                    } catch (e) {}
                    try {
                        if (Object.getOwnPropertyDescriptor) desc = Object.getOwnPropertyDescriptor(value, key) || desc;
                    } catch (e) {}
                    if (desc.get) if (desc.set) str = ctx.stylize("[Getter/Setter]", "special"); else str = ctx.stylize("[Getter]", "special"); else if (desc.set) str = ctx.stylize("[Setter]", "special");
                    if (!hasOwn(visibleKeys, key)) name = "[" + key + "]";
                    if (!str) if (ctx.seen.indexOf(desc.value) < 0) {
                        if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null); else str = formatValue(ctx, desc.value, recurseTimes - 1);
                        if (str.indexOf("\n") > -1) if (array) str = str.split("\n").map(function(line) {
                            return "  " + line;
                        }).join("\n").substr(2); else str = "\n" + str.split("\n").map(function(line) {
                            return "   " + line;
                        }).join("\n");
                    } else str = ctx.stylize("[Circular]", "special");
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) return str;
                        name = JSON.stringify("" + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.substr(1, name.length - 2);
                            name = ctx.stylize(name, "name");
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, "string");
                        }
                    }
                    return name + ": " + str;
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                    if (isString(value)) {
                        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return ctx.stylize(simple, "string");
                    }
                    if (isNumber(value)) return ctx.stylize("" + value, "number");
                    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
                    if (isNull(value)) return ctx.stylize("null", "null");
                }
                function reduceToSingleString(output, base, braces) {
                    var length = output.reduce(function(prev, cur) {
                        0;
                        if (cur.indexOf("\n") >= 0) 0;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0);
                    if (length > 60) return braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
                }
                function _extend(origin, add) {
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while (i--) origin[keys[i]] = add[keys[i]];
                    return origin;
                }
            },
            "./node_modules/buffer/index.js": (__unused_webpack_module, exports, __webpack_require__) => {
                "use strict";
                const base64 = __webpack_require__("./node_modules/base64-js/index.js");
                const ieee754 = __webpack_require__("./node_modules/ieee754/index.js");
                const customInspectSymbol = "function" === typeof Symbol && "function" === typeof Symbol["for"] ? Symbol["for"]("nodejs.util.inspect.custom") : null;
                exports.Buffer = Buffer;
                exports.SlowBuffer = SlowBuffer;
                exports.INSPECT_MAX_BYTES = 50;
                const K_MAX_LENGTH = 2147483647;
                exports.kMaxLength = K_MAX_LENGTH;
                Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
                if (!Buffer.TYPED_ARRAY_SUPPORT && "undefined" !== typeof console && "function" === typeof console.error) console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
                function typedArraySupport() {
                    try {
                        const arr = new Uint8Array(1);
                        const proto = {
                            foo: function() {
                                return 42;
                            }
                        };
                        Object.setPrototypeOf(proto, Uint8Array.prototype);
                        Object.setPrototypeOf(arr, proto);
                        return 42 === arr.foo();
                    } catch (e) {
                        return false;
                    }
                }
                Object.defineProperty(Buffer.prototype, "parent", {
                    enumerable: true,
                    get: function() {
                        if (!Buffer.isBuffer(this)) return;
                        return this.buffer;
                    }
                });
                Object.defineProperty(Buffer.prototype, "offset", {
                    enumerable: true,
                    get: function() {
                        if (!Buffer.isBuffer(this)) return;
                        return this.byteOffset;
                    }
                });
                function createBuffer(length) {
                    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
                    const buf = new Uint8Array(length);
                    Object.setPrototypeOf(buf, Buffer.prototype);
                    return buf;
                }
                function Buffer(arg, encodingOrOffset, length) {
                    if ("number" === typeof arg) {
                        if ("string" === typeof encodingOrOffset) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return allocUnsafe(arg);
                    }
                    return from(arg, encodingOrOffset, length);
                }
                Buffer.poolSize = 8192;
                function from(value, encodingOrOffset, length) {
                    if ("string" === typeof value) return fromString(value, encodingOrOffset);
                    if (ArrayBuffer.isView(value)) return fromArrayView(value);
                    if (null == value) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof value);
                    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
                    if ("undefined" !== typeof SharedArrayBuffer && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
                    if ("number" === typeof value) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    const valueOf = value.valueOf && value.valueOf();
                    if (null != valueOf && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
                    const b = fromObject(value);
                    if (b) return b;
                    if ("undefined" !== typeof Symbol && null != Symbol.toPrimitive && "function" === typeof value[Symbol.toPrimitive]) return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof value);
                }
                Buffer.from = function(value, encodingOrOffset, length) {
                    return from(value, encodingOrOffset, length);
                };
                Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
                Object.setPrototypeOf(Buffer, Uint8Array);
                function assertSize(size) {
                    if ("number" !== typeof size) throw new TypeError('"size" argument must be of type number'); else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
                }
                function alloc(size, fill, encoding) {
                    assertSize(size);
                    if (size <= 0) return createBuffer(size);
                    if (void 0 !== fill) return "string" === typeof encoding ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                    return createBuffer(size);
                }
                Buffer.alloc = function(size, fill, encoding) {
                    return alloc(size, fill, encoding);
                };
                function allocUnsafe(size) {
                    assertSize(size);
                    return createBuffer(size < 0 ? 0 : 0 | checked(size));
                }
                Buffer.allocUnsafe = function(size) {
                    return allocUnsafe(size);
                };
                Buffer.allocUnsafeSlow = function(size) {
                    return allocUnsafe(size);
                };
                function fromString(string, encoding) {
                    if ("string" !== typeof encoding || "" === encoding) encoding = "utf8";
                    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
                    const length = 0 | byteLength(string, encoding);
                    let buf = createBuffer(length);
                    const actual = buf.write(string, encoding);
                    if (actual !== length) buf = buf.slice(0, actual);
                    return buf;
                }
                function fromArrayLike(array) {
                    const length = array.length < 0 ? 0 : 0 | checked(array.length);
                    const buf = createBuffer(length);
                    for (let i = 0; i < length; i += 1) buf[i] = 255 & array[i];
                    return buf;
                }
                function fromArrayView(arrayView) {
                    if (isInstance(arrayView, Uint8Array)) {
                        const copy = new Uint8Array(arrayView);
                        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
                    }
                    return fromArrayLike(arrayView);
                }
                function fromArrayBuffer(array, byteOffset, length) {
                    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
                    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
                    let buf;
                    if (void 0 === byteOffset && void 0 === length) buf = new Uint8Array(array); else if (void 0 === length) buf = new Uint8Array(array, byteOffset); else buf = new Uint8Array(array, byteOffset, length);
                    Object.setPrototypeOf(buf, Buffer.prototype);
                    return buf;
                }
                function fromObject(obj) {
                    if (Buffer.isBuffer(obj)) {
                        const len = 0 | checked(obj.length);
                        const buf = createBuffer(len);
                        if (0 === buf.length) return buf;
                        obj.copy(buf, 0, 0, len);
                        return buf;
                    }
                    if (void 0 !== obj.length) {
                        if ("number" !== typeof obj.length || numberIsNaN(obj.length)) return createBuffer(0);
                        return fromArrayLike(obj);
                    }
                    if ("Buffer" === obj.type && Array.isArray(obj.data)) return fromArrayLike(obj.data);
                }
                function checked(length) {
                    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                    return 0 | length;
                }
                function SlowBuffer(length) {
                    if (+length != length) length = 0;
                    return Buffer.alloc(+length);
                }
                Buffer.isBuffer = function(b) {
                    return null != b && true === b._isBuffer && b !== Buffer.prototype;
                };
                Buffer.compare = function(a, b) {
                    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
                    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
                    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (a === b) return 0;
                    let x = a.length;
                    let y = b.length;
                    for (let i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
                        x = a[i];
                        y = b[i];
                        break;
                    }
                    if (x < y) return -1;
                    if (y < x) return 1;
                    return 0;
                };
                Buffer.isEncoding = function(encoding) {
                    switch (String(encoding).toLowerCase()) {
                      case "hex":
                      case "utf8":
                      case "utf-8":
                      case "ascii":
                      case "latin1":
                      case "binary":
                      case "base64":
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return true;

                      default:
                        return false;
                    }
                };
                Buffer.concat = function(list, length) {
                    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === list.length) return Buffer.alloc(0);
                    let i;
                    if (void 0 === length) {
                        length = 0;
                        for (i = 0; i < list.length; ++i) length += list[i].length;
                    }
                    const buffer = Buffer.allocUnsafe(length);
                    let pos = 0;
                    for (i = 0; i < list.length; ++i) {
                        let buf = list[i];
                        if (isInstance(buf, Uint8Array)) if (pos + buf.length > buffer.length) {
                            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                            buf.copy(buffer, pos);
                        } else Uint8Array.prototype.set.call(buffer, buf, pos); else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers'); else buf.copy(buffer, pos);
                        pos += buf.length;
                    }
                    return buffer;
                };
                function byteLength(string, encoding) {
                    if (Buffer.isBuffer(string)) return string.length;
                    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
                    if ("string" !== typeof string) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof string);
                    const len = string.length;
                    const mustMatch = arguments.length > 2 && true === arguments[2];
                    if (!mustMatch && 0 === len) return 0;
                    let loweredCase = false;
                    for (;;) switch (encoding) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return len;

                      case "utf8":
                      case "utf-8":
                        return utf8ToBytes(string).length;

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return 2 * len;

                      case "hex":
                        return len >>> 1;

                      case "base64":
                        return base64ToBytes(string).length;

                      default:
                        if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length;
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                }
                Buffer.byteLength = byteLength;
                function slowToString(encoding, start, end) {
                    let loweredCase = false;
                    if (void 0 === start || start < 0) start = 0;
                    if (start > this.length) return "";
                    if (void 0 === end || end > this.length) end = this.length;
                    if (end <= 0) return "";
                    end >>>= 0;
                    start >>>= 0;
                    if (end <= start) return "";
                    if (!encoding) encoding = "utf8";
                    while (true) switch (encoding) {
                      case "hex":
                        return hexSlice(this, start, end);

                      case "utf8":
                      case "utf-8":
                        return utf8Slice(this, start, end);

                      case "ascii":
                        return asciiSlice(this, start, end);

                      case "latin1":
                      case "binary":
                        return latin1Slice(this, start, end);

                      case "base64":
                        return base64Slice(this, start, end);

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return utf16leSlice(this, start, end);

                      default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase();
                        loweredCase = true;
                    }
                }
                Buffer.prototype._isBuffer = true;
                function swap(b, n, m) {
                    const i = b[n];
                    b[n] = b[m];
                    b[m] = i;
                }
                Buffer.prototype.swap16 = function() {
                    const len = this.length;
                    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (let i = 0; i < len; i += 2) swap(this, i, i + 1);
                    return this;
                };
                Buffer.prototype.swap32 = function() {
                    const len = this.length;
                    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (let i = 0; i < len; i += 4) {
                        swap(this, i, i + 3);
                        swap(this, i + 1, i + 2);
                    }
                    return this;
                };
                Buffer.prototype.swap64 = function() {
                    const len = this.length;
                    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (let i = 0; i < len; i += 8) {
                        swap(this, i, i + 7);
                        swap(this, i + 1, i + 6);
                        swap(this, i + 2, i + 5);
                        swap(this, i + 3, i + 4);
                    }
                    return this;
                };
                Buffer.prototype.toString = function() {
                    const length = this.length;
                    if (0 === length) return "";
                    if (0 === arguments.length) return utf8Slice(this, 0, length);
                    return slowToString.apply(this, arguments);
                };
                Buffer.prototype.toLocaleString = Buffer.prototype.toString;
                Buffer.prototype.equals = function(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
                    if (this === b) return true;
                    return 0 === Buffer.compare(this, b);
                };
                Buffer.prototype.inspect = function() {
                    let str = "";
                    const max = exports.INSPECT_MAX_BYTES;
                    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                    if (this.length > max) str += " ... ";
                    return "<Buffer " + str + ">";
                };
                if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
                Buffer.prototype.compare = function(target, start, end, thisStart, thisEnd) {
                    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
                    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof target);
                    if (void 0 === start) start = 0;
                    if (void 0 === end) end = target ? target.length : 0;
                    if (void 0 === thisStart) thisStart = 0;
                    if (void 0 === thisEnd) thisEnd = this.length;
                    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
                    if (thisStart >= thisEnd && start >= end) return 0;
                    if (thisStart >= thisEnd) return -1;
                    if (start >= end) return 1;
                    start >>>= 0;
                    end >>>= 0;
                    thisStart >>>= 0;
                    thisEnd >>>= 0;
                    if (this === target) return 0;
                    let x = thisEnd - thisStart;
                    let y = end - start;
                    const len = Math.min(x, y);
                    const thisCopy = this.slice(thisStart, thisEnd);
                    const targetCopy = target.slice(start, end);
                    for (let i = 0; i < len; ++i) if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i];
                        y = targetCopy[i];
                        break;
                    }
                    if (x < y) return -1;
                    if (y < x) return 1;
                    return 0;
                };
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                    if (0 === buffer.length) return -1;
                    if ("string" === typeof byteOffset) {
                        encoding = byteOffset;
                        byteOffset = 0;
                    } else if (byteOffset > 2147483647) byteOffset = 2147483647; else if (byteOffset < -2147483648) byteOffset = -2147483648;
                    byteOffset = +byteOffset;
                    if (numberIsNaN(byteOffset)) byteOffset = dir ? 0 : buffer.length - 1;
                    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                    if (byteOffset >= buffer.length) if (dir) return -1; else byteOffset = buffer.length - 1; else if (byteOffset < 0) if (dir) byteOffset = 0; else return -1;
                    if ("string" === typeof val) val = Buffer.from(val, encoding);
                    if (Buffer.isBuffer(val)) {
                        if (0 === val.length) return -1;
                        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                    } else if ("number" === typeof val) {
                        val &= 255;
                        if ("function" === typeof Uint8Array.prototype.indexOf) if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset); else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
                    }
                    throw new TypeError("val must be string, number or Buffer");
                }
                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                    let indexSize = 1;
                    let arrLength = arr.length;
                    let valLength = val.length;
                    if (void 0 !== encoding) {
                        encoding = String(encoding).toLowerCase();
                        if ("ucs2" === encoding || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding) {
                            if (arr.length < 2 || val.length < 2) return -1;
                            indexSize = 2;
                            arrLength /= 2;
                            valLength /= 2;
                            byteOffset /= 2;
                        }
                    }
                    function read(buf, i) {
                        if (1 === indexSize) return buf[i]; else return buf.readUInt16BE(i * indexSize);
                    }
                    let i;
                    if (dir) {
                        let foundIndex = -1;
                        for (i = byteOffset; i < arrLength; i++) if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
                            if (-1 === foundIndex) foundIndex = i;
                            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                        } else {
                            if (-1 !== foundIndex) i -= i - foundIndex;
                            foundIndex = -1;
                        }
                    } else {
                        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                        for (i = byteOffset; i >= 0; i--) {
                            let found = true;
                            for (let j = 0; j < valLength; j++) if (read(arr, i + j) !== read(val, j)) {
                                found = false;
                                break;
                            }
                            if (found) return i;
                        }
                    }
                    return -1;
                }
                Buffer.prototype.includes = function(val, byteOffset, encoding) {
                    return -1 !== this.indexOf(val, byteOffset, encoding);
                };
                Buffer.prototype.indexOf = function(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                };
                Buffer.prototype.lastIndexOf = function(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                };
                function hexWrite(buf, string, offset, length) {
                    offset = Number(offset) || 0;
                    const remaining = buf.length - offset;
                    if (!length) length = remaining; else {
                        length = Number(length);
                        if (length > remaining) length = remaining;
                    }
                    const strLen = string.length;
                    if (length > strLen / 2) length = strLen / 2;
                    let i;
                    for (i = 0; i < length; ++i) {
                        const parsed = parseInt(string.substr(2 * i, 2), 16);
                        if (numberIsNaN(parsed)) return i;
                        buf[offset + i] = parsed;
                    }
                    return i;
                }
                function utf8Write(buf, string, offset, length) {
                    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }
                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(asciiToBytes(string), buf, offset, length);
                }
                function base64Write(buf, string, offset, length) {
                    return blitBuffer(base64ToBytes(string), buf, offset, length);
                }
                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }
                Buffer.prototype.write = function(string, offset, length, encoding) {
                    if (void 0 === offset) {
                        encoding = "utf8";
                        length = this.length;
                        offset = 0;
                    } else if (void 0 === length && "string" === typeof offset) {
                        encoding = offset;
                        length = this.length;
                        offset = 0;
                    } else if (isFinite(offset)) {
                        offset >>>= 0;
                        if (isFinite(length)) {
                            length >>>= 0;
                            if (void 0 === encoding) encoding = "utf8";
                        } else {
                            encoding = length;
                            length = void 0;
                        }
                    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    const remaining = this.length - offset;
                    if (void 0 === length || length > remaining) length = remaining;
                    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    if (!encoding) encoding = "utf8";
                    let loweredCase = false;
                    for (;;) switch (encoding) {
                      case "hex":
                        return hexWrite(this, string, offset, length);

                      case "utf8":
                      case "utf-8":
                        return utf8Write(this, string, offset, length);

                      case "ascii":
                      case "latin1":
                      case "binary":
                        return asciiWrite(this, string, offset, length);

                      case "base64":
                        return base64Write(this, string, offset, length);

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return ucs2Write(this, string, offset, length);

                      default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                };
                Buffer.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                };
                function base64Slice(buf, start, end) {
                    if (0 === start && end === buf.length) return base64.fromByteArray(buf); else return base64.fromByteArray(buf.slice(start, end));
                }
                function utf8Slice(buf, start, end) {
                    end = Math.min(buf.length, end);
                    const res = [];
                    let i = start;
                    while (i < end) {
                        const firstByte = buf[i];
                        let codePoint = null;
                        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                        if (i + bytesPerSequence <= end) {
                            let secondByte, thirdByte, fourthByte, tempCodePoint;
                            switch (bytesPerSequence) {
                              case 1:
                                if (firstByte < 128) codePoint = firstByte;
                                break;

                              case 2:
                                secondByte = buf[i + 1];
                                if (128 === (192 & secondByte)) {
                                    tempCodePoint = (31 & firstByte) << 6 | 63 & secondByte;
                                    if (tempCodePoint > 127) codePoint = tempCodePoint;
                                }
                                break;

                              case 3:
                                secondByte = buf[i + 1];
                                thirdByte = buf[i + 2];
                                if (128 === (192 & secondByte) && 128 === (192 & thirdByte)) {
                                    tempCodePoint = (15 & firstByte) << 12 | (63 & secondByte) << 6 | 63 & thirdByte;
                                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                                }
                                break;

                              case 4:
                                secondByte = buf[i + 1];
                                thirdByte = buf[i + 2];
                                fourthByte = buf[i + 3];
                                if (128 === (192 & secondByte) && 128 === (192 & thirdByte) && 128 === (192 & fourthByte)) {
                                    tempCodePoint = (15 & firstByte) << 18 | (63 & secondByte) << 12 | (63 & thirdByte) << 6 | 63 & fourthByte;
                                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                                }
                            }
                        }
                        if (null === codePoint) {
                            codePoint = 65533;
                            bytesPerSequence = 1;
                        } else if (codePoint > 65535) {
                            codePoint -= 65536;
                            res.push(codePoint >>> 10 & 1023 | 55296);
                            codePoint = 56320 | 1023 & codePoint;
                        }
                        res.push(codePoint);
                        i += bytesPerSequence;
                    }
                    return decodeCodePointsArray(res);
                }
                const MAX_ARGUMENTS_LENGTH = 4096;
                function decodeCodePointsArray(codePoints) {
                    const len = codePoints.length;
                    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
                    let res = "";
                    let i = 0;
                    while (i < len) res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                    return res;
                }
                function asciiSlice(buf, start, end) {
                    let ret = "";
                    end = Math.min(buf.length, end);
                    for (let i = start; i < end; ++i) ret += String.fromCharCode(127 & buf[i]);
                    return ret;
                }
                function latin1Slice(buf, start, end) {
                    let ret = "";
                    end = Math.min(buf.length, end);
                    for (let i = start; i < end; ++i) ret += String.fromCharCode(buf[i]);
                    return ret;
                }
                function hexSlice(buf, start, end) {
                    const len = buf.length;
                    if (!start || start < 0) start = 0;
                    if (!end || end < 0 || end > len) end = len;
                    let out = "";
                    for (let i = start; i < end; ++i) out += hexSliceLookupTable[buf[i]];
                    return out;
                }
                function utf16leSlice(buf, start, end) {
                    const bytes = buf.slice(start, end);
                    let res = "";
                    for (let i = 0; i < bytes.length - 1; i += 2) res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
                    return res;
                }
                Buffer.prototype.slice = function(start, end) {
                    const len = this.length;
                    start = ~~start;
                    end = void 0 === end ? len : ~~end;
                    if (start < 0) {
                        start += len;
                        if (start < 0) start = 0;
                    } else if (start > len) start = len;
                    if (end < 0) {
                        end += len;
                        if (end < 0) end = 0;
                    } else if (end > len) end = len;
                    if (end < start) end = start;
                    const newBuf = this.subarray(start, end);
                    Object.setPrototypeOf(newBuf, Buffer.prototype);
                    return newBuf;
                };
                function checkOffset(offset, ext, length) {
                    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
                    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
                }
                Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
                    offset >>>= 0;
                    byteLength >>>= 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);
                    let val = this[offset];
                    let mul = 1;
                    let i = 0;
                    while (++i < byteLength && (mul *= 256)) val += this[offset + i] * mul;
                    return val;
                };
                Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
                    offset >>>= 0;
                    byteLength >>>= 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);
                    let val = this[offset + --byteLength];
                    let mul = 1;
                    while (byteLength > 0 && (mul *= 256)) val += this[offset + --byteLength] * mul;
                    return val;
                };
                Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 1, this.length);
                    return this[offset];
                };
                Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    return this[offset] | this[offset + 1] << 8;
                };
                Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    return this[offset] << 8 | this[offset + 1];
                };
                Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3];
                };
                Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return 16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
                };
                Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function(offset) {
                    offset >>>= 0;
                    validateNumber(offset, "offset");
                    const first = this[offset];
                    const last = this[offset + 7];
                    if (void 0 === first || void 0 === last) boundsError(offset, this.length - 8);
                    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
                    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
                    return BigInt(lo) + (BigInt(hi) << BigInt(32));
                });
                Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function(offset) {
                    offset >>>= 0;
                    validateNumber(offset, "offset");
                    const first = this[offset];
                    const last = this[offset + 7];
                    if (void 0 === first || void 0 === last) boundsError(offset, this.length - 8);
                    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
                    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
                    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
                });
                Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
                    offset >>>= 0;
                    byteLength >>>= 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);
                    let val = this[offset];
                    let mul = 1;
                    let i = 0;
                    while (++i < byteLength && (mul *= 256)) val += this[offset + i] * mul;
                    mul *= 128;
                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                    return val;
                };
                Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
                    offset >>>= 0;
                    byteLength >>>= 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);
                    let i = byteLength;
                    let mul = 1;
                    let val = this[offset + --i];
                    while (i > 0 && (mul *= 256)) val += this[offset + --i] * mul;
                    mul *= 128;
                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                    return val;
                };
                Buffer.prototype.readInt8 = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 1, this.length);
                    if (!(128 & this[offset])) return this[offset];
                    return -1 * (255 - this[offset] + 1);
                };
                Buffer.prototype.readInt16LE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    const val = this[offset] | this[offset + 1] << 8;
                    return 32768 & val ? 4294901760 | val : val;
                };
                Buffer.prototype.readInt16BE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    const val = this[offset + 1] | this[offset] << 8;
                    return 32768 & val ? 4294901760 | val : val;
                };
                Buffer.prototype.readInt32LE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
                };
                Buffer.prototype.readInt32BE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
                };
                Buffer.prototype.readBigInt64LE = defineBigIntMethod(function(offset) {
                    offset >>>= 0;
                    validateNumber(offset, "offset");
                    const first = this[offset];
                    const last = this[offset + 7];
                    if (void 0 === first || void 0 === last) boundsError(offset, this.length - 8);
                    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
                    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
                });
                Buffer.prototype.readBigInt64BE = defineBigIntMethod(function(offset) {
                    offset >>>= 0;
                    validateNumber(offset, "offset");
                    const first = this[offset];
                    const last = this[offset + 7];
                    if (void 0 === first || void 0 === last) boundsError(offset, this.length - 8);
                    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
                    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
                });
                Buffer.prototype.readFloatLE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, true, 23, 4);
                };
                Buffer.prototype.readFloatBE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, false, 23, 4);
                };
                Buffer.prototype.readDoubleLE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, true, 52, 8);
                };
                Buffer.prototype.readDoubleBE = function(offset, noAssert) {
                    offset >>>= 0;
                    if (!noAssert) checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, false, 52, 8);
                };
                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                    if (offset + ext > buf.length) throw new RangeError("Index out of range");
                }
                Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    byteLength >>>= 0;
                    if (!noAssert) {
                        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                        checkInt(this, value, offset, byteLength, maxBytes, 0);
                    }
                    let mul = 1;
                    let i = 0;
                    this[offset] = 255 & value;
                    while (++i < byteLength && (mul *= 256)) this[offset + i] = value / mul & 255;
                    return offset + byteLength;
                };
                Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    byteLength >>>= 0;
                    if (!noAssert) {
                        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                        checkInt(this, value, offset, byteLength, maxBytes, 0);
                    }
                    let i = byteLength - 1;
                    let mul = 1;
                    this[offset + i] = 255 & value;
                    while (--i >= 0 && (mul *= 256)) this[offset + i] = value / mul & 255;
                    return offset + byteLength;
                };
                Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
                    this[offset] = 255 & value;
                    return offset + 1;
                };
                Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                    this[offset] = 255 & value;
                    this[offset + 1] = value >>> 8;
                    return offset + 2;
                };
                Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                    this[offset] = value >>> 8;
                    this[offset + 1] = 255 & value;
                    return offset + 2;
                };
                Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                    this[offset + 3] = value >>> 24;
                    this[offset + 2] = value >>> 16;
                    this[offset + 1] = value >>> 8;
                    this[offset] = 255 & value;
                    return offset + 4;
                };
                Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                    this[offset] = value >>> 24;
                    this[offset + 1] = value >>> 16;
                    this[offset + 2] = value >>> 8;
                    this[offset + 3] = 255 & value;
                    return offset + 4;
                };
                function wrtBigUInt64LE(buf, value, offset, min, max) {
                    checkIntBI(value, min, max, buf, offset, 7);
                    let lo = Number(value & BigInt(4294967295));
                    buf[offset++] = lo;
                    lo >>= 8;
                    buf[offset++] = lo;
                    lo >>= 8;
                    buf[offset++] = lo;
                    lo >>= 8;
                    buf[offset++] = lo;
                    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
                    buf[offset++] = hi;
                    hi >>= 8;
                    buf[offset++] = hi;
                    hi >>= 8;
                    buf[offset++] = hi;
                    hi >>= 8;
                    buf[offset++] = hi;
                    return offset;
                }
                function wrtBigUInt64BE(buf, value, offset, min, max) {
                    checkIntBI(value, min, max, buf, offset, 7);
                    let lo = Number(value & BigInt(4294967295));
                    buf[offset + 7] = lo;
                    lo >>= 8;
                    buf[offset + 6] = lo;
                    lo >>= 8;
                    buf[offset + 5] = lo;
                    lo >>= 8;
                    buf[offset + 4] = lo;
                    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
                    buf[offset + 3] = hi;
                    hi >>= 8;
                    buf[offset + 2] = hi;
                    hi >>= 8;
                    buf[offset + 1] = hi;
                    hi >>= 8;
                    buf[offset] = hi;
                    return offset + 8;
                }
                Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function(value, offset = 0) {
                    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
                });
                Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function(value, offset = 0) {
                    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
                });
                Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) {
                        const limit = Math.pow(2, 8 * byteLength - 1);
                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }
                    let i = 0;
                    let mul = 1;
                    let sub = 0;
                    this[offset] = 255 & value;
                    while (++i < byteLength && (mul *= 256)) {
                        if (value < 0 && 0 === sub && 0 !== this[offset + i - 1]) sub = 1;
                        this[offset + i] = (value / mul >> 0) - sub & 255;
                    }
                    return offset + byteLength;
                };
                Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) {
                        const limit = Math.pow(2, 8 * byteLength - 1);
                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }
                    let i = byteLength - 1;
                    let mul = 1;
                    let sub = 0;
                    this[offset + i] = 255 & value;
                    while (--i >= 0 && (mul *= 256)) {
                        if (value < 0 && 0 === sub && 0 !== this[offset + i + 1]) sub = 1;
                        this[offset + i] = (value / mul >> 0) - sub & 255;
                    }
                    return offset + byteLength;
                };
                Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
                    if (value < 0) value = 255 + value + 1;
                    this[offset] = 255 & value;
                    return offset + 1;
                };
                Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                    this[offset] = 255 & value;
                    this[offset + 1] = value >>> 8;
                    return offset + 2;
                };
                Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                    this[offset] = value >>> 8;
                    this[offset + 1] = 255 & value;
                    return offset + 2;
                };
                Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                    this[offset] = 255 & value;
                    this[offset + 1] = value >>> 8;
                    this[offset + 2] = value >>> 16;
                    this[offset + 3] = value >>> 24;
                    return offset + 4;
                };
                Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                    if (value < 0) value = 4294967295 + value + 1;
                    this[offset] = value >>> 24;
                    this[offset + 1] = value >>> 16;
                    this[offset + 2] = value >>> 8;
                    this[offset + 3] = 255 & value;
                    return offset + 4;
                };
                Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function(value, offset = 0) {
                    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
                });
                Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function(value, offset = 0) {
                    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
                });
                function checkIEEE754(buf, value, offset, ext, max, min) {
                    if (offset + ext > buf.length) throw new RangeError("Index out of range");
                    if (offset < 0) throw new RangeError("Index out of range");
                }
                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                    ieee754.write(buf, value, offset, littleEndian, 23, 4);
                    return offset + 4;
                }
                Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
                    return writeFloat(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
                    return writeFloat(this, value, offset, false, noAssert);
                };
                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    value = +value;
                    offset >>>= 0;
                    if (!noAssert) checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                    ieee754.write(buf, value, offset, littleEndian, 52, 8);
                    return offset + 8;
                }
                Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
                    return writeDouble(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
                    return writeDouble(this, value, offset, false, noAssert);
                };
                Buffer.prototype.copy = function(target, targetStart, start, end) {
                    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
                    if (!start) start = 0;
                    if (!end && 0 !== end) end = this.length;
                    if (targetStart >= target.length) targetStart = target.length;
                    if (!targetStart) targetStart = 0;
                    if (end > 0 && end < start) end = start;
                    if (end === start) return 0;
                    if (0 === target.length || 0 === this.length) return 0;
                    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
                    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
                    if (end < 0) throw new RangeError("sourceEnd out of bounds");
                    if (end > this.length) end = this.length;
                    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
                    const len = end - start;
                    if (this === target && "function" === typeof Uint8Array.prototype.copyWithin) this.copyWithin(targetStart, start, end); else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                    return len;
                };
                Buffer.prototype.fill = function(val, start, end, encoding) {
                    if ("string" === typeof val) {
                        if ("string" === typeof start) {
                            encoding = start;
                            start = 0;
                            end = this.length;
                        } else if ("string" === typeof end) {
                            encoding = end;
                            end = this.length;
                        }
                        if (void 0 !== encoding && "string" !== typeof encoding) throw new TypeError("encoding must be a string");
                        if ("string" === typeof encoding && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
                        if (1 === val.length) {
                            const code = val.charCodeAt(0);
                            if ("utf8" === encoding && code < 128 || "latin1" === encoding) val = code;
                        }
                    } else if ("number" === typeof val) val &= 255; else if ("boolean" === typeof val) val = Number(val);
                    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
                    if (end <= start) return this;
                    start >>>= 0;
                    end = void 0 === end ? this.length : end >>> 0;
                    if (!val) val = 0;
                    let i;
                    if ("number" === typeof val) for (i = start; i < end; ++i) this[i] = val; else {
                        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                        const len = bytes.length;
                        if (0 === len) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                        for (i = 0; i < end - start; ++i) this[i + start] = bytes[i % len];
                    }
                    return this;
                };
                const errors = {};
                function E(sym, getMessage, Base) {
                    errors[sym] = class extends Base {
                        constructor() {
                            super();
                            Object.defineProperty(this, "message", {
                                value: getMessage.apply(this, arguments),
                                writable: true,
                                configurable: true
                            });
                            this.name = this.name + ` [${sym}]`;
                            this.stack;
                            delete this.name;
                        }
                        get code() {
                            return sym;
                        }
                        set code(value) {
                            Object.defineProperty(this, "code", {
                                configurable: true,
                                enumerable: true,
                                value: value,
                                writable: true
                            });
                        }
                        toString() {
                            return this.name + ` [${sym}]: ` + this.message;
                        }
                    };
                }
                E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
                    if (name) return name + ` is outside of buffer bounds`;
                    return "Attempt to access memory outside buffer bounds";
                }, RangeError);
                E("ERR_INVALID_ARG_TYPE", function(name, actual) {
                    return `The "${name}" argument must be of type number. Received type ` + typeof actual;
                }, TypeError);
                E("ERR_OUT_OF_RANGE", function(str, range, input) {
                    let msg = `The value of "${str}" is out of range.`;
                    let received = input;
                    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input)); else if ("bigint" === typeof input) {
                        received = String(input);
                        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
                        received += "n";
                    }
                    msg += ` It must be ${range}. Received ` + received;
                    return msg;
                }, RangeError);
                function addNumericalSeparator(val) {
                    let res = "";
                    let i = val.length;
                    const start = "-" === val[0] ? 1 : 0;
                    for (;i >= start + 4; i -= 3) res = `_` + val.slice(i - 3, i) + res;
                    return `` + val.slice(0, i) + res;
                }
                function checkBounds(buf, offset, byteLength) {
                    validateNumber(offset, "offset");
                    if (void 0 === buf[offset] || void 0 === buf[offset + byteLength]) boundsError(offset, buf.length - (byteLength + 1));
                }
                function checkIntBI(value, min, max, buf, offset, byteLength) {
                    if (value > max || value < min) {
                        const n = "bigint" === typeof min ? "n" : "";
                        let range;
                        if (byteLength > 3) if (0 === min || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ` + 8 * (byteLength + 1) + n; else range = `>= -(2${n} ** ${8 * (byteLength + 1) - 1}${n}) and < 2 ** ` + `` + (8 * (byteLength + 1) - 1) + n; else range = `>= ${min}${n} and <= ` + max + n;
                        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
                    }
                    checkBounds(buf, offset, byteLength);
                }
                function validateNumber(value, name) {
                    if ("number" !== typeof value) throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
                }
                function boundsError(value, length, type) {
                    if (Math.floor(value) !== value) {
                        validateNumber(value, type);
                        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
                    }
                    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
                    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ` + length, value);
                }
                const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
                function base64clean(str) {
                    str = str.split("=")[0];
                    str = str.trim().replace(INVALID_BASE64_RE, "");
                    if (str.length < 2) return "";
                    while (str.length % 4 !== 0) str += "=";
                    return str;
                }
                function utf8ToBytes(string, units) {
                    units = units || 1 / 0;
                    let codePoint;
                    const length = string.length;
                    let leadSurrogate = null;
                    const bytes = [];
                    for (let i = 0; i < length; ++i) {
                        codePoint = string.charCodeAt(i);
                        if (codePoint > 55295 && codePoint < 57344) {
                            if (!leadSurrogate) {
                                if (codePoint > 56319) {
                                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                                    continue;
                                } else if (i + 1 === length) {
                                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                                    continue;
                                }
                                leadSurrogate = codePoint;
                                continue;
                            }
                            if (codePoint < 56320) {
                                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                                leadSurrogate = codePoint;
                                continue;
                            }
                            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                        } else if (leadSurrogate) if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        leadSurrogate = null;
                        if (codePoint < 128) {
                            if (--units < 0) break;
                            bytes.push(codePoint);
                        } else if (codePoint < 2048) {
                            if ((units -= 2) < 0) break;
                            bytes.push(codePoint >> 6 | 192, 63 & codePoint | 128);
                        } else if (codePoint < 65536) {
                            if ((units -= 3) < 0) break;
                            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
                        } else if (codePoint < 1114112) {
                            if ((units -= 4) < 0) break;
                            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
                        } else throw new Error("Invalid code point");
                    }
                    return bytes;
                }
                function asciiToBytes(str) {
                    const byteArray = [];
                    for (let i = 0; i < str.length; ++i) byteArray.push(255 & str.charCodeAt(i));
                    return byteArray;
                }
                function utf16leToBytes(str, units) {
                    let c, hi, lo;
                    const byteArray = [];
                    for (let i = 0; i < str.length; ++i) {
                        if ((units -= 2) < 0) break;
                        c = str.charCodeAt(i);
                        hi = c >> 8;
                        lo = c % 256;
                        byteArray.push(lo);
                        byteArray.push(hi);
                    }
                    return byteArray;
                }
                function base64ToBytes(str) {
                    return base64.toByteArray(base64clean(str));
                }
                function blitBuffer(src, dst, offset, length) {
                    let i;
                    for (i = 0; i < length; ++i) {
                        if (i + offset >= dst.length || i >= src.length) break;
                        dst[i + offset] = src[i];
                    }
                    return i;
                }
                function isInstance(obj, type) {
                    return obj instanceof type || null != obj && null != obj.constructor && null != obj.constructor.name && obj.constructor.name === type.name;
                }
                function numberIsNaN(obj) {
                    return obj !== obj;
                }
                const hexSliceLookupTable = function() {
                    const alphabet = "0123456789abcdef";
                    const table = new Array(256);
                    for (let i = 0; i < 16; ++i) {
                        const i16 = 16 * i;
                        for (let j = 0; j < 16; ++j) table[i16 + j] = alphabet[i] + alphabet[j];
                    }
                    return table;
                }();
                function defineBigIntMethod(fn) {
                    return "undefined" === typeof BigInt ? BufferBigIntNotDefined : fn;
                }
                function BufferBigIntNotDefined() {
                    throw new Error("BigInt not supported");
                }
            },
            "./node_modules/events/events.js": module => {
                "use strict";
                var R = "object" === typeof Reflect ? Reflect : null;
                var ReflectApply = R && "function" === typeof R.apply ? R.apply : function(target, receiver, args) {
                    return Function.prototype.apply.call(target, receiver, args);
                };
                var ReflectOwnKeys;
                if (R && "function" === typeof R.ownKeys) ReflectOwnKeys = R.ownKeys; else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function(target) {
                    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                }; else ReflectOwnKeys = function(target) {
                    return Object.getOwnPropertyNames(target);
                };
                function ProcessEmitWarning(warning) {
                    if (console && console.warn) console.warn(warning);
                }
                var NumberIsNaN = Number.isNaN || function(value) {
                    return value !== value;
                };
                function EventEmitter() {
                    EventEmitter.init.call(this);
                }
                module.exports = EventEmitter;
                module.exports.once = once;
                EventEmitter.EventEmitter = EventEmitter;
                EventEmitter.prototype._events = void 0;
                EventEmitter.prototype._eventsCount = 0;
                EventEmitter.prototype._maxListeners = void 0;
                var defaultMaxListeners = 10;
                function checkListener(listener) {
                    if ("function" !== typeof listener) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                }
                Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                    enumerable: true,
                    get: function() {
                        return defaultMaxListeners;
                    },
                    set: function(arg) {
                        if ("number" !== typeof arg || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                        defaultMaxListeners = arg;
                    }
                });
                EventEmitter.init = function() {
                    if (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) {
                        this._events = Object.create(null);
                        this._eventsCount = 0;
                    }
                    this._maxListeners = this._maxListeners || void 0;
                };
                EventEmitter.prototype.setMaxListeners = function(n) {
                    if ("number" !== typeof n || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                    this._maxListeners = n;
                    return this;
                };
                function _getMaxListeners(that) {
                    if (void 0 === that._maxListeners) return EventEmitter.defaultMaxListeners;
                    return that._maxListeners;
                }
                EventEmitter.prototype.getMaxListeners = function() {
                    return _getMaxListeners(this);
                };
                EventEmitter.prototype.emit = function(type) {
                    var args = [];
                    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
                    var doError = "error" === type;
                    var events = this._events;
                    if (void 0 !== events) doError = doError && void 0 === events.error; else if (!doError) return false;
                    if (doError) {
                        if (args.length > 0) er = args[0];
                        if (er instanceof Error) throw er;
                        doError = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                        doError.context = er;
                        throw doError;
                    }
                    var er = events[type];
                    if (void 0 === er) return false;
                    if ("function" === typeof er) ReflectApply(er, this, args); else {
                        var len = er.length;
                        var listeners = arrayClone(er, len);
                        for (i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
                    }
                    return true;
                };
                function _addListener(target, type, listener, prepend) {
                    var events;
                    var existing;
                    checkListener(listener);
                    events = target._events;
                    if (void 0 === events) {
                        events = target._events = Object.create(null);
                        target._eventsCount = 0;
                    } else {
                        if (void 0 !== events.newListener) {
                            target.emit("newListener", type, listener.listener ? listener.listener : listener);
                            events = target._events;
                        }
                        existing = events[type];
                    }
                    if (void 0 === existing) {
                        existing = events[type] = listener;
                        ++target._eventsCount;
                    } else {
                        if ("function" === typeof existing) existing = events[type] = prepend ? [ listener, existing ] : [ existing, listener ]; else if (prepend) existing.unshift(listener); else existing.push(listener);
                        events = _getMaxListeners(target);
                        if (events > 0 && existing.length > events && !existing.warned) {
                            existing.warned = true;
                            prepend = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
                            prepend.name = "MaxListenersExceededWarning";
                            prepend.emitter = target;
                            prepend.type = type;
                            prepend.count = existing.length;
                            ProcessEmitWarning(prepend);
                        }
                    }
                    return target;
                }
                EventEmitter.prototype.addListener = function(type, listener) {
                    return _addListener(this, type, listener, false);
                };
                EventEmitter.prototype.on = EventEmitter.prototype.addListener;
                EventEmitter.prototype.prependListener = function(type, listener) {
                    return _addListener(this, type, listener, true);
                };
                function onceWrapper() {
                    if (!this.fired) {
                        this.target.removeListener(this.type, this.wrapFn);
                        this.fired = true;
                        if (0 === arguments.length) return this.listener.call(this.target);
                        return this.listener.apply(this.target, arguments);
                    }
                }
                function _onceWrap(target, type, listener) {
                    target = {
                        fired: false,
                        wrapFn: void 0,
                        target: target,
                        type: type,
                        listener: listener
                    };
                    type = onceWrapper.bind(target);
                    type.listener = listener;
                    target.wrapFn = type;
                    return type;
                }
                EventEmitter.prototype.once = function(type, listener) {
                    checkListener(listener);
                    this.on(type, _onceWrap(this, type, listener));
                    return this;
                };
                EventEmitter.prototype.prependOnceListener = function(type, listener) {
                    checkListener(listener);
                    this.prependListener(type, _onceWrap(this, type, listener));
                    return this;
                };
                EventEmitter.prototype.removeListener = function(type, listener) {
                    var list, events, position, i, originalListener;
                    checkListener(listener);
                    events = this._events;
                    if (void 0 === events) return this;
                    list = events[type];
                    if (void 0 === list) return this;
                    if (list === listener || list.listener === listener) if (0 === --this._eventsCount) this._events = Object.create(null); else {
                        delete events[type];
                        if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
                    } else if ("function" !== typeof list) {
                        position = -1;
                        for (i = list.length - 1; i >= 0; i--) if (list[i] === listener || list[i].listener === listener) {
                            originalListener = list[i].listener;
                            position = i;
                            break;
                        }
                        if (position < 0) return this;
                        if (0 === position) list.shift(); else spliceOne(list, position);
                        if (1 === list.length) events[type] = list[0];
                        if (void 0 !== events.removeListener) this.emit("removeListener", type, originalListener || listener);
                    }
                    return this;
                };
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.removeAllListeners = function(type) {
                    var listeners, events, i;
                    events = this._events;
                    if (void 0 === events) return this;
                    if (void 0 === events.removeListener) {
                        if (0 === arguments.length) {
                            this._events = Object.create(null);
                            this._eventsCount = 0;
                        } else if (void 0 !== events[type]) if (0 === --this._eventsCount) this._events = Object.create(null); else delete events[type];
                        return this;
                    }
                    if (0 === arguments.length) {
                        var keys = Object.keys(events);
                        var key;
                        for (i = 0; i < keys.length; ++i) {
                            key = keys[i];
                            if ("removeListener" === key) continue;
                            this.removeAllListeners(key);
                        }
                        this.removeAllListeners("removeListener");
                        this._events = Object.create(null);
                        this._eventsCount = 0;
                        return this;
                    }
                    listeners = events[type];
                    if ("function" === typeof listeners) this.removeListener(type, listeners); else if (void 0 !== listeners) for (i = listeners.length - 1; i >= 0; i--) this.removeListener(type, listeners[i]);
                    return this;
                };
                function _listeners(target, type, unwrap) {
                    target = target._events;
                    if (void 0 === target) return [];
                    target = target[type];
                    if (void 0 === target) return [];
                    if ("function" === typeof target) return unwrap ? [ target.listener || target ] : [ target ];
                    return unwrap ? unwrapListeners(target) : arrayClone(target, target.length);
                }
                EventEmitter.prototype.listeners = function(type) {
                    return _listeners(this, type, true);
                };
                EventEmitter.prototype.rawListeners = function(type) {
                    return _listeners(this, type, false);
                };
                EventEmitter.listenerCount = function(emitter, type) {
                    if ("function" === typeof emitter.listenerCount) return emitter.listenerCount(type); else return listenerCount.call(emitter, type);
                };
                EventEmitter.prototype.listenerCount = listenerCount;
                function listenerCount(type) {
                    var events = this._events;
                    if (void 0 !== events) {
                        events = events[type];
                        if ("function" === typeof events) return 1; else if (void 0 !== events) return events.length;
                    }
                    return 0;
                }
                EventEmitter.prototype.eventNames = function() {
                    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
                };
                function arrayClone(arr, n) {
                    var copy = new Array(n);
                    for (var i = 0; i < n; ++i) copy[i] = arr[i];
                    return copy;
                }
                function spliceOne(list, index) {
                    for (;index + 1 < list.length; index++) list[index] = list[index + 1];
                    list.pop();
                }
                function unwrapListeners(arr) {
                    var ret = new Array(arr.length);
                    for (var i = 0; i < ret.length; ++i) ret[i] = arr[i].listener || arr[i];
                    return ret;
                }
                function once(emitter, name) {
                    return new Promise(function(resolve, reject) {
                        function errorListener(err) {
                            emitter.removeListener(name, resolver);
                            reject(err);
                        }
                        function resolver() {
                            if ("function" === typeof emitter.removeListener) emitter.removeListener("error", errorListener);
                            resolve([].slice.call(arguments));
                        }
                        eventTargetAgnosticAddListener(emitter, name, resolver, {
                            once: true
                        });
                        if ("error" !== name) addErrorHandlerIfEventEmitter(emitter, errorListener, {
                            once: true
                        });
                    });
                }
                function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                    if ("function" === typeof emitter.on) eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                }
                function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                    if ("function" === typeof emitter.on) if (flags.once) emitter.once(name, listener); else emitter.on(name, listener); else if ("function" === typeof emitter.addEventListener) emitter.addEventListener(name, function wrapListener(arg) {
                        if (flags.once) emitter.removeEventListener(name, wrapListener);
                        listener(arg);
                    }); else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                }
            },
            "./node_modules/fflate/lib/browser.cjs": (__unused_webpack_module, exports) => {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var ch2 = {};
                var node_worker_1 = {};
                node_worker_1["default"] = function(c, id, msg, transfer, cb) {
                    id = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([ c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})' ], {
                        type: "text/javascript"
                    }))));
                    id.onmessage = function(e) {
                        var e = e.data, ed = e.$e$;
                        if (ed) {
                            var err = new Error(ed[0]);
                            err["code"] = ed[1];
                            err.stack = ed[2];
                            cb(err, null);
                        } else cb(null, e);
                    };
                    id.postMessage(msg, transfer);
                    return id;
                };
                var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
                var fleb = new u8([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0 ]);
                var fdeb = new u8([ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0 ]);
                var clim = new u8([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);
                var freb = function(eb, start) {
                    var b = new u16(31);
                    for (var i = 0; i < 31; ++i) b[i] = start += 1 << eb[i - 1];
                    var r = new i32(b[30]);
                    for (i = 1; i < 30; ++i) for (var j = b[i]; j < b[i + 1]; ++j) r[j] = j - b[i] << 5 | i;
                    return {
                        b: b,
                        r: r
                    };
                };
                var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
                fl[28] = 258, revfl[258] = 28;
                var _a = freb(fdeb, 0), fd = _a.b, revfd = _a.r;
                var rev = new u16(32768);
                for (var i = 0; i < 32768; ++i) {
                    var x = (43690 & i) >> 1 | (21845 & i) << 1;
                    x = (52428 & x) >> 2 | (13107 & x) << 2;
                    x = (61680 & x) >> 4 | (3855 & x) << 4;
                    rev[i] = ((65280 & x) >> 8 | (255 & x) << 8) >> 1;
                }
                var hMap = function(cd, mb, r) {
                    var s = cd.length;
                    var i = 0;
                    var l = new u16(mb);
                    for (;i < s; ++i) if (cd[i]) ++l[cd[i] - 1];
                    var le = new u16(mb);
                    for (i = 1; i < mb; ++i) le[i] = le[i - 1] + l[i - 1] << 1;
                    var co;
                    if (r) {
                        co = new u16(1 << mb);
                        var rvb = 15 - mb;
                        for (i = 0; i < s; ++i) if (cd[i]) {
                            var sv = i << 4 | cd[i];
                            var r_1 = mb - cd[i];
                            var v = le[cd[i] - 1]++ << r_1;
                            for (var m = v | (1 << r_1) - 1; v <= m; ++v) co[rev[v] >> rvb] = sv;
                        }
                    } else {
                        co = new u16(s);
                        for (i = 0; i < s; ++i) if (cd[i]) co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
                    }
                    return co;
                };
                var flt = new u8(288);
                for (i = 0; i < 144; ++i) flt[i] = 8;
                for (i = 144; i < 256; ++i) flt[i] = 9;
                for (i = 256; i < 280; ++i) flt[i] = 7;
                for (i = 280; i < 288; ++i) flt[i] = 8;
                var fdt = new u8(32);
                for (i = 0; i < 32; ++i) fdt[i] = 5;
                var flm = hMap(flt, 9, 0), flrm = hMap(flt, 9, 1);
                var fdm = hMap(fdt, 5, 0), fdrm = hMap(fdt, 5, 1);
                var max = function(a) {
                    var m = a[0];
                    for (var i = 1; i < a.length; ++i) if (a[i] > m) m = a[i];
                    return m;
                };
                var bits = function(d, p, m) {
                    var o = p / 8 | 0;
                    return (d[o] | d[o + 1] << 8) >> (7 & p) & m;
                };
                var bits16 = function(d, p) {
                    var o = p / 8 | 0;
                    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (7 & p);
                };
                var shft = function(p) {
                    return (p + 7) / 8 | 0;
                };
                var slc = function(v, s, e) {
                    if (null == s || s < 0) s = 0;
                    if (null == e || e > v.length) e = v.length;
                    return new u8(v.subarray(s, e));
                };
                exports.FlateErrorCode = {
                    UnexpectedEOF: 0,
                    InvalidBlockType: 1,
                    InvalidLengthLiteral: 2,
                    InvalidDistance: 3,
                    StreamFinished: 4,
                    NoStreamHandler: 5,
                    InvalidHeader: 6,
                    NoCallback: 7,
                    InvalidUTF8: 8,
                    ExtraFieldTooLong: 9,
                    InvalidDate: 10,
                    FilenameTooLong: 11,
                    StreamFinishing: 12,
                    InvalidZipData: 13,
                    UnknownCompressionMethod: 14
                };
                var ec = [ "unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data" ];
                var err = function(ind, msg, nt) {
                    msg = new Error(msg || ec[ind]);
                    msg.code = ind;
                    if (Error.captureStackTrace) Error.captureStackTrace(msg, err);
                    if (!nt) throw msg;
                    return msg;
                };
                var inflt = function(dat, st, buf, dict) {
                    var sl = dat.length, dl = dict ? dict.length : 0;
                    if (!sl || st.f && !st.l) return buf || new u8(0);
                    var noBuf = !buf;
                    var resize = noBuf || 2 != st.i;
                    var noSt = st.i;
                    if (noBuf) buf = new u8(3 * sl);
                    var cbuf = function(l) {
                        var bl = buf.length;
                        if (l > bl) {
                            bl = new u8(Math.max(2 * bl, l));
                            bl.set(buf);
                            buf = bl;
                        }
                    };
                    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
                    var tbts = 8 * sl;
                    do {
                        if (!lm) {
                            final = bits(dat, pos, 1);
                            var type = bits(dat, pos + 1, 3);
                            pos += 3;
                            if (!type) {
                                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
                                if (t > sl) {
                                    if (noSt) err(0);
                                    break;
                                }
                                if (resize) cbuf(bt + l);
                                buf.set(dat.subarray(s, t), bt);
                                st.b = bt += l, st.p = pos = 8 * t, st.f = final;
                                continue;
                            } else if (1 == type) lm = flrm, dm = fdrm, lbt = 9, 
                            dbt = 5; else if (2 == type) {
                                var l = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                                var tl = l + bits(dat, pos + 5, 31) + 1;
                                pos += 14;
                                var ldt = new u8(tl);
                                var clt = new u8(19);
                                for (var i = 0; i < hcLen; ++i) clt[clim[i]] = bits(dat, pos + 3 * i, 7);
                                pos += 3 * hcLen;
                                var t = max(clt), clbmsk = (1 << t) - 1;
                                var clm = hMap(clt, t, 1);
                                for (i = 0; i < tl; ) {
                                    var r = clm[bits(dat, pos, clbmsk)];
                                    pos += 15 & r;
                                    s = r >> 4;
                                    if (s < 16) ldt[i++] = s; else {
                                        var c = 0, n = 0;
                                        if (16 == s) n = 3 + bits(dat, pos, 3), 
                                        pos += 2, c = ldt[i - 1]; else if (17 == s) n = 3 + bits(dat, pos, 7), 
                                        pos += 3; else if (18 == s) n = 11 + bits(dat, pos, 127), 
                                        pos += 7;
                                        while (n--) ldt[i++] = c;
                                    }
                                }
                                var type = ldt.subarray(0, l), dt = ldt.subarray(l);
                                lbt = max(type);
                                dbt = max(dt);
                                lm = hMap(type, lbt, 1);
                                dm = hMap(dt, dbt, 1);
                            } else err(1);
                            if (pos > tbts) {
                                if (noSt) err(0);
                                break;
                            }
                        }
                        if (resize) cbuf(bt + 131072);
                        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
                        var lpos = pos;
                        for (;;lpos = pos) {
                            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
                            pos += 15 & c;
                            if (pos > tbts) {
                                if (noSt) err(0);
                                break;
                            }
                            if (!c) err(2);
                            if (sym < 256) buf[bt++] = sym; else if (256 == sym) {
                                lpos = pos, lm = null;
                                break;
                            } else {
                                var add = sym - 254;
                                if (sym > 264) {
                                    var i = sym - 257, b = fleb[i];
                                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                                    pos += b;
                                }
                                var sym = dm[bits16(dat, pos) & dms], dsym = sym >> 4;
                                if (!sym) err(3);
                                pos += 15 & sym;
                                dt = fd[dsym];
                                if (dsym > 3) {
                                    b = fdeb[dsym];
                                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                                }
                                if (pos > tbts) {
                                    if (noSt) err(0);
                                    break;
                                }
                                if (resize) cbuf(bt + 131072);
                                var end = bt + add;
                                if (bt < dt) {
                                    var shift = dl - dt, dend = Math.min(dt, end);
                                    if (shift + bt < 0) err(3);
                                    for (;bt < dend; ++bt) buf[bt] = dict[shift + bt];
                                }
                                for (;bt < end; ++bt) buf[bt] = buf[bt - dt];
                            }
                        }
                        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
                        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
                    } while (!final);
                    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
                };
                var wbits = function(d, p, v) {
                    v <<= 7 & p;
                    p = p / 8 | 0;
                    d[p] |= v;
                    d[p + 1] |= v >> 8;
                };
                var wbits16 = function(d, p, v) {
                    v <<= 7 & p;
                    p = p / 8 | 0;
                    d[p] |= v;
                    d[p + 1] |= v >> 8;
                    d[p + 2] |= v >> 16;
                };
                var hTree = function(d, mb) {
                    var t = [];
                    for (var i = 0; i < d.length; ++i) if (d[i]) t.push({
                        s: i,
                        f: d[i]
                    });
                    var s = t.length;
                    var t2 = t.slice();
                    if (!s) return {
                        t: et,
                        l: 0
                    };
                    if (1 == s) {
                        var v = new u8(t[0].s + 1);
                        v[t[0].s] = 1;
                        return {
                            t: v,
                            l: 1
                        };
                    }
                    t.sort(function(a, b) {
                        return a.f - b.f;
                    });
                    t.push({
                        s: -1,
                        f: 25001
                    });
                    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
                    t[0] = {
                        s: -1,
                        f: l.f + r.f,
                        l: l,
                        r: r
                    };
                    while (i1 != s - 1) {
                        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
                        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
                        t[i1++] = {
                            s: -1,
                            f: l.f + r.f,
                            l: l,
                            r: r
                        };
                    }
                    var maxSym = t2[0].s;
                    for (i = 1; i < s; ++i) if (t2[i].s > maxSym) maxSym = t2[i].s;
                    var tr = new u16(maxSym + 1);
                    var mbt = ln(t[i1 - 1], tr, 0);
                    if (mbt > mb) {
                        var i = 0, dt = 0;
                        var v = mbt - mb, cst = 1 << v;
                        t2.sort(function(a, b) {
                            return tr[b.s] - tr[a.s] || a.f - b.f;
                        });
                        for (;i < s; ++i) {
                            var i2_1 = t2[i].s;
                            if (tr[i2_1] > mb) {
                                dt += cst - (1 << mbt - tr[i2_1]);
                                tr[i2_1] = mb;
                            } else break;
                        }
                        dt >>= v;
                        while (dt > 0) {
                            var i2_2 = t2[i].s;
                            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1; else ++i;
                        }
                        for (;i >= 0 && dt; --i) {
                            var i2_3 = t2[i].s;
                            if (tr[i2_3] == mb) {
                                --tr[i2_3];
                                ++dt;
                            }
                        }
                        mbt = mb;
                    }
                    return {
                        t: new u8(tr),
                        l: mbt
                    };
                };
                var ln = function(n, l, d) {
                    return -1 == n.s ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
                };
                var lc = function(c) {
                    var s = c.length;
                    while (s && !c[--s]);
                    var cl = new u16(++s);
                    var cli = 0, cln = c[0], cls = 1;
                    var w = function(v) {
                        cl[cli++] = v;
                    };
                    for (var i = 1; i <= s; ++i) if (c[i] == cln && i != s) ++cls; else {
                        if (!cln && cls > 2) {
                            for (;cls > 138; cls -= 138) w(32754);
                            if (cls > 2) {
                                w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
                                cls = 0;
                            }
                        } else if (cls > 3) {
                            w(cln), --cls;
                            for (;cls > 6; cls -= 6) w(8304);
                            if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
                        }
                        while (cls--) w(cln);
                        cls = 1;
                        cln = c[i];
                    }
                    return {
                        c: cl.subarray(0, cli),
                        n: s
                    };
                };
                var clen = function(cf, cl) {
                    var l = 0;
                    for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];
                    return l;
                };
                var wfblk = function(out, pos, dat) {
                    var s = dat.length;
                    var o = shft(pos + 2);
                    out[o] = 255 & s;
                    out[o + 1] = s >> 8;
                    out[o + 2] = 255 ^ out[o];
                    out[o + 3] = 255 ^ out[o + 1];
                    for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];
                    return 8 * (o + 4 + s);
                };
                var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
                    wbits(out, p++, final);
                    ++lf[256];
                    var final = hTree(lf, 15), dlt = final.t, final = final.l;
                    var _b = hTree(df, 15), ddt = _b.t, _b = _b.l;
                    var _c = lc(dlt), lclt = _c.c, _c = _c.n;
                    var _d = lc(ddt), lcdt = _d.c, _d = _d.n;
                    var lcfreq = new u16(19);
                    for (var i = 0; i < lclt.length; ++i) ++lcfreq[31 & lclt[i]];
                    for (i = 0; i < lcdt.length; ++i) ++lcfreq[31 & lcdt[i]];
                    var _e = hTree(lcfreq, 7), lct = _e.t, _e = _e.l;
                    var nlcc = 19;
                    for (;nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);
                    var flen = bl + 5 << 3;
                    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
                    lf = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
                    if (bs >= 0 && flen <= ftlen && flen <= lf) return wfblk(out, p, dat.subarray(bs, bs + bl));
                    var lm, ll, dm, dl;
                    wbits(out, p, 1 + (lf < ftlen)), p += 2;
                    if (lf < ftlen) {
                        lm = hMap(dlt, final, 0), ll = dlt, dm = hMap(ddt, _b, 0), 
                        dl = ddt;
                        var llm = hMap(lct, _e, 0);
                        wbits(out, p, _c - 257);
                        wbits(out, p + 5, _d - 1);
                        wbits(out, p + 10, nlcc - 4);
                        p += 14;
                        for (i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);
                        p += 3 * nlcc;
                        var lcts = [ lclt, lcdt ];
                        for (var it = 0; it < 2; ++it) {
                            var clct = lcts[it];
                            for (i = 0; i < clct.length; ++i) {
                                var len = 31 & clct[i];
                                wbits(out, p, llm[len]), p += lct[len];
                                if (len > 15) wbits(out, p, clct[i] >> 5 & 127), 
                                p += clct[i] >> 12;
                            }
                        }
                    } else lm = flm, ll = flt, dm = fdm, dl = fdt;
                    for (i = 0; i < li; ++i) {
                        var sym = syms[i];
                        if (sym > 255) {
                            len = sym >> 18 & 31;
                            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
                            if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];
                            var dst = 31 & sym;
                            wbits16(out, p, dm[dst]), p += dl[dst];
                            if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
                        } else wbits16(out, p, lm[sym]), p += ll[sym];
                    }
                    wbits16(out, p, lm[256]);
                    return p + ll[256];
                };
                var deo = new i32([ 65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632 ]);
                var et = new u8(0);
                var dflt = function(dat, lvl, plvl, pre, post, st) {
                    var s = st.z || dat.length;
                    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
                    var w = o.subarray(pre, o.length - post);
                    var lst = st.l;
                    var pos = 7 & (st.r || 0);
                    if (lvl) {
                        if (pos) w[0] = st.r >> 3;
                        lvl = deo[lvl - 1];
                        var n = lvl >> 13, c = 8191 & lvl;
                        var msk_1 = (1 << plvl) - 1;
                        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
                        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
                        var hsh = function(i) {
                            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
                        };
                        var syms = new i32(25e3);
                        var lf = new u16(288), df = new u16(32);
                        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
                        for (;i + 2 < s; ++i) {
                            var hv = hsh(i);
                            var imod = 32767 & i, pimod = head[hv];
                            prev[imod] = pimod;
                            head[hv] = imod;
                            if (wi <= i) {
                                var rem = s - i;
                                if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
                                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                                    li = lc_1 = eb = 0, bs = i;
                                    for (var j = 0; j < 286; ++j) lf[j] = 0;
                                    for (j = 0; j < 30; ++j) df[j] = 0;
                                }
                                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                                if (rem > 2 && hv == hsh(i - dif)) {
                                    var maxn = Math.min(n, rem) - 1;
                                    var maxd = Math.min(32767, i);
                                    var ml = Math.min(258, rem);
                                    while (dif <= maxd && --ch_1 && imod != pimod) {
                                        if (dat[i + l] == dat[i + l - dif]) {
                                            var nl = 0;
                                            for (;nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);
                                            if (nl > l) {
                                                l = nl, d = dif;
                                                if (nl > maxn) break;
                                                var mmd = Math.min(dif, nl - 2);
                                                var md = 0;
                                                for (j = 0; j < mmd; ++j) {
                                                    var ti = i - dif + j & 32767;
                                                    var pti = prev[ti];
                                                    pti = ti - pti & 32767;
                                                    if (pti > md) md = pti, pimod = ti;
                                                }
                                            }
                                        }
                                        imod = pimod, pimod = prev[imod];
                                        dif += imod - pimod & 32767;
                                    }
                                }
                                if (d) {
                                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
                                    hv = 31 & revfl[l], rem = 31 & revfd[d];
                                    eb += fleb[hv] + fdeb[rem];
                                    ++lf[257 + hv];
                                    ++df[rem];
                                    wi = i + l;
                                    ++lc_1;
                                } else {
                                    syms[li++] = dat[i];
                                    ++lf[dat[i]];
                                }
                            }
                        }
                        for (i = Math.max(i, wi); i < s; ++i) {
                            syms[li++] = dat[i];
                            ++lf[dat[i]];
                        }
                        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
                        if (!lst) {
                            st.r = 7 & pos | w[pos / 8 | 0] << 3;
                            pos -= 7;
                            st.h = head, st.p = prev, st.i = i, st.w = wi;
                        }
                    } else {
                        for (i = st.w || 0; i < s + lst; i += 65535) {
                            var e = i + 65535;
                            if (e >= s) {
                                w[pos / 8 | 0] = lst;
                                e = s;
                            }
                            pos = wfblk(w, pos + 1, dat.subarray(i, e));
                        }
                        st.i = s;
                    }
                    return slc(o, 0, pre + shft(pos) + post);
                };
                var crct = function() {
                    var t = new Int32Array(256);
                    for (var i = 0; i < 256; ++i) {
                        var c = i, k = 9;
                        while (--k) c = (1 & c && -306674912) ^ c >>> 1;
                        t[i] = c;
                    }
                    return t;
                }();
                var crc = function() {
                    var c = -1;
                    return {
                        p: function(d) {
                            var cr = c;
                            for (var i = 0; i < d.length; ++i) cr = crct[255 & cr ^ d[i]] ^ cr >>> 8;
                            c = cr;
                        },
                        d: function() {
                            return ~c;
                        }
                    };
                };
                var adler = function() {
                    var a = 1, b = 0;
                    return {
                        p: function(d) {
                            var n = a, m = b;
                            var l = 0 | d.length;
                            for (var i = 0; i != l; ) {
                                var e = Math.min(i + 2655, l);
                                for (;i < e; ++i) m += n += d[i];
                                n = (65535 & n) + 15 * (n >> 16), m = (65535 & m) + 15 * (m >> 16);
                            }
                            a = n, b = m;
                        },
                        d: function() {
                            a %= 65521, b %= 65521;
                            return (255 & a) << 24 | (65280 & a) << 8 | (255 & b) << 8 | b >> 8;
                        }
                    };
                };
                var dopt = function(dat, opt, pre, post, st) {
                    if (!st) {
                        st = {
                            l: 1
                        };
                        if (opt.dictionary) {
                            var dict = opt.dictionary.subarray(-32768);
                            var newDat = new u8(dict.length + dat.length);
                            newDat.set(dict);
                            newDat.set(dat, dict.length);
                            dat = newDat;
                            st.w = dict.length;
                        }
                    }
                    return dflt(dat, null == opt.level ? 6 : opt.level, null == opt.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(dat.length)))) : 12 + opt.mem, pre, post, st);
                };
                var mrg = function(a, b) {
                    var o = {};
                    for (var k in a) o[k] = a[k];
                    for (var k in b) o[k] = b[k];
                    return o;
                };
                var wcln = function(fn, fnStr, td) {
                    var dt = fn();
                    fn = fn.toString();
                    var ks = fn.slice(fn.indexOf("[") + 1, fn.lastIndexOf("]")).replace(/\s+/g, "").split(",");
                    for (var i = 0; i < dt.length; ++i) {
                        var v = dt[i], k = ks[i];
                        if ("function" == typeof v) {
                            fnStr += ";" + k + "=";
                            var st_1 = v.toString();
                            if (v.prototype) if (-1 != st_1.indexOf("[native code]")) {
                                var spInd = st_1.indexOf(" ", 8) + 1;
                                fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
                            } else {
                                fnStr += st_1;
                                for (var t in v.prototype) fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
                            } else fnStr += st_1;
                        } else td[k] = v;
                    }
                    return fnStr;
                };
                var ch = [];
                var cbfs = function(v) {
                    var tl = [];
                    for (var k in v) if (v[k].buffer) tl.push((v[k] = new v[k].constructor(v[k])).buffer);
                    return tl;
                };
                var wrkr = function(fns, init, id, cb) {
                    if (!ch[id]) {
                        var fnStr = "", td_1 = {}, m = fns.length - 1;
                        for (var i = 0; i < m; ++i) fnStr = wcln(fns[i], fnStr, td_1);
                        ch[id] = {
                            c: wcln(fns[m], fnStr, td_1),
                            e: td_1
                        };
                    }
                    var td = mrg({}, ch[id].e);
                    return (0, node_worker_1.default)(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td, cbfs(td), cb);
                };
                var bInflt = function() {
                    return [ u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt ];
                };
                var bDflt = function() {
                    return [ u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf ];
                };
                var gze = function() {
                    return [ gzh, gzhl, wbytes, crc, crct ];
                };
                var guze = function() {
                    return [ gzs, gzl ];
                };
                var zle = function() {
                    return [ zlh, wbytes, adler ];
                };
                var zule = function() {
                    return [ zls ];
                };
                var pbf = function(msg) {
                    return postMessage(msg, [ msg.buffer ]);
                };
                var gopt = function(o) {
                    return o && {
                        out: o.size && new u8(o.size),
                        dictionary: o.dictionary
                    };
                };
                var cbify = function(dat, opts, fns, init, id, cb) {
                    var w = wrkr(fns, init, id, function(err, dat) {
                        w.terminate();
                        cb(err, dat);
                    });
                    w.postMessage([ dat, opts ], opts.consume ? [ dat.buffer ] : []);
                    return function() {
                        w.terminate();
                    };
                };
                var astrm = function(strm) {
                    strm.ondata = function(dat, final) {
                        return postMessage([ dat, final ], [ dat.buffer ]);
                    };
                    return function(ev) {
                        return strm.push(ev.data[0], ev.data[1]);
                    };
                };
                var astrmify = function(fns, strm, opts, init, id, ext) {
                    var t;
                    var w = wrkr(fns, init, id, function(err, dat) {
                        if (err) w.terminate(), strm.ondata.call(strm, err); else if (!Array.isArray(dat)) ext(dat); else {
                            if (dat[1]) w.terminate();
                            strm.ondata.call(strm, err, dat[0], dat[1]);
                        }
                    });
                    w.postMessage(opts);
                    strm.push = function(d, f) {
                        if (!strm.ondata) err(5);
                        if (t) strm.ondata(err(4, 0, 1), null, !!f);
                        w.postMessage([ d, t = f ], [ d.buffer ]);
                    };
                    strm.terminate = function() {
                        w.terminate();
                    };
                };
                var b2 = function(d, b) {
                    return d[b] | d[b + 1] << 8;
                };
                var b4 = function(d, b) {
                    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
                };
                var b8 = function(d, b) {
                    return b4(d, b) + 4294967296 * b4(d, b + 4);
                };
                var wbytes = function(d, b, v) {
                    for (;v; ++b) d[b] = v, v >>>= 8;
                };
                var gzh = function(c, o) {
                    var fn = o.filename;
                    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : 9 == o.level ? 2 : 0, 
                    c[9] = 3;
                    if (0 != o.mtime) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
                    if (fn) {
                        c[3] = 8;
                        for (var i = 0; i <= fn.length; ++i) c[i + 10] = fn.charCodeAt(i);
                    }
                };
                var gzs = function(d) {
                    if (31 != d[0] || 139 != d[1] || 8 != d[2]) err(6, "invalid gzip data");
                    var flg = d[3];
                    var st = 10;
                    if (4 & flg) st += (d[10] | d[11] << 8) + 2;
                    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);
                    return st + (2 & flg);
                };
                var gzl = function(d) {
                    var l = d.length;
                    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
                };
                var gzhl = function(o) {
                    return 10 + (o.filename ? o.filename.length + 1 : 0);
                };
                var zlh = function(c, o) {
                    var lv = o.level, lv = 0 == lv ? 0 : lv < 6 ? 1 : 9 == lv ? 3 : 2;
                    c[0] = 120, c[1] = lv << 6 | (o.dictionary && 32);
                    c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
                    if (o.dictionary) {
                        lv = adler();
                        lv.p(o.dictionary);
                        wbytes(c, 2, lv.d());
                    }
                };
                var zls = function(d, dict) {
                    if (8 != (15 & d[0]) || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31) err(6, "invalid zlib data");
                    if ((d[1] >> 5 & 1) == +!dict) err(6, "invalid zlib data: " + (32 & d[1] ? "need" : "unexpected") + " dictionary");
                    return (d[1] >> 3 & 4) + 2;
                };
                function StrmOpt(opts, cb) {
                    if ("function" == typeof opts) cb = opts, opts = {};
                    this.ondata = cb;
                    return opts;
                }
                var Deflate = function() {
                    function Deflate(opts, cb) {
                        if ("function" == typeof opts) cb = opts, opts = {};
                        this.ondata = cb;
                        this.o = opts || {};
                        this.s = {
                            l: 0,
                            i: 32768,
                            w: 32768,
                            z: 32768
                        };
                        this.b = new u8(98304);
                        if (this.o.dictionary) {
                            cb = this.o.dictionary.subarray(-32768);
                            this.b.set(cb, 32768 - cb.length);
                            this.s.i = 32768 - cb.length;
                        }
                    }
                    Deflate.prototype.p = function(c, f) {
                        this.ondata(dopt(c, this.o, 0, 0, this.s), f);
                    };
                    Deflate.prototype.push = function(chunk, final) {
                        if (!this.ondata) err(5);
                        if (this.s.l) err(4);
                        var endLen = chunk.length + this.s.z;
                        if (endLen > this.b.length) {
                            if (endLen > 2 * this.b.length - 32768) {
                                endLen = new u8(-32768 & endLen);
                                endLen.set(this.b.subarray(0, this.s.z));
                                this.b = endLen;
                            }
                            endLen = this.b.length - this.s.z;
                            if (endLen) {
                                this.b.set(chunk.subarray(0, endLen), this.s.z);
                                this.s.z = this.b.length;
                                this.p(this.b, false);
                            }
                            this.b.set(this.b.subarray(-32768));
                            this.b.set(chunk.subarray(endLen), 32768);
                            this.s.z = chunk.length - endLen + 32768;
                            this.s.i = 32766, this.s.w = 32768;
                        } else {
                            this.b.set(chunk, this.s.z);
                            this.s.z += chunk.length;
                        }
                        this.s.l = 1 & final;
                        if (this.s.z > this.s.w + 8191 || final) {
                            this.p(this.b, final || false);
                            this.s.w = this.s.i, this.s.i -= 2;
                        }
                    };
                    return Deflate;
                }();
                exports.Deflate = Deflate;
                var AsyncDeflate = function() {
                    function AsyncDeflate(opts, cb) {
                        astrmify([ bDflt, function() {
                            return [ astrm, Deflate ];
                        } ], this, StrmOpt.call(this, opts, cb), function(ev) {
                            ev = new Deflate(ev.data);
                            onmessage = astrm(ev);
                        }, 6);
                    }
                    return AsyncDeflate;
                }();
                exports.AsyncDeflate = AsyncDeflate;
                function deflate(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    return cbify(data, opts, [ bDflt ], function(ev) {
                        return pbf(deflateSync(ev.data[0], ev.data[1]));
                    }, 0, cb);
                }
                exports.deflate = deflate;
                function deflateSync(data, opts) {
                    return dopt(data, opts || {}, 0, 0);
                }
                exports.deflateSync = deflateSync;
                var Inflate = function() {
                    function Inflate(opts, cb) {
                        if ("function" == typeof opts) cb = opts, opts = {};
                        this.ondata = cb;
                        cb = opts && opts.dictionary && opts.dictionary.subarray(-32768);
                        this.s = {
                            i: 0,
                            b: cb ? cb.length : 0
                        };
                        this.o = new u8(32768);
                        this.p = new u8(0);
                        if (cb) this.o.set(cb);
                    }
                    Inflate.prototype.e = function(c) {
                        if (!this.ondata) err(5);
                        if (this.d) err(4);
                        if (!this.p.length) this.p = c; else if (c.length) {
                            var n = new u8(this.p.length + c.length);
                            n.set(this.p), n.set(c, this.p.length), this.p = n;
                        }
                    };
                    Inflate.prototype.c = function(final) {
                        this.s.i = +(this.d = final || false);
                        final = this.s.b;
                        var dt = inflt(this.p, this.s, this.o);
                        this.ondata(slc(dt, final, this.s.b), this.d);
                        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
                        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
                    };
                    Inflate.prototype.push = function(chunk, final) {
                        this.e(chunk), this.c(final);
                    };
                    return Inflate;
                }();
                exports.Inflate = Inflate;
                var AsyncInflate = function() {
                    function AsyncInflate(opts, cb) {
                        astrmify([ bInflt, function() {
                            return [ astrm, Inflate ];
                        } ], this, StrmOpt.call(this, opts, cb), function(ev) {
                            ev = new Inflate(ev.data);
                            onmessage = astrm(ev);
                        }, 7);
                    }
                    return AsyncInflate;
                }();
                exports.AsyncInflate = AsyncInflate;
                function inflate(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    return cbify(data, opts, [ bInflt ], function(ev) {
                        return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
                    }, 1, cb);
                }
                exports.inflate = inflate;
                function inflateSync(data, opts) {
                    return inflt(data, {
                        i: 2
                    }, opts && opts.out, opts && opts.dictionary);
                }
                exports.inflateSync = inflateSync;
                var Gzip = function() {
                    function Gzip(opts, cb) {
                        this.c = crc();
                        this.l = 0;
                        this.v = 1;
                        Deflate.call(this, opts, cb);
                    }
                    Gzip.prototype.push = function(chunk, final) {
                        this.c.p(chunk);
                        this.l += chunk.length;
                        Deflate.prototype.push.call(this, chunk, final);
                    };
                    Gzip.prototype.p = function(c, f) {
                        c = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
                        if (this.v) gzh(c, this.o), this.v = 0;
                        if (f) wbytes(c, c.length - 8, this.c.d()), wbytes(c, c.length - 4, this.l);
                        this.ondata(c, f);
                    };
                    return Gzip;
                }();
                exports.Gzip = Gzip;
                exports.Compress = Gzip;
                freb = function() {
                    function AsyncGzip(opts, cb) {
                        astrmify([ bDflt, gze, function() {
                            return [ astrm, Deflate, Gzip ];
                        } ], this, StrmOpt.call(this, opts, cb), function(ev) {
                            ev = new Gzip(ev.data);
                            onmessage = astrm(ev);
                        }, 8);
                    }
                    return AsyncGzip;
                }();
                exports.AsyncGzip = freb;
                exports.AsyncCompress = freb;
                function gzip(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    return cbify(data, opts, [ bDflt, gze, function() {
                        return [ gzipSync ];
                    } ], function(ev) {
                        return pbf(gzipSync(ev.data[0], ev.data[1]));
                    }, 2, cb);
                }
                exports.gzip = gzip;
                exports.compress = gzip;
                function gzipSync(data, opts) {
                    if (!opts) opts = {};
                    var c = crc(), l = data.length;
                    c.p(data);
                    var data = dopt(data, opts, gzhl(opts), 8), s = data.length;
                    return gzh(data, opts), wbytes(data, s - 8, c.d()), wbytes(data, s - 4, l), 
                    data;
                }
                exports.gzipSync = gzipSync;
                exports.compressSync = gzipSync;
                var Gunzip = function() {
                    function Gunzip(opts, cb) {
                        this.v = 1;
                        this.r = 0;
                        Inflate.call(this, opts, cb);
                    }
                    Gunzip.prototype.push = function(chunk, final) {
                        Inflate.prototype.e.call(this, chunk);
                        this.r += chunk.length;
                        if (this.v) {
                            chunk = this.p.subarray(this.v - 1);
                            var s = chunk.length > 3 ? gzs(chunk) : 4;
                            if (s > chunk.length) {
                                if (!final) return;
                            } else if (this.v > 1 && this.onmember) this.onmember(this.r - chunk.length);
                            this.p = chunk.subarray(s), this.v = 0;
                        }
                        Inflate.prototype.c.call(this, final);
                        if (this.s.f && !this.s.l) {
                            this.v = shft(this.s.p) + 9;
                            this.s = {
                                i: 0
                            };
                            this.o = new u8(0);
                            if (this.p.length) this.push(new u8(0), final);
                        }
                    };
                    return Gunzip;
                }();
                exports.Gunzip = Gunzip;
                var AsyncGunzip = function() {
                    function AsyncGunzip(opts, cb) {
                        var _this_1 = this;
                        astrmify([ bInflt, guze, function() {
                            return [ astrm, Inflate, Gunzip ];
                        } ], this, StrmOpt.call(this, opts, cb), function(ev) {
                            ev = new Gunzip(ev.data);
                            ev.onmember = function(offset) {
                                return postMessage(offset);
                            };
                            onmessage = astrm(ev);
                        }, 9, function(offset) {
                            return _this_1.onmember && _this_1.onmember(offset);
                        });
                    }
                    return AsyncGunzip;
                }();
                exports.AsyncGunzip = AsyncGunzip;
                function gunzip(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    return cbify(data, opts, [ bInflt, guze, function() {
                        return [ gunzipSync ];
                    } ], function(ev) {
                        return pbf(gunzipSync(ev.data[0], ev.data[1]));
                    }, 3, cb);
                }
                exports.gunzip = gunzip;
                function gunzipSync(data, opts) {
                    var st = gzs(data);
                    if (st + 8 > data.length) err(6, "invalid gzip data");
                    return inflt(data.subarray(st, -8), {
                        i: 2
                    }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
                }
                exports.gunzipSync = gunzipSync;
                var Zlib = function() {
                    function Zlib(opts, cb) {
                        this.c = adler();
                        this.v = 1;
                        Deflate.call(this, opts, cb);
                    }
                    Zlib.prototype.push = function(chunk, final) {
                        this.c.p(chunk);
                        Deflate.prototype.push.call(this, chunk, final);
                    };
                    Zlib.prototype.p = function(c, f) {
                        c = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
                        if (this.v) zlh(c, this.o), this.v = 0;
                        if (f) wbytes(c, c.length - 4, this.c.d());
                        this.ondata(c, f);
                    };
                    return Zlib;
                }();
                exports.Zlib = Zlib;
                _a = function() {
                    function AsyncZlib(opts, cb) {
                        astrmify([ bDflt, zle, function() {
                            return [ astrm, Deflate, Zlib ];
                        } ], this, StrmOpt.call(this, opts, cb), function(ev) {
                            ev = new Zlib(ev.data);
                            onmessage = astrm(ev);
                        }, 10);
                    }
                    return AsyncZlib;
                }();
                exports.AsyncZlib = _a;
                function zlib(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    return cbify(data, opts, [ bDflt, zle, function() {
                        return [ zlibSync ];
                    } ], function(ev) {
                        return pbf(zlibSync(ev.data[0], ev.data[1]));
                    }, 4, cb);
                }
                exports.zlib = zlib;
                function zlibSync(data, opts) {
                    if (!opts) opts = {};
                    var a = adler();
                    a.p(data);
                    data = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
                    return zlh(data, opts), wbytes(data, data.length - 4, a.d()), 
                    data;
                }
                exports.zlibSync = zlibSync;
                var Unzlib = function() {
                    function Unzlib(opts, cb) {
                        Inflate.call(this, opts, cb);
                        this.v = opts && opts.dictionary ? 2 : 1;
                    }
                    Unzlib.prototype.push = function(chunk, final) {
                        Inflate.prototype.e.call(this, chunk);
                        if (this.v) {
                            if (this.p.length < 6 && !final) return;
                            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
                        }
                        if (final) {
                            if (this.p.length < 4) err(6, "invalid zlib data");
                            this.p = this.p.subarray(0, -4);
                        }
                        Inflate.prototype.c.call(this, final);
                    };
                    return Unzlib;
                }();
                exports.Unzlib = Unzlib;
                var AsyncUnzlib = function() {
                    function AsyncUnzlib(opts, cb) {
                        astrmify([ bInflt, zule, function() {
                            return [ astrm, Inflate, Unzlib ];
                        } ], this, StrmOpt.call(this, opts, cb), function(ev) {
                            ev = new Unzlib(ev.data);
                            onmessage = astrm(ev);
                        }, 11);
                    }
                    return AsyncUnzlib;
                }();
                exports.AsyncUnzlib = AsyncUnzlib;
                function unzlib(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    return cbify(data, opts, [ bInflt, zule, function() {
                        return [ unzlibSync ];
                    } ], function(ev) {
                        return pbf(unzlibSync(ev.data[0], gopt(ev.data[1])));
                    }, 5, cb);
                }
                exports.unzlib = unzlib;
                function unzlibSync(data, opts) {
                    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), {
                        i: 2
                    }, opts && opts.out, opts && opts.dictionary);
                }
                exports.unzlibSync = unzlibSync;
                var Decompress = function() {
                    function Decompress(opts, cb) {
                        this.G = Gunzip;
                        this.I = Inflate;
                        this.Z = Unzlib;
                        this.o = StrmOpt.call(this, opts, cb) || {};
                    }
                    Decompress.prototype.push = function(chunk, final) {
                        if (!this.ondata) err(5);
                        if (!this.s) {
                            if (this.p && this.p.length) {
                                var n = new u8(this.p.length + chunk.length);
                                n.set(this.p), n.set(chunk, this.p.length);
                            } else this.p = chunk;
                            if (this.p.length > 2) {
                                var _this_2 = this;
                                n = function() {
                                    _this_2.ondata.apply(_this_2, arguments);
                                };
                                this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(this.o, n) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o, n) : new this.Z(this.o, n);
                                this.s.push(this.p, final);
                                this.p = null;
                            }
                        } else this.s.push(chunk, final);
                    };
                    return Decompress;
                }();
                exports.Decompress = Decompress;
                freb = function() {
                    function AsyncDecompress(opts, cb) {
                        this.G = AsyncGunzip;
                        this.I = AsyncInflate;
                        this.Z = AsyncUnzlib;
                        Decompress.call(this, opts, cb);
                    }
                    AsyncDecompress.prototype.push = function(chunk, final) {
                        Decompress.prototype.push.call(this, chunk, final);
                    };
                    return AsyncDecompress;
                }();
                exports.AsyncDecompress = freb;
                function decompress(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    return 31 == data[0] && 139 == data[1] && 8 == data[2] ? gunzip(data, opts, cb) : 8 != (15 & data[0]) || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
                }
                exports.decompress = decompress;
                function decompressSync(data, opts) {
                    return 31 == data[0] && 139 == data[1] && 8 == data[2] ? gunzipSync(data, opts) : 8 != (15 & data[0]) || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
                }
                exports.decompressSync = decompressSync;
                var fltn = function(d, p, t, o) {
                    for (var k in d) {
                        var val = d[k], k = p + k, op = o;
                        if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];
                        if (val instanceof u8) t[k] = [ val, op ]; else {
                            t[k += "/"] = [ new u8(0), op ];
                            fltn(val, k, t, o);
                        }
                    }
                };
                var te = "undefined" != typeof TextEncoder && new TextEncoder();
                var td = "undefined" != typeof TextDecoder && new TextDecoder();
                var tds = 0;
                try {
                    td.decode(et, {
                        stream: true
                    });
                    tds = 1;
                } catch (e) {}
                var dutf8 = function(d) {
                    for (var r = "", i = 0; ;) {
                        var c = d[i++];
                        var eb = (c > 127) + (c > 223) + (c > 239);
                        if (i + eb > d.length) return {
                            s: r,
                            r: slc(d, i - 1)
                        };
                        if (!eb) r += String.fromCharCode(c); else if (3 == eb) c = ((15 & c) << 18 | (63 & d[i++]) << 12 | (63 & d[i++]) << 6 | 63 & d[i++]) - 65536, 
                        r += String.fromCharCode(55296 | c >> 10, 56320 | 1023 & c); else if (1 & eb) r += String.fromCharCode((31 & c) << 6 | 63 & d[i++]); else r += String.fromCharCode((15 & c) << 12 | (63 & d[i++]) << 6 | 63 & d[i++]);
                    }
                };
                _a = function() {
                    function DecodeUTF8(cb) {
                        this.ondata = cb;
                        if (tds) this.t = new TextDecoder(); else this.p = et;
                    }
                    DecodeUTF8.prototype.push = function(chunk, final) {
                        if (!this.ondata) err(5);
                        final = !!final;
                        if (this.t) {
                            this.ondata(this.t.decode(chunk, {
                                stream: true
                            }), final);
                            if (final) {
                                if (this.t.decode().length) err(8);
                                this.t = null;
                            }
                            return;
                        }
                        if (!this.p) err(4);
                        var dat = new u8(this.p.length + chunk.length);
                        dat.set(this.p);
                        dat.set(chunk, this.p.length);
                        chunk = dutf8(dat), dat = chunk.s, chunk = chunk.r;
                        if (final) {
                            if (chunk.length) err(8);
                            this.p = null;
                        } else this.p = chunk;
                        this.ondata(dat, final);
                    };
                    return DecodeUTF8;
                }();
                exports.DecodeUTF8 = _a;
                freb = function() {
                    function EncodeUTF8(cb) {
                        this.ondata = cb;
                    }
                    EncodeUTF8.prototype.push = function(chunk, final) {
                        if (!this.ondata) err(5);
                        if (this.d) err(4);
                        this.ondata(strToU8(chunk), this.d = final || false);
                    };
                    return EncodeUTF8;
                }();
                exports.EncodeUTF8 = freb;
                function strToU8(str, latin1) {
                    if (latin1) {
                        var ar_1 = new u8(str.length);
                        for (var i = 0; i < str.length; ++i) ar_1[i] = str.charCodeAt(i);
                        return ar_1;
                    }
                    if (te) return te.encode(str);
                    var l = str.length;
                    var ar = new u8(str.length + (str.length >> 1));
                    var ai = 0;
                    var w = function(v) {
                        ar[ai++] = v;
                    };
                    for (i = 0; i < l; ++i) {
                        if (ai + 5 > ar.length) {
                            var n = new u8(ai + 8 + (l - i << 1));
                            n.set(ar);
                            ar = n;
                        }
                        n = str.charCodeAt(i);
                        if (n < 128 || latin1) w(n); else if (n < 2048) w(192 | n >> 6), 
                        w(128 | 63 & n); else if (n > 55295 && n < 57344) n = 65536 + (n & 1023 << 10) | 1023 & str.charCodeAt(++i), 
                        w(240 | n >> 18), w(128 | n >> 12 & 63), w(128 | n >> 6 & 63), 
                        w(128 | 63 & n); else w(224 | n >> 12), w(128 | n >> 6 & 63), 
                        w(128 | 63 & n);
                    }
                    return slc(ar, 0, ai);
                }
                exports.strToU8 = strToU8;
                function strFromU8(dat, latin1) {
                    if (latin1) {
                        var r = "";
                        for (var i = 0; i < dat.length; i += 16384) r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
                        return r;
                    } else if (td) return td.decode(dat); else {
                        var latin1 = dutf8(dat), s = latin1.s, r = latin1.r;
                        if (r.length) err(8);
                        return s;
                    }
                }
                exports.strFromU8 = strFromU8;
                var dbf = function(l) {
                    return 1 == l ? 3 : l < 6 ? 2 : 9 == l ? 1 : 0;
                };
                var slzh = function(d, b) {
                    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
                };
                var zh = function(d, b, z) {
                    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(2048 & b2(d, b + 8))), fnl = b + 46 + fnl, bs = b4(d, b + 20);
                    var z = z && 4294967295 == bs ? z64e(d, fnl) : [ bs, b4(d, b + 24), b4(d, b + 42) ], bs = z[0], su = z[1], z = z[2];
                    return [ b2(d, b + 10), bs, su, fn, fnl + b2(d, b + 30) + b2(d, b + 32), z ];
                };
                var z64e = function(d, b) {
                    for (;1 != b2(d, b); b += 4 + b2(d, b + 2));
                    return [ b8(d, b + 12), b8(d, b + 4), b8(d, b + 20) ];
                };
                var exfl = function(ex) {
                    var le = 0;
                    if (ex) for (var k in ex) {
                        k = ex[k].length;
                        if (k > 65535) err(9);
                        le += k + 4;
                    }
                    return le;
                };
                var wzh = function(d, b, f, fn, u, c, ce, co) {
                    var fl = fn.length, ex = f.extra, col = co && co.length;
                    var exl = exfl(ex);
                    wbytes(d, b, null != ce ? 33639248 : 67324752), b += 4;
                    if (null != ce) d[b++] = 20, d[b++] = f.os;
                    d[b] = 20, b += 2;
                    d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
                    d[b++] = 255 & f.compression, d[b++] = f.compression >> 8;
                    var u = new Date(null == f.mtime ? Date.now() : f.mtime), y = u.getFullYear() - 1980;
                    if (y < 0 || y > 119) err(10);
                    wbytes(d, b, y << 25 | u.getMonth() + 1 << 21 | u.getDate() << 16 | u.getHours() << 11 | u.getMinutes() << 5 | u.getSeconds() >> 1), 
                    b += 4;
                    if (-1 != c) {
                        wbytes(d, b, f.crc);
                        wbytes(d, b + 4, c < 0 ? -c - 2 : c);
                        wbytes(d, b + 8, f.size);
                    }
                    wbytes(d, b + 12, fl);
                    wbytes(d, b + 14, exl), b += 16;
                    if (null != ce) {
                        wbytes(d, b, col);
                        wbytes(d, b + 6, f.attrs);
                        wbytes(d, b + 10, ce), b += 14;
                    }
                    d.set(fn, b);
                    b += fl;
                    if (exl) for (var k in ex) {
                        var exf = ex[k], l = exf.length;
                        wbytes(d, b, +k);
                        wbytes(d, b + 2, l);
                        d.set(exf, b + 4), b += 4 + l;
                    }
                    if (col) d.set(co, b), b += col;
                    return b;
                };
                var wzf = function(o, b, c, d, e) {
                    wbytes(o, b, 101010256);
                    wbytes(o, b + 8, c);
                    wbytes(o, b + 10, c);
                    wbytes(o, b + 12, d);
                    wbytes(o, b + 16, e);
                };
                var ZipPassThrough = function() {
                    function ZipPassThrough(filename) {
                        this.filename = filename;
                        this.c = crc();
                        this.size = 0;
                        this.compression = 0;
                    }
                    ZipPassThrough.prototype.process = function(chunk, final) {
                        this.ondata(null, chunk, final);
                    };
                    ZipPassThrough.prototype.push = function(chunk, final) {
                        if (!this.ondata) err(5);
                        this.c.p(chunk);
                        this.size += chunk.length;
                        if (final) this.crc = this.c.d();
                        this.process(chunk, final || false);
                    };
                    return ZipPassThrough;
                }();
                exports.ZipPassThrough = ZipPassThrough;
                _a = function() {
                    function ZipDeflate(filename, opts) {
                        var _this_1 = this;
                        if (!opts) opts = {};
                        ZipPassThrough.call(this, filename);
                        this.d = new Deflate(opts, function(dat, final) {
                            _this_1.ondata(null, dat, final);
                        });
                        this.compression = 8;
                        this.flag = dbf(opts.level);
                    }
                    ZipDeflate.prototype.process = function(chunk, final) {
                        try {
                            this.d.push(chunk, final);
                        } catch (e) {
                            this.ondata(e, null, final);
                        }
                    };
                    ZipDeflate.prototype.push = function(chunk, final) {
                        ZipPassThrough.prototype.push.call(this, chunk, final);
                    };
                    return ZipDeflate;
                }();
                exports.ZipDeflate = _a;
                freb = function() {
                    function AsyncZipDeflate(filename, opts) {
                        var _this_1 = this;
                        if (!opts) opts = {};
                        ZipPassThrough.call(this, filename);
                        this.d = new AsyncDeflate(opts, function(err, dat, final) {
                            _this_1.ondata(err, dat, final);
                        });
                        this.compression = 8;
                        this.flag = dbf(opts.level);
                        this.terminate = this.d.terminate;
                    }
                    AsyncZipDeflate.prototype.process = function(chunk, final) {
                        this.d.push(chunk, final);
                    };
                    AsyncZipDeflate.prototype.push = function(chunk, final) {
                        ZipPassThrough.prototype.push.call(this, chunk, final);
                    };
                    return AsyncZipDeflate;
                }();
                exports.AsyncZipDeflate = freb;
                _a = function() {
                    function Zip(cb) {
                        this.ondata = cb;
                        this.u = [];
                        this.d = 1;
                    }
                    Zip.prototype.add = function(file) {
                        var _this_1 = this;
                        if (!this.ondata) err(5);
                        if (2 & this.d) this.ondata(err(4 + 8 * (1 & this.d), 0, 1), null, false); else {
                            var f = strToU8(file.filename), fl_1 = f.length;
                            var com = file.comment, o = com && strToU8(com);
                            com = fl_1 != file.filename.length || o && com.length != o.length;
                            var hl_1 = fl_1 + exfl(file.extra) + 30;
                            if (fl_1 > 65535) this.ondata(err(11, 0, 1), null, false);
                            fl_1 = new u8(hl_1);
                            wzh(fl_1, 0, file, f, com, -1);
                            var chks_1 = [ fl_1 ];
                            var pAll_1 = function() {
                                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
                                    var chk = chks_2[_i];
                                    _this_1.ondata(null, chk, false);
                                }
                                chks_1 = [];
                            };
                            var tr_1 = this.d;
                            this.d = 0;
                            var ind_1 = this.u.length;
                            var uf_1 = mrg(file, {
                                f: f,
                                u: com,
                                o: o,
                                t: function() {
                                    if (file.terminate) file.terminate();
                                },
                                r: function() {
                                    pAll_1();
                                    if (tr_1) {
                                        var nxt = _this_1.u[ind_1 + 1];
                                        if (nxt) nxt.r(); else _this_1.d = 1;
                                    }
                                    tr_1 = 1;
                                }
                            });
                            var cl_1 = 0;
                            file.ondata = function(err, dat, final) {
                                if (err) {
                                    _this_1.ondata(err, dat, final);
                                    _this_1.terminate();
                                } else {
                                    cl_1 += dat.length;
                                    chks_1.push(dat);
                                    if (final) {
                                        err = new u8(16);
                                        wbytes(err, 0, 134695760);
                                        wbytes(err, 4, file.crc);
                                        wbytes(err, 8, cl_1);
                                        wbytes(err, 12, file.size);
                                        chks_1.push(err);
                                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, 
                                        uf_1.crc = file.crc, uf_1.size = file.size;
                                        if (tr_1) uf_1.r();
                                        tr_1 = 1;
                                    } else if (tr_1) pAll_1();
                                }
                            };
                            this.u.push(uf_1);
                        }
                    };
                    Zip.prototype.end = function() {
                        var _this_1 = this;
                        if (2 & this.d) {
                            this.ondata(err(4 + 8 * (1 & this.d), 0, 1), null, true);
                            return;
                        }
                        if (this.d) this.e(); else this.u.push({
                            r: function() {
                                if (!(1 & _this_1.d)) return;
                                _this_1.u.splice(-1, 1);
                                _this_1.e();
                            },
                            t: function() {}
                        });
                        this.d = 3;
                    };
                    Zip.prototype.e = function() {
                        var bt = 0, l = 0, tl = 0;
                        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
                            var f = _a[_i];
                            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
                        }
                        var out = new u8(tl + 22);
                        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {
                            f = _c[_b];
                            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
                            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), 
                            l += f.b;
                        }
                        wzf(out, bt, this.u.length, tl, l);
                        this.ondata(null, out, true);
                        this.d = 2;
                    };
                    Zip.prototype.terminate = function() {
                        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
                            var f = _a[_i];
                            f.t();
                        }
                        this.d = 2;
                    };
                    return Zip;
                }();
                exports.Zip = _a;
                function zip(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    var r = {};
                    fltn(data, "", r, opts);
                    var k = Object.keys(r);
                    var lft = k.length, o = 0, tot = 0;
                    var slft = lft, files = new Array(lft);
                    var term = [];
                    var tAll = function() {
                        for (var i = 0; i < term.length; ++i) term[i]();
                    };
                    var cbd = function(a, b) {
                        mt(function() {
                            cb(a, b);
                        });
                    };
                    mt(function() {
                        cbd = cb;
                    });
                    var cbf = function() {
                        var out = new u8(tot + 22), oe = o, cdl = tot - o;
                        tot = 0;
                        for (var i = 0; i < slft; ++i) {
                            var f = files[i];
                            try {
                                var l = f.c.length;
                                wzh(out, tot, f, f.f, f.u, l);
                                var badd = 30 + f.f.length + exfl(f.extra);
                                var loc = tot + badd;
                                out.set(f.c, loc);
                                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), 
                                tot = loc + l;
                            } catch (e) {
                                return cbd(e, null);
                            }
                        }
                        wzf(out, o, files.length, cdl, oe);
                        cbd(null, out);
                    };
                    if (!lft) cbf();
                    var _loop_1 = function(i) {
                        var fn = k[i];
                        var _a = r[fn], file = _a[0], p = _a[1];
                        var c = crc(), size = file.length;
                        c.p(file);
                        var f = strToU8(fn), s = f.length;
                        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
                        var exl = exfl(p.extra);
                        var compression = 0 == p.level ? 0 : 8;
                        _a = function(e, d) {
                            if (e) {
                                tAll();
                                cbd(e, null);
                            } else {
                                e = d.length;
                                files[i] = mrg(p, {
                                    size: size,
                                    crc: c.d(),
                                    c: d,
                                    f: f,
                                    m: m,
                                    u: s != fn.length || m && com.length != ms,
                                    compression: compression
                                });
                                o += 30 + s + exl + e;
                                tot += 76 + 2 * (s + exl) + (ms || 0) + e;
                                if (!--lft) cbf();
                            }
                        };
                        if (s > 65535) _a(err(11, 0, 1), null);
                        if (!compression) _a(null, file); else if (size < 16e4) try {
                            _a(null, deflateSync(file, p));
                        } catch (e) {
                            _a(e, null);
                        } else term.push(deflate(file, p, _a));
                    };
                    for (var i = 0; i < slft; ++i) _loop_1(i);
                    return tAll;
                }
                exports.zip = zip;
                function zipSync(data, opts) {
                    if (!opts) opts = {};
                    var r = {};
                    var files = [];
                    fltn(data, "", r, opts);
                    var o = 0;
                    var tot = 0;
                    for (var fn in r) {
                        var _a = r[fn], file = _a[0], _a = _a[1];
                        var compression = 0 == _a.level ? 0 : 8;
                        var f = strToU8(fn), s = f.length;
                        var com = _a.comment, m = com && strToU8(com), ms = m && m.length;
                        var exl = exfl(_a.extra);
                        if (s > 65535) err(11);
                        var d = compression ? deflateSync(file, _a) : file, l = d.length;
                        var c = crc();
                        c.p(file);
                        files.push(mrg(_a, {
                            size: file.length,
                            crc: c.d(),
                            c: d,
                            f: f,
                            m: m,
                            u: s != fn.length || m && com.length != ms,
                            o: o,
                            compression: compression
                        }));
                        o += 30 + s + exl + l;
                        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
                    }
                    var out = new u8(tot + 22), data = o, opts = tot - o;
                    for (var i = 0; i < files.length; ++i) {
                        f = files[i];
                        wzh(out, f.o, f, f.f, f.u, f.c.length);
                        var badd = 30 + f.f.length + exfl(f.extra);
                        out.set(f.c, f.o + badd);
                        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
                    }
                    wzf(out, o, files.length, opts, data);
                    return out;
                }
                exports.zipSync = zipSync;
                var UnzipPassThrough = function() {
                    function UnzipPassThrough() {}
                    UnzipPassThrough.prototype.push = function(data, final) {
                        this.ondata(null, data, final);
                    };
                    UnzipPassThrough.compression = 0;
                    return UnzipPassThrough;
                }();
                exports.UnzipPassThrough = UnzipPassThrough;
                freb = function() {
                    function UnzipInflate() {
                        var _this_1 = this;
                        this.i = new Inflate(function(dat, final) {
                            _this_1.ondata(null, dat, final);
                        });
                    }
                    UnzipInflate.prototype.push = function(data, final) {
                        try {
                            this.i.push(data, final);
                        } catch (e) {
                            this.ondata(e, null, final);
                        }
                    };
                    UnzipInflate.compression = 8;
                    return UnzipInflate;
                }();
                exports.UnzipInflate = freb;
                _a = function() {
                    function AsyncUnzipInflate(_, sz) {
                        var _this_1 = this;
                        if (sz < 32e4) this.i = new Inflate(function(dat, final) {
                            _this_1.ondata(null, dat, final);
                        }); else {
                            this.i = new AsyncInflate(function(err, dat, final) {
                                _this_1.ondata(err, dat, final);
                            });
                            this.terminate = this.i.terminate;
                        }
                    }
                    AsyncUnzipInflate.prototype.push = function(data, final) {
                        if (this.i.terminate) data = slc(data, 0);
                        this.i.push(data, final);
                    };
                    AsyncUnzipInflate.compression = 8;
                    return AsyncUnzipInflate;
                }();
                exports.AsyncUnzipInflate = _a;
                freb = function() {
                    function Unzip(cb) {
                        this.onfile = cb;
                        this.k = [];
                        this.o = {
                            0: UnzipPassThrough
                        };
                        this.p = et;
                    }
                    Unzip.prototype.push = function(chunk, final) {
                        var _this_1 = this;
                        if (!this.onfile) err(5);
                        if (!this.p) err(4);
                        if (this.c > 0) {
                            var len = Math.min(this.c, chunk.length);
                            var toAdd = chunk.subarray(0, len);
                            this.c -= len;
                            if (this.d) this.d.push(toAdd, !this.c); else this.k[0].push(toAdd);
                            chunk = chunk.subarray(len);
                            if (chunk.length) return this.push(chunk, final);
                        } else {
                            var f = 0, i = 0, is = void 0, buf = void 0;
                            if (!this.p.length) buf = chunk; else if (!chunk.length) buf = this.p; else {
                                buf = new u8(this.p.length + chunk.length);
                                buf.set(this.p), buf.set(chunk, this.p.length);
                            }
                            var l = buf.length, oc = this.c, toAdd = oc && this.d;
                            var _loop_2 = function() {
                                var sig = b4(buf, i);
                                if (67324752 == sig) {
                                    f = 1, is = i;
                                    this_1.d = null;
                                    this_1.c = 0;
                                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = 2048 & bf, bf = 8 & bf, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
                                    if (l > i + 30 + fnl + es) {
                                        var chks_3 = [];
                                        this_1.k.unshift(chks_3);
                                        f = 2;
                                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                                        if (4294967295 == sc_1) fnl = bf ? [ -2 ] : z64e(buf, i), 
                                        sc_1 = fnl[0], su_1 = fnl[1]; else if (bf) sc_1 = -1;
                                        i += es;
                                        this_1.c = sc_1;
                                        var d_1;
                                        var file_1 = {
                                            name: fn_1,
                                            compression: cmp_1,
                                            start: function() {
                                                if (!file_1.ondata) err(5);
                                                if (!sc_1) file_1.ondata(null, et, true); else {
                                                    var ctr = _this_1.o[cmp_1];
                                                    if (!ctr) file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                                                    d_1.ondata = function(err, dat, final) {
                                                        file_1.ondata(err, dat, final);
                                                    };
                                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                                                        var dat = chks_4[_i];
                                                        d_1.push(dat, false);
                                                    }
                                                    if (_this_1.k[0] == chks_3 && _this_1.c) _this_1.d = d_1; else d_1.push(et, true);
                                                }
                                            },
                                            terminate: function() {
                                                if (d_1 && d_1.terminate) d_1.terminate();
                                            }
                                        };
                                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;
                                        this_1.onfile(file_1);
                                    }
                                    return "break";
                                } else if (oc) if (134695760 == sig) {
                                    is = i += 12 + (-2 == oc && 8), f = 3, this_1.c = 0;
                                    return "break";
                                } else if (33639248 == sig) {
                                    is = i -= 4, f = 3, this_1.c = 0;
                                    return "break";
                                }
                            };
                            var this_1 = this;
                            for (;i < l - 4; ++i) {
                                var state_1 = _loop_2();
                                if ("break" === state_1) break;
                            }
                            this.p = et;
                            if (oc < 0) {
                                len = f ? buf.subarray(0, is - 12 - (-2 == oc && 8) - (134695760 == b4(buf, is - 16) && 4)) : buf.subarray(0, i);
                                if (toAdd) toAdd.push(len, !!f); else this.k[+(2 == f)].push(len);
                            }
                            if (2 & f) return this.push(buf.subarray(i), final);
                            this.p = buf.subarray(i);
                        }
                        if (final) {
                            if (this.c) err(13);
                            this.p = null;
                        }
                    };
                    Unzip.prototype.register = function(decoder) {
                        this.o[decoder.compression] = decoder;
                    };
                    return Unzip;
                }();
                exports.Unzip = freb;
                var mt = "function" == typeof queueMicrotask ? queueMicrotask : "function" == typeof setTimeout ? setTimeout : function(fn) {
                    fn();
                };
                function unzip(data, opts, cb) {
                    if (!cb) cb = opts, opts = {};
                    if ("function" != typeof cb) err(7);
                    var term = [];
                    var tAll = function() {
                        for (var i = 0; i < term.length; ++i) term[i]();
                    };
                    var files = {};
                    var cbd = function(a, b) {
                        mt(function() {
                            cb(a, b);
                        });
                    };
                    mt(function() {
                        cbd = cb;
                    });
                    var e = data.length - 22;
                    for (;101010256 != b4(data, e); --e) if (!e || data.length - e > 65558) {
                        cbd(err(13, 0, 1), null);
                        return tAll;
                    }
                    var lft = b2(data, e + 8);
                    if (lft) {
                        var c = lft;
                        var o = b4(data, e + 16);
                        var z = 4294967295 == o || 65535 == c;
                        if (z) {
                            var ze = b4(data, e - 12);
                            z = 101075792 == b4(data, ze);
                            if (z) {
                                c = lft = b4(data, ze + 32);
                                o = b4(data, ze + 48);
                            }
                        }
                        var fltr = opts && opts.filter;
                        var _loop_3 = function(i) {
                            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], _a = _a[5], _a = slzh(data, _a);
                            o = no;
                            no = function(e, d) {
                                if (e) {
                                    tAll();
                                    cbd(e, null);
                                } else {
                                    if (d) files[fn] = d;
                                    if (!--lft) cbd(null, files);
                                }
                            };
                            if (!fltr || fltr({
                                name: fn,
                                size: sc,
                                originalSize: su,
                                compression: c_1
                            })) if (!c_1) no(null, slc(data, _a, _a + sc)); else if (8 == c_1) {
                                _a = data.subarray(_a, _a + sc);
                                if (sc < 32e4) try {
                                    no(null, inflateSync(_a, {
                                        out: new u8(su)
                                    }));
                                } catch (e) {
                                    no(e, null);
                                } else term.push(inflate(_a, {
                                    size: su
                                }, no));
                            } else no(err(14, "unknown compression type " + c_1, 1), null); else no(null, null);
                        };
                        for (var i = 0; i < c; ++i) _loop_3(i);
                    } else cbd(null, {});
                    return tAll;
                }
                exports.unzip = unzip;
                function unzipSync(data, opts) {
                    var files = {};
                    var e = data.length - 22;
                    for (;101010256 != b4(data, e); --e) if (!e || data.length - e > 65558) err(13);
                    var c = b2(data, e + 8);
                    if (!c) return {};
                    var o = b4(data, e + 16);
                    var z = 4294967295 == o || 65535 == c;
                    if (z) {
                        var ze = b4(data, e - 12);
                        z = 101075792 == b4(data, ze);
                        if (z) {
                            c = b4(data, ze + 32);
                            o = b4(data, ze + 48);
                        }
                    }
                    var fltr = opts && opts.filter;
                    for (var i = 0; i < c; ++i) {
                        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], _a = _a[5], _a = slzh(data, _a);
                        o = no;
                        if (!fltr || fltr({
                            name: fn,
                            size: sc,
                            originalSize: su,
                            compression: c_2
                        })) if (!c_2) files[fn] = slc(data, _a, _a + sc); else if (8 == c_2) files[fn] = inflateSync(data.subarray(_a, _a + sc), {
                            out: new u8(su)
                        }); else err(14, "unknown compression type " + c_2);
                    }
                    return files;
                }
                exports.unzipSync = unzipSync;
            },
            "./node_modules/ieee754/index.js": (__unused_webpack_module, exports) => {
                exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                    var e, m;
                    var eLen = 8 * nBytes - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;
                    var nBits = -7;
                    var i = isLE ? nBytes - 1 : 0;
                    var d = isLE ? -1 : 1;
                    nBytes = buffer[offset + i];
                    i += d;
                    e = nBytes & (1 << -nBits) - 1;
                    nBytes >>= -nBits;
                    nBits += eLen;
                    for (;nBits > 0; e = 256 * e + buffer[offset + i], i += d, nBits -= 8);
                    m = e & (1 << -nBits) - 1;
                    e >>= -nBits;
                    nBits += mLen;
                    for (;nBits > 0; m = 256 * m + buffer[offset + i], i += d, nBits -= 8);
                    if (0 === e) e = 1 - eBias; else if (e === eMax) return m ? NaN : (nBytes ? -1 : 1) * (1 / 0); else {
                        m += Math.pow(2, mLen);
                        e -= eBias;
                    }
                    return (nBytes ? -1 : 1) * m * Math.pow(2, e - mLen);
                };
                exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                    var e, m;
                    var eLen = 8 * nBytes - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;
                    var rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                    var i = isLE ? 0 : nBytes - 1;
                    var d = isLE ? 1 : -1;
                    nBytes = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
                    value = Math.abs(value);
                    if (isNaN(value) || value === 1 / 0) {
                        m = isNaN(value) ? 1 : 0;
                        e = eMax;
                    } else {
                        e = Math.floor(Math.log(value) / Math.LN2);
                        if (value * (isLE = Math.pow(2, -e)) < 1) {
                            e--;
                            isLE *= 2;
                        }
                        if (e + eBias >= 1) value += rt / isLE; else value += rt * Math.pow(2, 1 - eBias);
                        if (value * isLE >= 2) {
                            e++;
                            isLE /= 2;
                        }
                        if (e + eBias >= eMax) {
                            m = 0;
                            e = eMax;
                        } else if (e + eBias >= 1) {
                            m = (value * isLE - 1) * Math.pow(2, mLen);
                            e += eBias;
                        } else {
                            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                            e = 0;
                        }
                    }
                    for (;mLen >= 8; buffer[offset + i] = 255 & m, i += d, m /= 256, 
                    mLen -= 8);
                    e = e << mLen | m;
                    eLen += mLen;
                    for (;eLen > 0; buffer[offset + i] = 255 & e, i += d, e /= 256, 
                    eLen -= 8);
                    buffer[offset + i - d] |= 128 * nBytes;
                };
            },
            "./node_modules/long/umd/index.js": (module, exports) => {
                var __WEBPACK_AMD_DEFINE_ARRAY__;
                var Long = function(exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.default = void 0;
                    var wasm = null;
                    try {
                        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11 ])), {}).exports;
                    } catch (e) {}
                    function Long(low, high, unsigned) {
                        this.low = 0 | low;
                        this.high = 0 | high;
                        this.unsigned = !!unsigned;
                    }
                    Long.prototype.__isLong__;
                    Object.defineProperty(Long.prototype, "__isLong__", {
                        value: true
                    });
                    function isLong(obj) {
                        return true === (obj && obj["__isLong__"]);
                    }
                    function ctz32(value) {
                        var c = Math.clz32(value & -value);
                        return value ? 31 - c : c;
                    }
                    Long.isLong = isLong;
                    var INT_CACHE = {};
                    var UINT_CACHE = {};
                    function fromInt(value, unsigned) {
                        var obj, cachedObj, cache;
                        if (unsigned) {
                            value >>>= 0;
                            if (cache = 0 <= value && value < 256) {
                                cachedObj = UINT_CACHE[value];
                                if (cachedObj) return cachedObj;
                            }
                            obj = fromBits(value, 0, true);
                            if (cache) UINT_CACHE[value] = obj;
                            return obj;
                        } else {
                            value |= 0;
                            if (cache = -128 <= value && value < 128) {
                                cachedObj = INT_CACHE[value];
                                if (cachedObj) return cachedObj;
                            }
                            obj = fromBits(value, value < 0 ? -1 : 0, false);
                            if (cache) INT_CACHE[value] = obj;
                            return obj;
                        }
                    }
                    Long.fromInt = fromInt;
                    function fromNumber(value, unsigned) {
                        if (isNaN(value)) return unsigned ? UZERO : ZERO;
                        if (unsigned) {
                            if (value < 0) return UZERO;
                            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
                        } else {
                            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
                            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
                        }
                        if (value < 0) return fromNumber(-value, unsigned).neg();
                        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
                    }
                    Long.fromNumber = fromNumber;
                    function fromBits(lowBits, highBits, unsigned) {
                        return new Long(lowBits, highBits, unsigned);
                    }
                    Long.fromBits = fromBits;
                    var pow_dbl = Math.pow;
                    function fromString(str, unsigned, radix) {
                        if (0 === str.length) throw Error("empty string");
                        if ("number" === typeof unsigned) {
                            radix = unsigned;
                            unsigned = false;
                        } else unsigned = !!unsigned;
                        if ("NaN" === str || "Infinity" === str || "+Infinity" === str || "-Infinity" === str) return unsigned ? UZERO : ZERO;
                        radix = radix || 10;
                        if (radix < 2 || 36 < radix) throw RangeError("radix");
                        var p;
                        if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen"); else if (0 === p) return fromString(str.substring(1), unsigned, radix).neg();
                        var radixToPower = fromNumber(pow_dbl(radix, 8));
                        var result = ZERO;
                        for (var i = 0; i < str.length; i += 8) {
                            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
                            if (size < 8) {
                                size = fromNumber(pow_dbl(radix, size));
                                result = result.mul(size).add(fromNumber(value));
                            } else {
                                result = result.mul(radixToPower);
                                result = result.add(fromNumber(value));
                            }
                        }
                        result.unsigned = unsigned;
                        return result;
                    }
                    Long.fromString = fromString;
                    function fromValue(val, unsigned) {
                        if ("number" === typeof val) return fromNumber(val, unsigned);
                        if ("string" === typeof val) return fromString(val, unsigned);
                        return fromBits(val.low, val.high, "boolean" === typeof unsigned ? unsigned : val.unsigned);
                    }
                    Long.fromValue = fromValue;
                    var TWO_PWR_16_DBL = 1 << 16;
                    var TWO_PWR_24_DBL = 1 << 24;
                    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
                    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
                    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
                    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
                    var ZERO = fromInt(0);
                    Long.ZERO = ZERO;
                    var UZERO = fromInt(0, true);
                    Long.UZERO = UZERO;
                    var ONE = fromInt(1);
                    Long.ONE = ONE;
                    var UONE = fromInt(1, true);
                    Long.UONE = UONE;
                    var NEG_ONE = fromInt(-1);
                    Long.NEG_ONE = NEG_ONE;
                    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
                    Long.MAX_VALUE = MAX_VALUE;
                    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
                    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
                    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
                    Long.MIN_VALUE = MIN_VALUE;
                    TWO_PWR_16_DBL = Long.prototype;
                    TWO_PWR_16_DBL.toInt = function() {
                        return this.unsigned ? this.low >>> 0 : this.low;
                    };
                    TWO_PWR_16_DBL.toNumber = function() {
                        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
                        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
                    };
                    TWO_PWR_16_DBL.toString = function(radix) {
                        radix = radix || 10;
                        if (radix < 2 || 36 < radix) throw RangeError("radix");
                        if (this.isZero()) return "0";
                        if (this.isNegative()) if (this.eq(MIN_VALUE)) {
                            var radixLong = fromNumber(radix), div = this.div(radixLong), radixLong = div.mul(radixLong).sub(this);
                            return div.toString(radix) + radixLong.toInt().toString(radix);
                        } else return "-" + this.neg().toString(radix);
                        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
                        var result = "";
                        while (true) {
                            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
                            rem = remDiv;
                            if (rem.isZero()) return digits + result; else {
                                while (digits.length < 6) digits = "0" + digits;
                                result = "" + digits + result;
                            }
                        }
                    };
                    TWO_PWR_16_DBL.getHighBits = function() {
                        return this.high;
                    };
                    TWO_PWR_16_DBL.getHighBitsUnsigned = function() {
                        return this.high >>> 0;
                    };
                    TWO_PWR_16_DBL.getLowBits = function() {
                        return this.low;
                    };
                    TWO_PWR_16_DBL.getLowBitsUnsigned = function() {
                        return this.low >>> 0;
                    };
                    TWO_PWR_16_DBL.getNumBitsAbs = function() {
                        if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
                        var val = 0 != this.high ? this.high : this.low;
                        for (var bit = 31; bit > 0; bit--) if (0 != (val & 1 << bit)) break;
                        return 0 != this.high ? bit + 33 : bit + 1;
                    };
                    TWO_PWR_16_DBL.isZero = function() {
                        return 0 === this.high && 0 === this.low;
                    };
                    TWO_PWR_16_DBL.eqz = TWO_PWR_16_DBL.isZero;
                    TWO_PWR_16_DBL.isNegative = function() {
                        return !this.unsigned && this.high < 0;
                    };
                    TWO_PWR_16_DBL.isPositive = function() {
                        return this.unsigned || this.high >= 0;
                    };
                    TWO_PWR_16_DBL.isOdd = function() {
                        return 1 === (1 & this.low);
                    };
                    TWO_PWR_16_DBL.isEven = function() {
                        return 0 === (1 & this.low);
                    };
                    TWO_PWR_16_DBL.equals = function(other) {
                        if (!isLong(other)) other = fromValue(other);
                        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
                        return this.high === other.high && this.low === other.low;
                    };
                    TWO_PWR_16_DBL.eq = TWO_PWR_16_DBL.equals;
                    TWO_PWR_16_DBL.notEquals = function(other) {
                        return !this.eq(other);
                    };
                    TWO_PWR_16_DBL.neq = TWO_PWR_16_DBL.notEquals;
                    TWO_PWR_16_DBL.ne = TWO_PWR_16_DBL.notEquals;
                    TWO_PWR_16_DBL.lessThan = function(other) {
                        return this.comp(other) < 0;
                    };
                    TWO_PWR_16_DBL.lt = TWO_PWR_16_DBL.lessThan;
                    TWO_PWR_16_DBL.lessThanOrEqual = function(other) {
                        return this.comp(other) <= 0;
                    };
                    TWO_PWR_16_DBL.lte = TWO_PWR_16_DBL.lessThanOrEqual;
                    TWO_PWR_16_DBL.le = TWO_PWR_16_DBL.lessThanOrEqual;
                    TWO_PWR_16_DBL.greaterThan = function(other) {
                        return this.comp(other) > 0;
                    };
                    TWO_PWR_16_DBL.gt = TWO_PWR_16_DBL.greaterThan;
                    TWO_PWR_16_DBL.greaterThanOrEqual = function(other) {
                        return this.comp(other) >= 0;
                    };
                    TWO_PWR_16_DBL.gte = TWO_PWR_16_DBL.greaterThanOrEqual;
                    TWO_PWR_16_DBL.ge = TWO_PWR_16_DBL.greaterThanOrEqual;
                    TWO_PWR_16_DBL.compare = function(other) {
                        if (!isLong(other)) other = fromValue(other);
                        if (this.eq(other)) return 0;
                        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
                        if (thisNeg && !otherNeg) return -1;
                        if (!thisNeg && otherNeg) return 1;
                        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
                        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
                    };
                    TWO_PWR_16_DBL.comp = TWO_PWR_16_DBL.compare;
                    TWO_PWR_16_DBL.negate = function() {
                        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
                        return this.not().add(ONE);
                    };
                    TWO_PWR_16_DBL.neg = TWO_PWR_16_DBL.negate;
                    TWO_PWR_16_DBL.add = function(addend) {
                        if (!isLong(addend)) addend = fromValue(addend);
                        var a48 = this.high >>> 16;
                        var a32 = 65535 & this.high;
                        var a16 = this.low >>> 16;
                        var a00 = 65535 & this.low;
                        var b48 = addend.high >>> 16;
                        var b32 = 65535 & addend.high;
                        var b16 = addend.low >>> 16;
                        addend = 65535 & addend.low;
                        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                        c00 += a00 + addend;
                        c16 += c00 >>> 16;
                        c00 &= 65535;
                        c16 += a16 + b16;
                        c32 += c16 >>> 16;
                        c16 &= 65535;
                        c32 += a32 + b32;
                        c48 += c32 >>> 16;
                        c32 &= 65535;
                        c48 += a48 + b48;
                        c48 &= 65535;
                        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
                    };
                    TWO_PWR_16_DBL.subtract = function(subtrahend) {
                        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
                        return this.add(subtrahend.neg());
                    };
                    TWO_PWR_16_DBL.sub = TWO_PWR_16_DBL.subtract;
                    TWO_PWR_16_DBL.multiply = function(multiplier) {
                        if (this.isZero()) return this;
                        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
                        if (wasm) {
                            var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
                            return fromBits(low, wasm["get_high"](), this.unsigned);
                        }
                        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
                        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
                        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
                        if (this.isNegative()) if (multiplier.isNegative()) return this.neg().mul(multiplier.neg()); else return this.neg().mul(multiplier).neg(); else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
                        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
                        low = this.high >>> 16;
                        var a32 = 65535 & this.high;
                        var a16 = this.low >>> 16;
                        var a00 = 65535 & this.low;
                        var b48 = multiplier.high >>> 16;
                        var b32 = 65535 & multiplier.high;
                        var b16 = multiplier.low >>> 16;
                        multiplier = 65535 & multiplier.low;
                        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                        c00 += a00 * multiplier;
                        c16 += c00 >>> 16;
                        c00 &= 65535;
                        c16 += a16 * multiplier;
                        c32 += c16 >>> 16;
                        c16 &= 65535;
                        c16 += a00 * b16;
                        c32 += c16 >>> 16;
                        c16 &= 65535;
                        c32 += a32 * multiplier;
                        c48 += c32 >>> 16;
                        c32 &= 65535;
                        c32 += a16 * b16;
                        c48 += c32 >>> 16;
                        c32 &= 65535;
                        c32 += a00 * b32;
                        c48 += c32 >>> 16;
                        c32 &= 65535;
                        c48 += low * multiplier + a32 * b16 + a16 * b32 + a00 * b48;
                        c48 &= 65535;
                        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
                    };
                    TWO_PWR_16_DBL.mul = TWO_PWR_16_DBL.multiply;
                    TWO_PWR_16_DBL.divide = function(divisor) {
                        if (!isLong(divisor)) divisor = fromValue(divisor);
                        if (divisor.isZero()) throw Error("division by zero");
                        if (wasm) {
                            if (!this.unsigned && -2147483648 === this.high && -1 === divisor.low && -1 === divisor.high) return this;
                            var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
                            return fromBits(low, wasm["get_high"](), this.unsigned);
                        }
                        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
                        var approx, rem, res;
                        if (!this.unsigned) {
                            if (this.eq(MIN_VALUE)) if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; else if (divisor.eq(MIN_VALUE)) return ONE; else {
                                low = this.shr(1);
                                approx = low.div(divisor).shl(1);
                                if (approx.eq(ZERO)) return divisor.isNegative() ? ONE : NEG_ONE; else {
                                    rem = this.sub(divisor.mul(approx));
                                    res = approx.add(rem.div(divisor));
                                    return res;
                                }
                            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
                            if (this.isNegative()) {
                                if (divisor.isNegative()) return this.neg().div(divisor.neg());
                                return this.neg().div(divisor).neg();
                            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
                            res = ZERO;
                        } else {
                            if (!divisor.unsigned) divisor = divisor.toUnsigned();
                            if (divisor.gt(this)) return UZERO;
                            if (divisor.gt(this.shru(1))) return UONE;
                            res = UZERO;
                        }
                        rem = this;
                        while (rem.gte(divisor)) {
                            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
                            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
                            while (approxRem.isNegative() || approxRem.gt(rem)) {
                                approx -= delta;
                                approxRes = fromNumber(approx, this.unsigned);
                                approxRem = approxRes.mul(divisor);
                            }
                            if (approxRes.isZero()) approxRes = ONE;
                            res = res.add(approxRes);
                            rem = rem.sub(approxRem);
                        }
                        return res;
                    };
                    TWO_PWR_16_DBL.div = TWO_PWR_16_DBL.divide;
                    TWO_PWR_16_DBL.modulo = function(divisor) {
                        if (!isLong(divisor)) divisor = fromValue(divisor);
                        if (wasm) {
                            var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
                            return fromBits(low, wasm["get_high"](), this.unsigned);
                        }
                        return this.sub(this.div(divisor).mul(divisor));
                    };
                    TWO_PWR_16_DBL.mod = TWO_PWR_16_DBL.modulo;
                    TWO_PWR_16_DBL.rem = TWO_PWR_16_DBL.modulo;
                    TWO_PWR_16_DBL.not = function() {
                        return fromBits(~this.low, ~this.high, this.unsigned);
                    };
                    TWO_PWR_16_DBL.countLeadingZeros = function() {
                        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
                    };
                    TWO_PWR_16_DBL.clz = TWO_PWR_16_DBL.countLeadingZeros;
                    TWO_PWR_16_DBL.countTrailingZeros = function() {
                        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
                    };
                    TWO_PWR_16_DBL.ctz = TWO_PWR_16_DBL.countTrailingZeros;
                    TWO_PWR_16_DBL.and = function(other) {
                        if (!isLong(other)) other = fromValue(other);
                        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
                    };
                    TWO_PWR_16_DBL.or = function(other) {
                        if (!isLong(other)) other = fromValue(other);
                        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
                    };
                    TWO_PWR_16_DBL.xor = function(other) {
                        if (!isLong(other)) other = fromValue(other);
                        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
                    };
                    TWO_PWR_16_DBL.shiftLeft = function(numBits) {
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if (0 === (numBits &= 63)) return this; else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned); else return fromBits(0, this.low << numBits - 32, this.unsigned);
                    };
                    TWO_PWR_16_DBL.shl = TWO_PWR_16_DBL.shiftLeft;
                    TWO_PWR_16_DBL.shiftRight = function(numBits) {
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if (0 === (numBits &= 63)) return this; else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned); else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
                    };
                    TWO_PWR_16_DBL.shr = TWO_PWR_16_DBL.shiftRight;
                    TWO_PWR_16_DBL.shiftRightUnsigned = function(numBits) {
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if (0 === (numBits &= 63)) return this;
                        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
                        if (32 === numBits) return fromBits(this.high, 0, this.unsigned);
                        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
                    };
                    TWO_PWR_16_DBL.shru = TWO_PWR_16_DBL.shiftRightUnsigned;
                    TWO_PWR_16_DBL.shr_u = TWO_PWR_16_DBL.shiftRightUnsigned;
                    TWO_PWR_16_DBL.rotateLeft = function(numBits) {
                        var b;
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if (0 === (numBits &= 63)) return this;
                        if (32 === numBits) return fromBits(this.high, this.low, this.unsigned);
                        if (numBits < 32) {
                            b = 32 - numBits;
                            return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
                        }
                        numBits -= 32;
                        b = 32 - numBits;
                        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
                    };
                    TWO_PWR_16_DBL.rotl = TWO_PWR_16_DBL.rotateLeft;
                    TWO_PWR_16_DBL.rotateRight = function(numBits) {
                        var b;
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if (0 === (numBits &= 63)) return this;
                        if (32 === numBits) return fromBits(this.high, this.low, this.unsigned);
                        if (numBits < 32) {
                            b = 32 - numBits;
                            return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
                        }
                        numBits -= 32;
                        b = 32 - numBits;
                        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
                    };
                    TWO_PWR_16_DBL.rotr = TWO_PWR_16_DBL.rotateRight;
                    TWO_PWR_16_DBL.toSigned = function() {
                        if (!this.unsigned) return this;
                        return fromBits(this.low, this.high, false);
                    };
                    TWO_PWR_16_DBL.toUnsigned = function() {
                        if (this.unsigned) return this;
                        return fromBits(this.low, this.high, true);
                    };
                    TWO_PWR_16_DBL.toBytes = function(le) {
                        return le ? this.toBytesLE() : this.toBytesBE();
                    };
                    TWO_PWR_16_DBL.toBytesLE = function() {
                        var hi = this.high, lo = this.low;
                        return [ 255 & lo, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, 255 & hi, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24 ];
                    };
                    TWO_PWR_16_DBL.toBytesBE = function() {
                        var hi = this.high, lo = this.low;
                        return [ hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, 255 & hi, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, 255 & lo ];
                    };
                    Long.fromBytes = function(bytes, unsigned, le) {
                        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
                    };
                    Long.fromBytesLE = function(bytes, unsigned) {
                        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
                    };
                    Long.fromBytesBE = function(bytes, unsigned) {
                        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
                    };
                    TWO_PWR_24_DBL = Long;
                    exports.default = TWO_PWR_24_DBL;
                    return "default" in exports ? exports.default : exports;
                }({});
                if (true) __WEBPACK_AMD_DEFINE_ARRAY__ = [], exports = function() {
                    return Long;
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), void 0 !== exports && (module.exports = exports);
            },
            "?37c5": () => {},
            "?41db": () => {},
            "?77a7": () => {},
            "?84d9": () => {},
            "?c549": () => {}
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (void 0 !== cachedModule) return cachedModule.exports;
            cachedModule = __webpack_module_cache__[moduleId] = {
                exports: {}
            };
            __webpack_modules__[moduleId].call(cachedModule.exports, cachedModule, cachedModule.exports, __webpack_require__);
            return cachedModule.exports;
        }
        (() => {
            __webpack_require__.g = function() {
                if ("object" === typeof globalThis) return globalThis;
                try {
                    return this || new Function("return this")();
                } catch (e) {
                    if ("object" === typeof window) return window;
                }
            }();
        })();
        var __webpack_exports__ = __webpack_require__("./index.js");
        return __webpack_exports__;
    })();
});
//# sourceMappingURL=solclient-full.js.map